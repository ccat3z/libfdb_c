#define POST_ACTOR_COMPILER 1
#line 1 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
/*
 * NativeAPI.actor.cpp
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2013-2022 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "fdbclient/NativeAPI.actor.h"

#include <algorithm>
#include <iterator>
#include <memory>
#include <regex>
#include <unordered_set>
#include <tuple>
#include <utility>
#include <vector>

#include "boost/algorithm/string.hpp"
#include "fmt/format.h"

#include "fdbclient/FDBOptions.g.h"
#include "fdbclient/FDBTypes.h"
#include "fdbrpc/FailureMonitor.h"
#include "fdbrpc/MultiInterface.h"

#include "fdbclient/ActorLineageProfiler.h"
#include "fdbclient/AnnotateActor.h"
#include "fdbclient/Atomic.h"
#include "fdbclient/BlobGranuleCommon.h"
#include "fdbclient/ClusterInterface.h"
#include "fdbclient/ClusterConnectionFile.h"
#include "fdbclient/CoordinationInterface.h"
#include "fdbclient/DatabaseContext.h"
#include "fdbclient/GlobalConfig.actor.h"
#include "fdbclient/IKnobCollection.h"
#include "fdbclient/Knobs.h"
#include "fdbclient/JsonBuilder.h"
#include "fdbclient/KeyBackedTypes.h"
#include "fdbclient/KeyRangeMap.h"
#include "fdbclient/ManagementAPI.actor.h"
#include "fdbclient/NameLineage.h"
#include "fdbclient/CommitProxyInterface.h"
#include "fdbclient/MonitorLeader.h"
#include "fdbclient/MutationList.h"
#include "fdbclient/ReadYourWrites.h"
#include "fdbclient/ParallelStream.actor.h"
#include "fdbclient/SpecialKeySpace.actor.h"
#include "fdbclient/StorageServerInterface.h"
#include "fdbclient/SystemData.h"
#include "fdbclient/TransactionLineage.h"
#include "fdbclient/versions.h"
#include "fdbclient/WellKnownEndpoints.h"
#include "fdbrpc/LoadBalance.h"
#include "fdbrpc/Net2FileSystem.h"
#include "fdbrpc/simulator.h"
#include "fdbrpc/sim_validation.h"
#include "flow/Arena.h"
#include "flow/ActorCollection.h"
#include "flow/DeterministicRandom.h"
#include "flow/Error.h"
#include "flow/FastRef.h"
#include "flow/IRandom.h"
#include "flow/Trace.h"
#include "flow/ProtocolVersion.h"
#include "flow/flow.h"
#include "flow/genericactors.actor.h"
#include "flow/Knobs.h"
#include "flow/Platform.h"
#include "flow/SystemMonitor.h"
#include "flow/TLSConfig.actor.h"
#include "flow/Tracing.h"
#include "flow/UnitTest.h"
#include "flow/network.h"
#include "flow/serialize.h"

#ifdef ADDRESS_SANITIZER
#include <sanitizer/lsan_interface.h>
#endif

#ifdef WIN32
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#undef min
#undef max
#else
#include <time.h>
#endif
#include "flow/actorcompiler.h" // This must be the last #include.

extern const char* getSourceVersion();

namespace {

TransactionLineageCollector transactionLineageCollector;
NameLineageCollector nameLineageCollector;

template <class Interface, class Request>
Future<REPLY_TYPE(Request)> loadBalance(
    DatabaseContext* ctx,
    const Reference<LocationInfo> alternatives,
    RequestStream<Request> Interface::*channel,
    const Request& request = Request(),
    TaskPriority taskID = TaskPriority::DefaultPromiseEndpoint,
    AtMostOnce atMostOnce =
        AtMostOnce::False, // if true, throws request_maybe_delivered() instead of retrying automatically
    QueueModel* model = nullptr) {
	if (alternatives->hasCaches) {
		return loadBalance(alternatives->locations(), channel, request, taskID, atMostOnce, model);
	}
	return fmap(
	    [ctx](auto const& res) {
		    if (res.cached) {
			    ctx->updateCache.trigger();
		    }
		    return res;
	    },
	    loadBalance(alternatives->locations(), channel, request, taskID, atMostOnce, model));
}
} // namespace

FDB_BOOLEAN_PARAM(TransactionRecordLogInfo);
FDB_DEFINE_BOOLEAN_PARAM(UseProvisionalProxies);

// Used to determine whether or not client will load balance based on the number of GRVs released by each proxy
FDB_DEFINE_BOOLEAN_PARAM(BalanceOnRequests);

// Whether or not a request should include the tenant name
FDB_BOOLEAN_PARAM(UseTenant);

NetworkOptions networkOptions;
TLSConfig tlsConfig(TLSEndpointType::CLIENT);

// The default values, TRACE_DEFAULT_ROLL_SIZE and TRACE_DEFAULT_MAX_LOGS_SIZE are located in Trace.h.
NetworkOptions::NetworkOptions()
  : traceRollSize(TRACE_DEFAULT_ROLL_SIZE), traceMaxLogsSize(TRACE_DEFAULT_MAX_LOGS_SIZE), traceLogGroup("default"),
    traceFormat("xml"), traceClockSource("now"),
    supportedVersions(new ReferencedObject<Standalone<VectorRef<ClientVersionRef>>>()), runLoopProfilingEnabled(false),
    primaryClient(true) {}

static const Key CLIENT_LATENCY_INFO_PREFIX = LiteralStringRef("client_latency/");
static const Key CLIENT_LATENCY_INFO_CTR_PREFIX = LiteralStringRef("client_latency_counter/");

void DatabaseContext::addTssMapping(StorageServerInterface const& ssi, StorageServerInterface const& tssi) {
	auto result = tssMapping.find(ssi.id());
	// Update tss endpoint mapping if ss isn't in mapping, or the interface it mapped to changed
	if (result == tssMapping.end() ||
	    result->second.getValue.getEndpoint().token.first() != tssi.getValue.getEndpoint().token.first()) {
		Reference<TSSMetrics> metrics;
		if (result == tssMapping.end()) {
			// new TSS pairing
			metrics = makeReference<TSSMetrics>();
			tssMetrics[tssi.id()] = metrics;
			tssMapping[ssi.id()] = tssi;
		} else {
			if (result->second.id() == tssi.id()) {
				metrics = tssMetrics[tssi.id()];
			} else {
				TEST(true); // SS now maps to new TSS! This will probably never happen in practice
				tssMetrics.erase(result->second.id());
				metrics = makeReference<TSSMetrics>();
				tssMetrics[tssi.id()] = metrics;
			}
			result->second = tssi;
		}

		// data requests duplicated for load and data comparison
		queueModel.updateTssEndpoint(ssi.getValue.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.getValue.getEndpoint(), metrics));
		queueModel.updateTssEndpoint(ssi.getKey.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.getKey.getEndpoint(), metrics));
		queueModel.updateTssEndpoint(ssi.getKeyValues.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.getKeyValues.getEndpoint(), metrics));
		queueModel.updateTssEndpoint(ssi.getMappedKeyValues.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.getMappedKeyValues.getEndpoint(), metrics));
		queueModel.updateTssEndpoint(ssi.getKeyValuesStream.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.getKeyValuesStream.getEndpoint(), metrics));

		// non-data requests duplicated for load
		queueModel.updateTssEndpoint(ssi.watchValue.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.watchValue.getEndpoint(), metrics));
		queueModel.updateTssEndpoint(ssi.splitMetrics.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.splitMetrics.getEndpoint(), metrics));
		queueModel.updateTssEndpoint(ssi.getReadHotRanges.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.getReadHotRanges.getEndpoint(), metrics));
		queueModel.updateTssEndpoint(ssi.getRangeSplitPoints.getEndpoint().token.first(),
		                             TSSEndpointData(tssi.id(), tssi.getRangeSplitPoints.getEndpoint(), metrics));
	}
}

void DatabaseContext::removeTssMapping(StorageServerInterface const& ssi) {
	auto result = tssMapping.find(ssi.id());
	if (result != tssMapping.end()) {
		tssMetrics.erase(ssi.id());
		tssMapping.erase(result);
		queueModel.removeTssEndpoint(ssi.getValue.getEndpoint().token.first());
		queueModel.removeTssEndpoint(ssi.getKey.getEndpoint().token.first());
		queueModel.removeTssEndpoint(ssi.getKeyValues.getEndpoint().token.first());
		queueModel.removeTssEndpoint(ssi.getMappedKeyValues.getEndpoint().token.first());
		queueModel.removeTssEndpoint(ssi.getKeyValuesStream.getEndpoint().token.first());

		queueModel.removeTssEndpoint(ssi.watchValue.getEndpoint().token.first());
		queueModel.removeTssEndpoint(ssi.splitMetrics.getEndpoint().token.first());
		queueModel.removeTssEndpoint(ssi.getReadHotRanges.getEndpoint().token.first());
		queueModel.removeTssEndpoint(ssi.getRangeSplitPoints.getEndpoint().token.first());
	}
}

void DatabaseContext::addSSIdTagMapping(const UID& uid, const Tag& tag) {
	ssidTagMapping[uid] = tag;
}

void DatabaseContext::getLatestCommitVersionForSSID(const UID& ssid, Tag& tag, Version& commitVersion) {
	// initialization
	tag = invalidTag;
	commitVersion = invalidVersion;

	auto iter = ssidTagMapping.find(ssid);
	if (iter != ssidTagMapping.end()) {
		tag = iter->second;

		if (ssVersionVectorCache.hasVersion(tag)) {
			commitVersion = ssVersionVectorCache.getVersion(tag);
		}
	}
}

void DatabaseContext::getLatestCommitVersion(const StorageServerInterface& ssi,
                                             Version readVersion,
                                             VersionVector& latestCommitVersion) {
	latestCommitVersion.clear();

	if (ssVersionVectorCache.getMaxVersion() == invalidVersion) {
		return;
	}

	// Error checking (based on the assumption that the read version was not obtained
	// from the client's grv cache).
	if (readVersion > ssVersionVectorCache.getMaxVersion()) {
		TraceEvent(SevError, "ReadVersionExceedsVersionVectorMax")
		    .detail("ReadVersion", readVersion)
		    .detail("VersionVector", ssVersionVectorCache.toString());
		if (g_network->isSimulated()) {
			ASSERT(false);
		} else {
			return; // Do not return a stale commit version in production.
		}
	}

	Tag tag = invalidTag;
	Version commitVersion = invalidVersion;
	getLatestCommitVersionForSSID(ssi.id(), tag, commitVersion);

	if (tag != invalidTag && commitVersion != invalidVersion && commitVersion < readVersion) {
		latestCommitVersion.setVersion(tag, commitVersion);
	}
}

void DatabaseContext::getLatestCommitVersions(const Reference<LocationInfo>& locationInfo,
                                              Version readVersion,
                                              Reference<TransactionState> info,
                                              VersionVector& latestCommitVersions) {
	latestCommitVersions.clear();

	if (info->debugID.present()) {
		g_traceBatch.addEvent("TransactionDebug", info->debugID.get().first(), "NativeAPI.getLatestCommitVersions");
	}

	if (!info->readVersionObtainedFromGrvProxy) {
		return;
	}

	if (ssVersionVectorCache.getMaxVersion() == invalidVersion) {
		return;
	}

	if (readVersion > ssVersionVectorCache.getMaxVersion()) {
		if (!CLIENT_KNOBS->FORCE_GRV_CACHE_OFF && !info->options.skipGrvCache && info->options.useGrvCache) {
			return;
		} else {
			TraceEvent(SevError, "GetLatestCommitVersions")
			    .detail("ReadVersion", readVersion)
			    .detail("VersionVector", ssVersionVectorCache.toString());
			ASSERT(false);
		}
	}

	std::map<Version, std::set<Tag>> versionMap; // order the versions to be returned
	for (int i = 0; i < locationInfo->locations()->size(); i++) {
		Tag tag = invalidTag;
		Version commitVersion = invalidVersion; // latest commit version
		getLatestCommitVersionForSSID(locationInfo->locations()->getId(i), tag, commitVersion);

		bool updatedVersionMap = false;
		if (tag != invalidTag && commitVersion != invalidVersion && commitVersion < readVersion) {
			updatedVersionMap = true;
			versionMap[commitVersion].insert(tag);
		}

		// Do not log if commitVersion >= readVersion.
		if (!updatedVersionMap && commitVersion == invalidVersion) {
			TraceEvent(SevDebug, "CommitVersionNotFoundForSS")
			    .detail("InSSIDMap", tag != invalidTag ? 1 : 0)
			    .detail("Tag", tag)
			    .detail("CommitVersion", commitVersion)
			    .detail("ReadVersion", readVersion)
			    .detail("VersionVector", ssVersionVectorCache.toString())
			    .setMaxEventLength(11000)
			    .setMaxFieldLength(10000);
			++transactionCommitVersionNotFoundForSS;
		}
	}

	// insert the commit versions in the version vector.
	for (auto& iter : versionMap) {
		latestCommitVersions.setVersion(iter.second, iter.first);
	}
}

void updateCachedReadVersionShared(double t, Version v, DatabaseSharedState* p) {
	MutexHolder mutex(p->mutexLock);
	if (v >= p->grvCacheSpace.cachedReadVersion) {
		//TraceEvent(SevDebug, "CacheReadVersionUpdate")
		//    .detail("Version", v)
		//    .detail("CurTime", t)
		//    .detail("LastVersion", p->grvCacheSpace.cachedReadVersion)
		//    .detail("LastTime", p->grvCacheSpace.lastGrvTime);
		p->grvCacheSpace.cachedReadVersion = v;
		if (t > p->grvCacheSpace.lastGrvTime) {
			p->grvCacheSpace.lastGrvTime = t;
		}
	}
}

void DatabaseContext::updateCachedReadVersion(double t, Version v) {
	if (sharedStatePtr) {
		return updateCachedReadVersionShared(t, v, sharedStatePtr);
	}
	if (v >= cachedReadVersion) {
		//TraceEvent(SevDebug, "CachedReadVersionUpdate")
		//    .detail("Version", v)
		//    .detail("GrvStartTime", t)
		//    .detail("LastVersion", cachedReadVersion)
		//    .detail("LastTime", lastGrvTime);
		cachedReadVersion = v;
		// Since the time is based on the start of the request, it's possible that we
		// get a newer version with an older time.
		// (Request started earlier, but was latest to reach the proxy)
		// Only update time when strictly increasing (?)
		if (t > lastGrvTime) {
			lastGrvTime = t;
		}
	}
}

Version DatabaseContext::getCachedReadVersion() {
	if (sharedStatePtr) {
		MutexHolder mutex(sharedStatePtr->mutexLock);
		return sharedStatePtr->grvCacheSpace.cachedReadVersion;
	}
	return cachedReadVersion;
}

double DatabaseContext::getLastGrvTime() {
	if (sharedStatePtr) {
		MutexHolder mutex(sharedStatePtr->mutexLock);
		return sharedStatePtr->grvCacheSpace.lastGrvTime;
	}
	return lastGrvTime;
}

Reference<StorageServerInfo> StorageServerInfo::getInterface(DatabaseContext* cx,
                                                             StorageServerInterface const& ssi,
                                                             LocalityData const& locality) {
	auto it = cx->server_interf.find(ssi.id());
	if (it != cx->server_interf.end()) {
		if (it->second->interf.getValue.getEndpoint().token != ssi.getValue.getEndpoint().token) {
			if (it->second->interf.locality == ssi.locality) {
				// FIXME: load balance holds pointers to individual members of the interface, and this assignment will
				// swap out the object they are
				//       pointing to. This is technically correct, but is very unnatural. We may want to refactor load
				//       balance to take an AsyncVar<Reference<Interface>> so that it is notified when the interface
				//       changes.

				it->second->interf = ssi;
			} else {
				it->second->notifyContextDestroyed();
				Reference<StorageServerInfo> loc(new StorageServerInfo(cx, ssi, locality));
				cx->server_interf[ssi.id()] = loc.getPtr();
				return loc;
			}
		}

		return Reference<StorageServerInfo>::addRef(it->second);
	}

	Reference<StorageServerInfo> loc(new StorageServerInfo(cx, ssi, locality));
	cx->server_interf[ssi.id()] = loc.getPtr();
	return loc;
}

void StorageServerInfo::notifyContextDestroyed() {
	cx = nullptr;
}

StorageServerInfo::~StorageServerInfo() {
	if (cx) {
		auto it = cx->server_interf.find(interf.id());
		if (it != cx->server_interf.end())
			cx->server_interf.erase(it);
		cx = nullptr;
	}
}

std::string printable(const VectorRef<KeyValueRef>& val) {
	std::string s;
	for (int i = 0; i < val.size(); i++)
		s = s + printable(val[i].key) + format(":%d ", val[i].value.size());
	return s;
}

std::string printable(const KeyValueRef& val) {
	return printable(val.key) + format(":%d ", val.value.size());
}

std::string printable(const VectorRef<StringRef>& val) {
	std::string s;
	for (int i = 0; i < val.size(); i++)
		s = s + printable(val[i]) + " ";
	return s;
}

std::string printable(const StringRef& val) {
	return val.printable();
}
std::string printable(const std::string& str) {
	return StringRef(str).printable();
}

std::string printable(const KeyRangeRef& range) {
	return printable(range.begin) + " - " + printable(range.end);
}

std::string printable(const VectorRef<KeyRangeRef>& val) {
	std::string s;
	for (int i = 0; i < val.size(); i++)
		s = s + printable(val[i]) + " ";
	return s;
}

int unhex(char c) {
	if (c >= '0' && c <= '9')
		return c - '0';
	if (c >= 'a' && c <= 'f')
		return c - 'a' + 10;
	if (c >= 'A' && c <= 'F')
		return c - 'A' + 10;
	UNREACHABLE();
}

std::string unprintable(std::string const& val) {
	std::string s;
	for (int i = 0; i < val.size(); i++) {
		char c = val[i];
		if (c == '\\') {
			if (++i == val.size())
				ASSERT(false);
			if (val[i] == '\\') {
				s += '\\';
			} else if (val[i] == 'x') {
				if (i + 2 >= val.size())
					ASSERT(false);
				s += char((unhex(val[i + 1]) << 4) + unhex(val[i + 2]));
				i += 2;
			} else
				ASSERT(false);
		} else
			s += c;
	}
	return s;
}

void DatabaseContext::validateVersion(Version version) const {
	// Version could be 0 if the INITIALIZE_NEW_DATABASE option is set. In that case, it is illegal to perform any
	// reads. We throw client_invalid_operation because the caller didn't directly set the version, so the
	// version_invalid error might be confusing.
	if (version == 0) {
		throw client_invalid_operation();
	}
	if (switchable && version < minAcceptableReadVersion) {
		TEST(true); // Attempted to read a version lower than any this client has seen from the current cluster
		throw transaction_too_old();
	}

	ASSERT(version > 0 || version == latestVersion);
}

void validateOptionValuePresent(Optional<StringRef> value) {
	if (!value.present()) {
		throw invalid_option_value();
	}
}

void validateOptionValueNotPresent(Optional<StringRef> value) {
	if (value.present() && value.get().size() > 0) {
		throw invalid_option_value();
	}
}

void dumpMutations(const MutationListRef& mutations) {
	for (auto m = mutations.begin(); m; ++m) {
		switch (m->type) {
		case MutationRef::SetValue:
			printf("  '%s' := '%s'\n", printable(m->param1).c_str(), printable(m->param2).c_str());
			break;
		case MutationRef::AddValue:
			printf("  '%s' += '%s'", printable(m->param1).c_str(), printable(m->param2).c_str());
			break;
		case MutationRef::ClearRange:
			printf("  Clear ['%s','%s')\n", printable(m->param1).c_str(), printable(m->param2).c_str());
			break;
		default:
			printf("  Unknown mutation %d('%s','%s')\n",
			       m->type,
			       printable(m->param1).c_str(),
			       printable(m->param2).c_str());
			break;
		}
	}
}

template <>
void addref(DatabaseContext* ptr) {
	ptr->addref();
}
template <>
void delref(DatabaseContext* ptr) {
	ptr->delref();
}

void traceTSSErrors(const char* name, UID tssId, const std::unordered_map<int, uint64_t>& errorsByCode) {
	TraceEvent ev(name, tssId);
	for (auto& it : errorsByCode) {
		ev.detail("E" + std::to_string(it.first), it.second);
	}
}

/*
    For each request type, this will produce
    <Type>Count
    <Type>{SS,TSS}{Mean,P50,P90,P99}
    Example:
    GetValueLatencySSMean
*/
void traceSSOrTSSPercentiles(TraceEvent& ev, const std::string name, ContinuousSample<double>& sample) {
	ev.detail(name + "Mean", sample.mean());
	// don't log the larger percentiles unless we actually have enough samples to log the accurate percentile instead of
	// the largest sample in this window
	if (sample.getPopulationSize() >= 3) {
		ev.detail(name + "P50", sample.median());
	}
	if (sample.getPopulationSize() >= 10) {
		ev.detail(name + "P90", sample.percentile(0.90));
	}
	if (sample.getPopulationSize() >= 100) {
		ev.detail(name + "P99", sample.percentile(0.99));
	}
}

void traceTSSPercentiles(TraceEvent& ev,
                         const std::string name,
                         ContinuousSample<double>& ssSample,
                         ContinuousSample<double>& tssSample) {
	ASSERT(ssSample.getPopulationSize() == tssSample.getPopulationSize());
	ev.detail(name + "Count", ssSample.getPopulationSize());
	if (ssSample.getPopulationSize() > 0) {
		traceSSOrTSSPercentiles(ev, name + "SS", ssSample);
		traceSSOrTSSPercentiles(ev, name + "TSS", tssSample);
	}
}

															#line 597 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via tssLogger()
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class TssLoggerActor>
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TssLoggerActorState {
															#line 604 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TssLoggerActorState(DatabaseContext* const& cx) 
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 596 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   lastLogged(0)
															#line 613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("tssLogger", reinterpret_cast<unsigned long>(this));

	}
	~TssLoggerActorState() 
	{
		fdb_probe_actor_destroy("tssLogger", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 597 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TssLoggerActorState();
		static_cast<TssLoggerActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 598 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = delay(CLIENT_KNOBS->TSS_METRICS_LOGGING_INTERVAL, TaskPriority::FlushTrace);
															#line 598 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<TssLoggerActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<TssLoggerActor*>(this)->actor_wait_state = 1;
															#line 598 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TssLoggerActor, 0, Void >*>(static_cast<TssLoggerActor*>(this)));
															#line 665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 601 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& it : cx->tssMetrics ) {
															#line 602 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second->detailedMismatches.size())
															#line 676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 603 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->tssMismatchStream.send( std::pair<UID, std::vector<DetailedTSSMismatch>>(it.first, it.second->detailedMismatches));
															#line 680 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second->ssErrorsByCode.size())
															#line 684 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 609 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				traceTSSErrors("TSS_SSErrors", it.first, it.second->ssErrorsByCode);
															#line 688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 612 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second->tssErrorsByCode.size())
															#line 692 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				traceTSSErrors("TSS_TSSErrors", it.first, it.second->tssErrorsByCode);
															#line 696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent tssEv("TSSClientMetrics", cx->dbId);
															#line 617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tssEv.detail("TSSID", it.first) .detail("Elapsed", (lastLogged == 0) ? 0 : now() - lastLogged) .detail("Internal", cx->internal);
															#line 621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			it.second->cc.logToTraceEvent(tssEv);
															#line 623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles(tssEv, "GetValueLatency", it.second->SSgetValueLatency, it.second->TSSgetValueLatency);
															#line 624 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles( tssEv, "GetKeyValuesLatency", it.second->SSgetKeyValuesLatency, it.second->TSSgetKeyValuesLatency);
															#line 626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles(tssEv, "GetKeyLatency", it.second->SSgetKeyLatency, it.second->TSSgetKeyLatency);
															#line 627 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles(tssEv, "GetMappedKeyValuesLatency", it.second->SSgetMappedKeyValuesLatency, it.second->TSSgetMappedKeyValuesLatency);
															#line 632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			it.second->clear();
															#line 714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 635 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastLogged = now();
															#line 718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 601 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& it : cx->tssMetrics ) {
															#line 602 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second->detailedMismatches.size())
															#line 729 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 603 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->tssMismatchStream.send( std::pair<UID, std::vector<DetailedTSSMismatch>>(it.first, it.second->detailedMismatches));
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second->ssErrorsByCode.size())
															#line 737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 609 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				traceTSSErrors("TSS_SSErrors", it.first, it.second->ssErrorsByCode);
															#line 741 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 612 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second->tssErrorsByCode.size())
															#line 745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				traceTSSErrors("TSS_TSSErrors", it.first, it.second->tssErrorsByCode);
															#line 749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent tssEv("TSSClientMetrics", cx->dbId);
															#line 617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tssEv.detail("TSSID", it.first) .detail("Elapsed", (lastLogged == 0) ? 0 : now() - lastLogged) .detail("Internal", cx->internal);
															#line 621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			it.second->cc.logToTraceEvent(tssEv);
															#line 623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles(tssEv, "GetValueLatency", it.second->SSgetValueLatency, it.second->TSSgetValueLatency);
															#line 624 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles( tssEv, "GetKeyValuesLatency", it.second->SSgetKeyValuesLatency, it.second->TSSgetKeyValuesLatency);
															#line 626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles(tssEv, "GetKeyLatency", it.second->SSgetKeyLatency, it.second->TSSgetKeyLatency);
															#line 627 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			traceTSSPercentiles(tssEv, "GetMappedKeyValuesLatency", it.second->SSgetMappedKeyValuesLatency, it.second->TSSgetMappedKeyValuesLatency);
															#line 632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			it.second->clear();
															#line 767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 635 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastLogged = now();
															#line 771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TssLoggerActor*>(this)->actor_wait_state > 0) static_cast<TssLoggerActor*>(this)->actor_wait_state = 0;
		static_cast<TssLoggerActor*>(this)->ActorCallback< TssLoggerActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TssLoggerActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tssLogger", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssLogger", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TssLoggerActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tssLogger", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssLogger", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TssLoggerActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tssLogger", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssLogger", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 596 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double lastLogged;
															#line 843 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via tssLogger()
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TssLoggerActor final : public Actor<Void>, public ActorCallback< TssLoggerActor, 0, Void >, public FastAllocated<TssLoggerActor>, public TssLoggerActorState<TssLoggerActor> {
															#line 848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<TssLoggerActor>::operator new;
	using FastAllocated<TssLoggerActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< TssLoggerActor, 0, Void >;
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TssLoggerActor(DatabaseContext* const& cx) 
															#line 859 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   TssLoggerActorState<TssLoggerActor>(cx)
	{
		fdb_probe_actor_enter("tssLogger", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tssLogger");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tssLogger", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TssLoggerActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> tssLogger( DatabaseContext* const& cx ) {
															#line 595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new TssLoggerActor(cx));
															#line 887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 638 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via databaseLogger()
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class DatabaseLoggerActor>
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class DatabaseLoggerActorState {
															#line 899 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseLoggerActorState(DatabaseContext* const& cx) 
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 640 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   lastLogged(0)
															#line 908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("databaseLogger", reinterpret_cast<unsigned long>(this));

	}
	~DatabaseLoggerActorState() 
	{
		fdb_probe_actor_destroy("databaseLogger", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 641 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 923 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DatabaseLoggerActorState();
		static_cast<DatabaseLoggerActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = delay(CLIENT_KNOBS->SYSTEM_MONITOR_INTERVAL, TaskPriority::FlushTrace);
															#line 642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<DatabaseLoggerActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<DatabaseLoggerActor*>(this)->actor_wait_state = 1;
															#line 642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DatabaseLoggerActor, 0, Void >*>(static_cast<DatabaseLoggerActor*>(this)));
															#line 960 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!g_network->isSimulated())
															#line 969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent ev("TransactionMetrics", cx->dbId);
															#line 647 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ev.detail("Elapsed", (lastLogged == 0) ? 0 : now() - lastLogged) .detail("Cluster", cx->getConnectionRecord() ? cx->getConnectionRecord()->getConnectionString().clusterKeyName().toString() : "") .detail("Internal", cx->internal);
															#line 654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->cc.logToTraceEvent(ev);
															#line 656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ev.detail("LocationCacheEntryCount", cx->locationCache.size());
															#line 657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ev.detail("MeanLatency", cx->latencies.mean()) .detail("MedianLatency", cx->latencies.median()) .detail("Latency90", cx->latencies.percentile(0.90)) .detail("Latency98", cx->latencies.percentile(0.98)) .detail("MaxLatency", cx->latencies.max()) .detail("MeanRowReadLatency", cx->readLatencies.mean()) .detail("MedianRowReadLatency", cx->readLatencies.median()) .detail("MaxRowReadLatency", cx->readLatencies.max()) .detail("MeanGRVLatency", cx->GRVLatencies.mean()) .detail("MedianGRVLatency", cx->GRVLatencies.median()) .detail("MaxGRVLatency", cx->GRVLatencies.max()) .detail("MeanCommitLatency", cx->commitLatencies.mean()) .detail("MedianCommitLatency", cx->commitLatencies.median()) .detail("MaxCommitLatency", cx->commitLatencies.max()) .detail("MeanMutationsPerCommit", cx->mutationsPerCommit.mean()) .detail("MedianMutationsPerCommit", cx->mutationsPerCommit.median()) .detail("MaxMutationsPerCommit", cx->mutationsPerCommit.max()) .detail("MeanBytesPerCommit", cx->bytesPerCommit.mean()) .detail("MedianBytesPerCommit", cx->bytesPerCommit.median()) .detail("MaxBytesPerCommit", cx->bytesPerCommit.max()) .detail("NumLocalityCacheEntries", cx->locationCache.size());
															#line 678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (cx->anyBlobGranuleRequests)
															#line 983 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ev.detail("MeanBGLatency", cx->bgLatencies.mean()) .detail("MedianBGLatency", cx->bgLatencies.median()) .detail("MaxBGLatency", cx->bgLatencies.max()) .detail("MeanBGGranulesPerRequest", cx->bgGranulesPerRequest.mean()) .detail("MedianBGGranulesPerRequest", cx->bgGranulesPerRequest.median()) .detail("MaxBGGranulesPerRequest", cx->bgGranulesPerRequest.max());
															#line 987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->latencies.clear();
															#line 689 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->readLatencies.clear();
															#line 690 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->GRVLatencies.clear();
															#line 691 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->commitLatencies.clear();
															#line 692 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->mutationsPerCommit.clear();
															#line 693 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->bytesPerCommit.clear();
															#line 694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->bgLatencies.clear();
															#line 695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->bgGranulesPerRequest.clear();
															#line 697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastLogged = now();
															#line 1008 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!g_network->isSimulated())
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent ev("TransactionMetrics", cx->dbId);
															#line 647 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ev.detail("Elapsed", (lastLogged == 0) ? 0 : now() - lastLogged) .detail("Cluster", cx->getConnectionRecord() ? cx->getConnectionRecord()->getConnectionString().clusterKeyName().toString() : "") .detail("Internal", cx->internal);
															#line 654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->cc.logToTraceEvent(ev);
															#line 656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ev.detail("LocationCacheEntryCount", cx->locationCache.size());
															#line 657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ev.detail("MeanLatency", cx->latencies.mean()) .detail("MedianLatency", cx->latencies.median()) .detail("Latency90", cx->latencies.percentile(0.90)) .detail("Latency98", cx->latencies.percentile(0.98)) .detail("MaxLatency", cx->latencies.max()) .detail("MeanRowReadLatency", cx->readLatencies.mean()) .detail("MedianRowReadLatency", cx->readLatencies.median()) .detail("MaxRowReadLatency", cx->readLatencies.max()) .detail("MeanGRVLatency", cx->GRVLatencies.mean()) .detail("MedianGRVLatency", cx->GRVLatencies.median()) .detail("MaxGRVLatency", cx->GRVLatencies.max()) .detail("MeanCommitLatency", cx->commitLatencies.mean()) .detail("MedianCommitLatency", cx->commitLatencies.median()) .detail("MaxCommitLatency", cx->commitLatencies.max()) .detail("MeanMutationsPerCommit", cx->mutationsPerCommit.mean()) .detail("MedianMutationsPerCommit", cx->mutationsPerCommit.median()) .detail("MaxMutationsPerCommit", cx->mutationsPerCommit.max()) .detail("MeanBytesPerCommit", cx->bytesPerCommit.mean()) .detail("MedianBytesPerCommit", cx->bytesPerCommit.median()) .detail("MaxBytesPerCommit", cx->bytesPerCommit.max()) .detail("NumLocalityCacheEntries", cx->locationCache.size());
															#line 678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (cx->anyBlobGranuleRequests)
															#line 1031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ev.detail("MeanBGLatency", cx->bgLatencies.mean()) .detail("MedianBGLatency", cx->bgLatencies.median()) .detail("MaxBGLatency", cx->bgLatencies.max()) .detail("MeanBGGranulesPerRequest", cx->bgGranulesPerRequest.mean()) .detail("MedianBGGranulesPerRequest", cx->bgGranulesPerRequest.median()) .detail("MaxBGGranulesPerRequest", cx->bgGranulesPerRequest.max());
															#line 1035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->latencies.clear();
															#line 689 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->readLatencies.clear();
															#line 690 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->GRVLatencies.clear();
															#line 691 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->commitLatencies.clear();
															#line 692 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->mutationsPerCommit.clear();
															#line 693 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->bytesPerCommit.clear();
															#line 694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->bgLatencies.clear();
															#line 695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->bgGranulesPerRequest.clear();
															#line 697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastLogged = now();
															#line 1056 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DatabaseLoggerActor*>(this)->actor_wait_state > 0) static_cast<DatabaseLoggerActor*>(this)->actor_wait_state = 0;
		static_cast<DatabaseLoggerActor*>(this)->ActorCallback< DatabaseLoggerActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DatabaseLoggerActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("databaseLogger", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("databaseLogger", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DatabaseLoggerActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("databaseLogger", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("databaseLogger", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DatabaseLoggerActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("databaseLogger", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("databaseLogger", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 640 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double lastLogged;
															#line 1128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via databaseLogger()
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class DatabaseLoggerActor final : public Actor<Void>, public ActorCallback< DatabaseLoggerActor, 0, Void >, public FastAllocated<DatabaseLoggerActor>, public DatabaseLoggerActorState<DatabaseLoggerActor> {
															#line 1133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<DatabaseLoggerActor>::operator new;
	using FastAllocated<DatabaseLoggerActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< DatabaseLoggerActor, 0, Void >;
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseLoggerActor(DatabaseContext* const& cx) 
															#line 1144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   DatabaseLoggerActorState<DatabaseLoggerActor>(cx)
	{
		fdb_probe_actor_enter("databaseLogger", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("databaseLogger");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("databaseLogger", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DatabaseLoggerActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> databaseLogger( DatabaseContext* const& cx ) {
															#line 639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new DatabaseLoggerActor(cx));
															#line 1172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 700 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

struct TrInfoChunk {
	ValueRef value;
	Key key;
};

															#line 1182 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via transactionInfoCommitActor()
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class TransactionInfoCommitActorActor>
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TransactionInfoCommitActorActorState {
															#line 1189 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionInfoCommitActorActorState(Transaction* const& tr,std::vector<TrInfoChunk>* const& chunks) 
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : tr(tr),
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   chunks(chunks),
															#line 707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   clientLatencyAtomicCtr(CLIENT_LATENCY_INFO_CTR_PREFIX.withPrefix(fdbClientInfoPrefixRange.begin)),
															#line 708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   retryCount(0)
															#line 1202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this));

	}
	~TransactionInfoCommitActorActorState() 
	{
		fdb_probe_actor_destroy("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 1217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TransactionInfoCommitActorActorState();
		static_cast<TransactionInfoCommitActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->reset();
															#line 712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 713 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			vstamp = tr->getVersionstamp();
															#line 715 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			int64_t numCommitBytes = 0;
															#line 716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& chunk : *chunks ) {
															#line 717 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr->atomicOp(chunk.key, chunk.value, MutationRef::SetVersionstampedKey);
															#line 718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				numCommitBytes += chunk.key.size() + chunk.value.size() - 4;
															#line 1262 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 721 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->atomicOp(clientLatencyAtomicCtr, StringRef((uint8_t*)&numCommitBytes, 8), MutationRef::AddValue);
															#line 722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = tr->commit();
															#line 722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state = 1;
															#line 722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TransactionInfoCommitActorActor, 0, Void >*>(static_cast<TransactionInfoCommitActorActor*>(this)));
															#line 1275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			retryCount++;
															#line 726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (retryCount == 10)
															#line 1299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 1303 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = tr->onError(e);
															#line 728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 1309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_1.get(), loopDepth); };
			static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state = 2;
															#line 728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TransactionInfoCommitActorActor, 1, Void >*>(static_cast<TransactionInfoCommitActorActor*>(this)));
															#line 1314 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<TransactionInfoCommitActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TransactionInfoCommitActorActorState(); static_cast<TransactionInfoCommitActorActor*>(this)->destroy(); return 0; }
															#line 1329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<TransactionInfoCommitActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TransactionInfoCommitActorActorState();
		static_cast<TransactionInfoCommitActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<TransactionInfoCommitActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TransactionInfoCommitActorActorState(); static_cast<TransactionInfoCommitActorActor*>(this)->destroy(); return 0; }
															#line 1341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<TransactionInfoCommitActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~TransactionInfoCommitActorActorState();
		static_cast<TransactionInfoCommitActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state > 0) static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state = 0;
		static_cast<TransactionInfoCommitActorActor*>(this)->ActorCallback< TransactionInfoCommitActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TransactionInfoCommitActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TransactionInfoCommitActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TransactionInfoCommitActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state > 0) static_cast<TransactionInfoCommitActorActor*>(this)->actor_wait_state = 0;
		static_cast<TransactionInfoCommitActorActor*>(this)->ActorCallback< TransactionInfoCommitActorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TransactionInfoCommitActorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TransactionInfoCommitActorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TransactionInfoCommitActorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction* tr;
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<TrInfoChunk>* chunks;
															#line 707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	const Key clientLatencyAtomicCtr;
															#line 708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int retryCount;
															#line 714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Standalone<StringRef>> vstamp;
															#line 1497 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via transactionInfoCommitActor()
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TransactionInfoCommitActorActor final : public Actor<Void>, public ActorCallback< TransactionInfoCommitActorActor, 0, Void >, public ActorCallback< TransactionInfoCommitActorActor, 1, Void >, public FastAllocated<TransactionInfoCommitActorActor>, public TransactionInfoCommitActorActorState<TransactionInfoCommitActorActor> {
															#line 1502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<TransactionInfoCommitActorActor>::operator new;
	using FastAllocated<TransactionInfoCommitActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< TransactionInfoCommitActorActor, 0, Void >;
friend struct ActorCallback< TransactionInfoCommitActorActor, 1, Void >;
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionInfoCommitActorActor(Transaction* const& tr,std::vector<TrInfoChunk>* const& chunks) 
															#line 1514 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   TransactionInfoCommitActorActorState<TransactionInfoCommitActorActor>(tr, chunks)
	{
		fdb_probe_actor_enter("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("transactionInfoCommitActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("transactionInfoCommitActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TransactionInfoCommitActorActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< TransactionInfoCommitActorActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> transactionInfoCommitActor( Transaction* const& tr, std::vector<TrInfoChunk>* const& chunks ) {
															#line 706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new TransactionInfoCommitActorActor(tr, chunks));
															#line 1543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 1548 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via delExcessClntTxnEntriesActor()
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class DelExcessClntTxnEntriesActorActor>
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class DelExcessClntTxnEntriesActorActorState {
															#line 1555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DelExcessClntTxnEntriesActorActorState(Transaction* const& tr,int64_t const& clientTxInfoSizeLimit) 
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : tr(tr),
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   clientTxInfoSizeLimit(clientTxInfoSizeLimit),
															#line 734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   clientLatencyName(CLIENT_LATENCY_INFO_PREFIX.withPrefix(fdbClientInfoPrefixRange.begin)),
															#line 735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   clientLatencyAtomicCtr(CLIENT_LATENCY_INFO_CTR_PREFIX.withPrefix(fdbClientInfoPrefixRange.begin))
															#line 1568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this));

	}
	~DelExcessClntTxnEntriesActorActorState() 
	{
		fdb_probe_actor_destroy("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 736 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevInfo, "DelExcessClntTxnEntriesCalled").log();
															#line 737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 1585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DelExcessClntTxnEntriesActorActorState();
		static_cast<DelExcessClntTxnEntriesActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->reset();
															#line 740 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 741 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = tr->get(KeyRef(clientLatencyAtomicCtr), Snapshot::True);
															#line 742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1624 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 1;
															#line 742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >*>(static_cast<DelExcessClntTxnEntriesActorActor*>(this)));
															#line 1629 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 776 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr->onError(e);
															#line 776 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 1653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 4;
															#line 776 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >*>(static_cast<DelExcessClntTxnEntriesActorActor*>(this)));
															#line 1658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Value> const& ctrValue,int loopDepth) 
	{
															#line 743 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!ctrValue.present())
															#line 1673 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 744 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevInfo, "NumClntTxnEntriesNotFound").log();
															#line 745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DelExcessClntTxnEntriesActorActorState(); static_cast<DelExcessClntTxnEntriesActorActor*>(this)->destroy(); return 0; }
															#line 1679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~DelExcessClntTxnEntriesActorActorState();
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txInfoSize = 0;
															#line 748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(ctrValue.get().size() == sizeof(int64_t));
															#line 749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		memcpy(&txInfoSize, ctrValue.get().begin(), ctrValue.get().size());
															#line 750 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (txInfoSize < clientTxInfoSizeLimit)
															#line 1693 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 751 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DelExcessClntTxnEntriesActorActorState(); static_cast<DelExcessClntTxnEntriesActorActor*>(this)->destroy(); return 0; }
															#line 1697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~DelExcessClntTxnEntriesActorActorState();
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 752 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int getRangeByteLimit = (txInfoSize - clientTxInfoSizeLimit) < CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT ? (txInfoSize - clientTxInfoSizeLimit) : CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT;
															#line 755 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		GetRangeLimits limit(GetRangeLimits::ROW_LIMIT_UNLIMITED, getRangeByteLimit);
															#line 756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResult> __when_expr_1 = tr->getRange(KeyRangeRef(clientLatencyName, strinc(clientLatencyName)), limit);
															#line 756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 2;
															#line 756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >*>(static_cast<DelExcessClntTxnEntriesActorActor*>(this)));
															#line 1716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Value> && ctrValue,int loopDepth) 
	{
															#line 743 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!ctrValue.present())
															#line 1725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 744 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevInfo, "NumClntTxnEntriesNotFound").log();
															#line 745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DelExcessClntTxnEntriesActorActorState(); static_cast<DelExcessClntTxnEntriesActorActor*>(this)->destroy(); return 0; }
															#line 1731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~DelExcessClntTxnEntriesActorActorState();
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txInfoSize = 0;
															#line 748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(ctrValue.get().size() == sizeof(int64_t));
															#line 749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		memcpy(&txInfoSize, ctrValue.get().begin(), ctrValue.get().size());
															#line 750 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (txInfoSize < clientTxInfoSizeLimit)
															#line 1745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 751 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DelExcessClntTxnEntriesActorActorState(); static_cast<DelExcessClntTxnEntriesActorActor*>(this)->destroy(); return 0; }
															#line 1749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~DelExcessClntTxnEntriesActorActorState();
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 752 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int getRangeByteLimit = (txInfoSize - clientTxInfoSizeLimit) < CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT ? (txInfoSize - clientTxInfoSizeLimit) : CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT;
															#line 755 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		GetRangeLimits limit(GetRangeLimits::ROW_LIMIT_UNLIMITED, getRangeByteLimit);
															#line 756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResult> __when_expr_1 = tr->getRange(KeyRangeRef(clientLatencyName, strinc(clientLatencyName)), limit);
															#line 756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 2;
															#line 756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >*>(static_cast<DelExcessClntTxnEntriesActorActor*>(this)));
															#line 1768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> const& ctrValue,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(ctrValue, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> && ctrValue,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(ctrValue), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state > 0) static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 0;
		static_cast<DelExcessClntTxnEntriesActorActor*>(this)->ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(RangeResult const& txEntries,int loopDepth) 
	{
															#line 758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		numBytesToDel = 0;
															#line 759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRef endKey;
															#line 760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& kv : txEntries ) {
															#line 761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			endKey = kv.key;
															#line 762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			numBytesToDel += kv.key.size() + kv.value.size();
															#line 763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (txInfoSize - numBytesToDel <= clientTxInfoSizeLimit)
															#line 1850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
				break;
			}
		}
															#line 766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (numBytesToDel)
															#line 1857 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->clear(KeyRangeRef(txEntries[0].key, strinc(endKey)));
															#line 768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevInfo, "DeletingExcessCntTxnEntries").detail("BytesToBeDeleted", numBytesToDel);
															#line 769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			int64_t bytesDel = -numBytesToDel;
															#line 770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->atomicOp(clientLatencyAtomicCtr, StringRef((uint8_t*)&bytesDel, 8), MutationRef::AddValue);
															#line 771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 3;
															#line 771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >*>(static_cast<DelExcessClntTxnEntriesActorActor*>(this)));
															#line 1876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont6(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(RangeResult && txEntries,int loopDepth) 
	{
															#line 758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		numBytesToDel = 0;
															#line 759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRef endKey;
															#line 760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& kv : txEntries ) {
															#line 761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			endKey = kv.key;
															#line 762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			numBytesToDel += kv.key.size() + kv.value.size();
															#line 763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (txInfoSize - numBytesToDel <= clientTxInfoSizeLimit)
															#line 1900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
				break;
			}
		}
															#line 766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (numBytesToDel)
															#line 1907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->clear(KeyRangeRef(txEntries[0].key, strinc(endKey)));
															#line 768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevInfo, "DeletingExcessCntTxnEntries").detail("BytesToBeDeleted", numBytesToDel);
															#line 769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			int64_t bytesDel = -numBytesToDel;
															#line 770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->atomicOp(clientLatencyAtomicCtr, StringRef((uint8_t*)&bytesDel, 8), MutationRef::AddValue);
															#line 771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 3;
															#line 771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >*>(static_cast<DelExcessClntTxnEntriesActorActor*>(this)));
															#line 1926 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont6(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(RangeResult const& txEntries,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(txEntries, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(RangeResult && txEntries,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(txEntries), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state > 0) static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 0;
		static_cast<DelExcessClntTxnEntriesActorActor*>(this)->ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
															#line 773 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (txInfoSize - numBytesToDel <= clientTxInfoSizeLimit)
															#line 2003 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 774 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DelExcessClntTxnEntriesActorActorState(); static_cast<DelExcessClntTxnEntriesActorActor*>(this)->destroy(); return 0; }
															#line 2007 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<DelExcessClntTxnEntriesActorActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~DelExcessClntTxnEntriesActorActorState();
			static_cast<DelExcessClntTxnEntriesActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		loopDepth = a_body1loopBody1cont12(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont9(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont9(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state > 0) static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 0;
		static_cast<DelExcessClntTxnEntriesActorActor*>(this)->ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont12(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state > 0) static_cast<DelExcessClntTxnEntriesActorActor*>(this)->actor_wait_state = 0;
		static_cast<DelExcessClntTxnEntriesActorActor*>(this)->ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction* tr;
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int64_t clientTxInfoSizeLimit;
															#line 734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	const Key clientLatencyName;
															#line 735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	const Key clientLatencyAtomicCtr;
															#line 747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int64_t txInfoSize;
															#line 758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int64_t numBytesToDel;
															#line 2192 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via delExcessClntTxnEntriesActor()
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class DelExcessClntTxnEntriesActorActor final : public Actor<Void>, public ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >, public ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >, public ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >, public ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >, public FastAllocated<DelExcessClntTxnEntriesActorActor>, public DelExcessClntTxnEntriesActorActorState<DelExcessClntTxnEntriesActorActor> {
															#line 2197 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<DelExcessClntTxnEntriesActorActor>::operator new;
	using FastAllocated<DelExcessClntTxnEntriesActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >;
friend struct ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >;
friend struct ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >;
friend struct ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >;
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DelExcessClntTxnEntriesActorActor(Transaction* const& tr,int64_t const& clientTxInfoSizeLimit) 
															#line 2211 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   DelExcessClntTxnEntriesActorActorState<DelExcessClntTxnEntriesActorActor>(tr, clientTxInfoSizeLimit)
	{
		fdb_probe_actor_enter("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("delExcessClntTxnEntriesActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("delExcessClntTxnEntriesActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DelExcessClntTxnEntriesActorActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DelExcessClntTxnEntriesActorActor, 1, RangeResult >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< DelExcessClntTxnEntriesActorActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< DelExcessClntTxnEntriesActorActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> delExcessClntTxnEntriesActor( Transaction* const& tr, int64_t const& clientTxInfoSizeLimit ) {
															#line 733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new DelExcessClntTxnEntriesActorActor(tr, clientTxInfoSizeLimit));
															#line 2242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 780 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Delref and addref self to give self a chance to get destroyed.
															#line 2248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via refreshTransaction()
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class RefreshTransactionActor>
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class RefreshTransactionActorState {
															#line 2255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RefreshTransactionActorState(DatabaseContext* const& self,Transaction* const& tr) 
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self),
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(tr)
															#line 2264 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("refreshTransaction", reinterpret_cast<unsigned long>(this));

	}
	~RefreshTransactionActorState() 
	{
		fdb_probe_actor_destroy("refreshTransaction", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			*tr = Transaction();
															#line 784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = delay(0);
															#line 784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<RefreshTransactionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 2283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<RefreshTransactionActor*>(this)->actor_wait_state = 1;
															#line 784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< RefreshTransactionActor, 0, Void >*>(static_cast<RefreshTransactionActor*>(this)));
															#line 2288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~RefreshTransactionActorState();
		static_cast<RefreshTransactionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		*tr = Transaction(Database(Reference<DatabaseContext>::addRef(self)));
															#line 786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<RefreshTransactionActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~RefreshTransactionActorState(); static_cast<RefreshTransactionActor*>(this)->destroy(); return 0; }
															#line 2313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<RefreshTransactionActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~RefreshTransactionActorState();
		static_cast<RefreshTransactionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		*tr = Transaction(Database(Reference<DatabaseContext>::addRef(self)));
															#line 786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<RefreshTransactionActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~RefreshTransactionActorState(); static_cast<RefreshTransactionActor*>(this)->destroy(); return 0; }
															#line 2327 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<RefreshTransactionActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~RefreshTransactionActorState();
		static_cast<RefreshTransactionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<RefreshTransactionActor*>(this)->actor_wait_state > 0) static_cast<RefreshTransactionActor*>(this)->actor_wait_state = 0;
		static_cast<RefreshTransactionActor*>(this)->ActorCallback< RefreshTransactionActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RefreshTransactionActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("refreshTransaction", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("refreshTransaction", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< RefreshTransactionActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("refreshTransaction", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("refreshTransaction", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< RefreshTransactionActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("refreshTransaction", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("refreshTransaction", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* self;
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction* tr;
															#line 2402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via refreshTransaction()
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class RefreshTransactionActor final : public Actor<Void>, public ActorCallback< RefreshTransactionActor, 0, Void >, public FastAllocated<RefreshTransactionActor>, public RefreshTransactionActorState<RefreshTransactionActor> {
															#line 2407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<RefreshTransactionActor>::operator new;
	using FastAllocated<RefreshTransactionActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< RefreshTransactionActor, 0, Void >;
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RefreshTransactionActor(DatabaseContext* const& self,Transaction* const& tr) 
															#line 2418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   RefreshTransactionActorState<RefreshTransactionActor>(self, tr)
	{
		fdb_probe_actor_enter("refreshTransaction", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("refreshTransaction");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("refreshTransaction", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< RefreshTransactionActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> refreshTransaction( DatabaseContext* const& self, Transaction* const& tr ) {
															#line 782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new RefreshTransactionActor(self, tr));
															#line 2446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 788 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// The reason for getting a pointer to DatabaseContext instead of a reference counted object is because reference
// counting will increment reference count for DatabaseContext which holds the future of this actor. This creates a
// cyclic reference and hence this actor and Database object will not be destroyed at all.
															#line 2454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via clientStatusUpdateActor()
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ClientStatusUpdateActorActor>
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ClientStatusUpdateActorActorState {
															#line 2461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ClientStatusUpdateActorActorState(DatabaseContext* const& cx) 
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 793 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   clientLatencyName(CLIENT_LATENCY_INFO_PREFIX.withPrefix(fdbClientInfoPrefixRange.begin).toString()),
															#line 795 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(),
															#line 796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   commitQ(),
															#line 797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   txBytes(0)
															#line 2476 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this));

	}
	~ClientStatusUpdateActorActorState() 
	{
		fdb_probe_actor_destroy("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 799 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 2491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ClientStatusUpdateActorActorState();
		static_cast<ClientStatusUpdateActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = refreshTransaction(cx, &tr);
															#line 802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 2523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 1;
															#line 802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 0, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 2528 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
		try {
															#line 804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(cx->clientStatusUpdater.outStatusQ.empty());
															#line 805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->clientStatusUpdater.inStatusQ.swap(cx->clientStatusUpdater.outStatusQ);
															#line 807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trChunksQ = std::vector<TrInfoChunk>();
															#line 808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& entry : cx->clientStatusUpdater.outStatusQ ) {
															#line 809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto& bw = entry.second;
															#line 810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				int64_t value_size_limit = BUGGIFY ? deterministicRandom()->randomInt(1e3, CLIENT_KNOBS->VALUE_SIZE_LIMIT) : CLIENT_KNOBS->VALUE_SIZE_LIMIT;
															#line 813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				int num_chunks = (bw.getLength() + value_size_limit - 1) / value_size_limit;
															#line 814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				std::string random_id = deterministicRandom()->randomAlphaNumeric(16);
															#line 815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				std::string user_provided_id = entry.first.size() ? entry.first + "/" : "";
															#line 816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for(int i = 0;i < num_chunks;i++) {
															#line 817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TrInfoChunk chunk;
															#line 818 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					BinaryWriter chunkBW(Unversioned());
															#line 819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					chunkBW << bigEndian32(i + 1) << bigEndian32(num_chunks);
															#line 820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					chunk.key = KeyRef(clientLatencyName + std::string(10, '\x00') + "/" + random_id + "/" + chunkBW.toValue().toString() + "/" + user_provided_id + std::string(4, '\x00'));
															#line 822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					int32_t pos = littleEndian32(clientLatencyName.size());
															#line 823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					memcpy(mutateString(chunk.key) + chunk.key.size() - sizeof(int32_t), &pos, sizeof(int32_t));
															#line 824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (i == num_chunks - 1)
															#line 2570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 825 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						chunk.value = ValueRef(static_cast<uint8_t*>(bw.getData()) + (i * value_size_limit), bw.getLength() - (i * value_size_limit));
															#line 2574 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
					else
					{
															#line 828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						chunk.value = ValueRef(static_cast<uint8_t*>(bw.getData()) + (i * value_size_limit), value_size_limit);
															#line 2580 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trChunksQ.push_back(std::move(chunk));
															#line 2584 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 836 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			dataSizeLimit = BUGGIFY ? deterministicRandom()->randomInt(200e3, 1.5 * CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT) : 0.8 * CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT;
															#line 839 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracking_iter = trChunksQ.begin();
															#line 840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(commitQ.empty() && (txBytes == 0));
															#line 841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 2595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
		try {
															#line 804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(cx->clientStatusUpdater.outStatusQ.empty());
															#line 805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->clientStatusUpdater.inStatusQ.swap(cx->clientStatusUpdater.outStatusQ);
															#line 807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trChunksQ = std::vector<TrInfoChunk>();
															#line 808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& entry : cx->clientStatusUpdater.outStatusQ ) {
															#line 809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto& bw = entry.second;
															#line 810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				int64_t value_size_limit = BUGGIFY ? deterministicRandom()->randomInt(1e3, CLIENT_KNOBS->VALUE_SIZE_LIMIT) : CLIENT_KNOBS->VALUE_SIZE_LIMIT;
															#line 813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				int num_chunks = (bw.getLength() + value_size_limit - 1) / value_size_limit;
															#line 814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				std::string random_id = deterministicRandom()->randomAlphaNumeric(16);
															#line 815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				std::string user_provided_id = entry.first.size() ? entry.first + "/" : "";
															#line 816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for(int i = 0;i < num_chunks;i++) {
															#line 817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TrInfoChunk chunk;
															#line 818 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					BinaryWriter chunkBW(Unversioned());
															#line 819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					chunkBW << bigEndian32(i + 1) << bigEndian32(num_chunks);
															#line 820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					chunk.key = KeyRef(clientLatencyName + std::string(10, '\x00') + "/" + random_id + "/" + chunkBW.toValue().toString() + "/" + user_provided_id + std::string(4, '\x00'));
															#line 822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					int32_t pos = littleEndian32(clientLatencyName.size());
															#line 823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					memcpy(mutateString(chunk.key) + chunk.key.size() - sizeof(int32_t), &pos, sizeof(int32_t));
															#line 824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (i == num_chunks - 1)
															#line 2643 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 825 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						chunk.value = ValueRef(static_cast<uint8_t*>(bw.getData()) + (i * value_size_limit), bw.getLength() - (i * value_size_limit));
															#line 2647 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
					else
					{
															#line 828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						chunk.value = ValueRef(static_cast<uint8_t*>(bw.getData()) + (i * value_size_limit), value_size_limit);
															#line 2653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trChunksQ.push_back(std::move(chunk));
															#line 2657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 836 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			dataSizeLimit = BUGGIFY ? deterministicRandom()->randomInt(200e3, 1.5 * CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT) : 0.8 * CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT;
															#line 839 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracking_iter = trChunksQ.begin();
															#line 840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(commitQ.empty() && (txBytes == 0));
															#line 841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 2668 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state > 0) static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 0;
		static_cast<ClientStatusUpdateActorActor*>(this)->ActorCallback< ClientStatusUpdateActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ClientStatusUpdateActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_actor_cancelled)
															#line 2753 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 2757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->clientStatusUpdater.outStatusQ.clear();
															#line 892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarnAlways, "UnableToWriteClientStatus").error(e);
															#line 893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_6 = delay(10.0);
															#line 893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 2767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_6.get(), loopDepth); };
			static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 7;
															#line 893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 6, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 2772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
															#line 875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->clientStatusUpdater.outStatusQ.clear();
															#line 876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = cx->globalConfig->onInitialized();
															#line 876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 2791 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1cont1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 4;
															#line 876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 3, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 2796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1(int loopDepth) 
	{
															#line 842 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		iter = tracking_iter;
															#line 843 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txBytes = 0;
															#line 844 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		commitQ.clear();
															#line 2816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 2820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont1loopBody1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_transaction_too_large)
															#line 2855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 865 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				dataSizeLimit /= 2;
															#line 866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ASSERT(dataSizeLimit >= CLIENT_KNOBS->VALUE_SIZE_LIMIT + CLIENT_KNOBS->KEY_SIZE_LIMIT);
															#line 2861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevWarnAlways, "ClientTrInfoErrorCommit").error(e).detail("TxBytes", txBytes);
															#line 869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				commitQ.clear();
															#line 870 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				txBytes = 0;
															#line 871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1loopBody1cont1Catch1(e, std::max(0, loopDepth - 1));
															#line 2873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			loopDepth = a_body1loopBody1cont1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2(int loopDepth) 
	{
															#line 857 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!commitQ.empty())
															#line 2889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = transactionInfoCommitActor(&tr, &commitQ);
															#line 858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 2895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 3;
															#line 858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 2, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 2900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont1loopBody1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1loopBody1(int loopDepth) 
	{
															#line 846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(iter != trChunksQ.end()))
															#line 2921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1cont1loopBody1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (iter->value.size() + iter->key.size() + txBytes > dataSizeLimit)
															#line 2927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = transactionInfoCommitActor(&tr, &commitQ);
															#line 848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 2933 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1loopBody1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1loopBody1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 2;
															#line 848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 1, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 2938 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont1loopBody1loopBody1cont1(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1loopBody1cont1(int loopDepth) 
	{
															#line 853 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		commitQ.push_back(*iter);
															#line 854 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txBytes += iter->value.size() + iter->key.size();
															#line 855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++iter;
															#line 2969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont1loopBody1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tracking_iter = iter;
															#line 850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		commitQ.clear();
															#line 851 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txBytes = 0;
															#line 2982 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tracking_iter = iter;
															#line 850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		commitQ.clear();
															#line 851 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txBytes = 0;
															#line 2995 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state > 0) static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 0;
		static_cast<ClientStatusUpdateActorActor*>(this)->ActorCallback< ClientStatusUpdateActorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ClientStatusUpdateActorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont1loopBody1cont3(int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont4(Void const& _,int loopDepth) 
	{
															#line 859 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		commitQ.clear();
															#line 860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txBytes = 0;
															#line 3075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont4(Void && _,int loopDepth) 
	{
															#line 859 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		commitQ.clear();
															#line 860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		txBytes = 0;
															#line 3086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state > 0) static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 0;
		static_cast<ClientStatusUpdateActorActor*>(this)->ActorCallback< ClientStatusUpdateActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< ClientStatusUpdateActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont8(Void const& _,int loopDepth) 
	{
															#line 877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double sampleRate = cx->globalConfig->get<double>(fdbClientInfoTxnSampleRate, std::numeric_limits<double>::infinity());
															#line 879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double clientSamplingProbability = std::isinf(sampleRate) ? CLIENT_KNOBS->CSI_SAMPLING_PROBABILITY : sampleRate;
															#line 881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int64_t sizeLimit = cx->globalConfig->get<int64_t>(fdbClientInfoTxnSizeLimit, -1);
															#line 882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int64_t clientTxnInfoSizeLimit = sizeLimit == -1 ? CLIENT_KNOBS->CSI_SIZE_LIMIT : sizeLimit;
															#line 883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!trChunksQ.empty() && deterministicRandom()->random01() < clientSamplingProbability)
															#line 3166 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = delExcessClntTxnEntriesActor(&tr, clientTxnInfoSizeLimit);
															#line 884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 3172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1cont1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont8when1(__when_expr_4.get(), loopDepth); };
			static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 5;
															#line 884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 4, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 3177 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont9(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont8(Void && _,int loopDepth) 
	{
															#line 877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double sampleRate = cx->globalConfig->get<double>(fdbClientInfoTxnSampleRate, std::numeric_limits<double>::infinity());
															#line 879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double clientSamplingProbability = std::isinf(sampleRate) ? CLIENT_KNOBS->CSI_SAMPLING_PROBABILITY : sampleRate;
															#line 881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int64_t sizeLimit = cx->globalConfig->get<int64_t>(fdbClientInfoTxnSizeLimit, -1);
															#line 882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int64_t clientTxnInfoSizeLimit = sizeLimit == -1 ? CLIENT_KNOBS->CSI_SIZE_LIMIT : sizeLimit;
															#line 883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!trChunksQ.empty() && deterministicRandom()->random01() < clientSamplingProbability)
															#line 3199 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = delExcessClntTxnEntriesActor(&tr, clientTxnInfoSizeLimit);
															#line 884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 3205 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1cont1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont8when1(__when_expr_4.get(), loopDepth); };
			static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 5;
															#line 884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 4, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 3210 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont9(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state > 0) static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 0;
		static_cast<ClientStatusUpdateActorActor*>(this)->ActorCallback< ClientStatusUpdateActorActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< ClientStatusUpdateActorActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont9(int loopDepth) 
	{
															#line 886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_5 = delay(CLIENT_KNOBS->CSI_STATUS_DELAY);
															#line 886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 3289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1loopBody1cont1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1loopBody1cont9when1(__when_expr_5.get(), loopDepth); };
		static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 6;
															#line 886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< ClientStatusUpdateActorActor, 5, Void >*>(static_cast<ClientStatusUpdateActorActor*>(this)));
															#line 3294 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont10(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont10(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont8when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont8when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state > 0) static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 0;
		static_cast<ClientStatusUpdateActorActor*>(this)->ActorCallback< ClientStatusUpdateActorActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont8when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont8when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< ClientStatusUpdateActorActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1loopBody1cont11(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont9when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont9when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state > 0) static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 0;
		static_cast<ClientStatusUpdateActorActor*>(this)->ActorCallback< ClientStatusUpdateActorActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1cont9when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1cont9when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< ClientStatusUpdateActorActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1loopBody1cont11cont1(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state > 0) static_cast<ClientStatusUpdateActorActor*>(this)->actor_wait_state = 0;
		static_cast<ClientStatusUpdateActorActor*>(this)->ActorCallback< ClientStatusUpdateActorActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< ClientStatusUpdateActorActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< ClientStatusUpdateActorActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), 6);

	}
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 793 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	const std::string clientLatencyName;
															#line 795 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<TrInfoChunk> commitQ;
															#line 797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int txBytes;
															#line 807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<TrInfoChunk> trChunksQ;
															#line 836 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int64_t dataSizeLimit;
															#line 839 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<TrInfoChunk>::iterator tracking_iter;
															#line 842 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<TrInfoChunk>::iterator iter;
															#line 3555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via clientStatusUpdateActor()
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ClientStatusUpdateActorActor final : public Actor<Void>, public ActorCallback< ClientStatusUpdateActorActor, 0, Void >, public ActorCallback< ClientStatusUpdateActorActor, 1, Void >, public ActorCallback< ClientStatusUpdateActorActor, 2, Void >, public ActorCallback< ClientStatusUpdateActorActor, 3, Void >, public ActorCallback< ClientStatusUpdateActorActor, 4, Void >, public ActorCallback< ClientStatusUpdateActorActor, 5, Void >, public ActorCallback< ClientStatusUpdateActorActor, 6, Void >, public FastAllocated<ClientStatusUpdateActorActor>, public ClientStatusUpdateActorActorState<ClientStatusUpdateActorActor> {
															#line 3560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ClientStatusUpdateActorActor>::operator new;
	using FastAllocated<ClientStatusUpdateActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< ClientStatusUpdateActorActor, 0, Void >;
friend struct ActorCallback< ClientStatusUpdateActorActor, 1, Void >;
friend struct ActorCallback< ClientStatusUpdateActorActor, 2, Void >;
friend struct ActorCallback< ClientStatusUpdateActorActor, 3, Void >;
friend struct ActorCallback< ClientStatusUpdateActorActor, 4, Void >;
friend struct ActorCallback< ClientStatusUpdateActorActor, 5, Void >;
friend struct ActorCallback< ClientStatusUpdateActorActor, 6, Void >;
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ClientStatusUpdateActorActor(DatabaseContext* const& cx) 
															#line 3577 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   ClientStatusUpdateActorActorState<ClientStatusUpdateActorActor>(cx)
	{
		fdb_probe_actor_enter("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("clientStatusUpdateActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("clientStatusUpdateActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ClientStatusUpdateActorActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< ClientStatusUpdateActorActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< ClientStatusUpdateActorActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< ClientStatusUpdateActorActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< ClientStatusUpdateActorActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< ClientStatusUpdateActorActor, 5, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< ClientStatusUpdateActorActor, 6, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> clientStatusUpdateActor( DatabaseContext* const& cx ) {
															#line 792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new ClientStatusUpdateActorActor(cx));
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 3616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via assertFailure()
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class AssertFailureActor>
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class AssertFailureActorState {
															#line 3623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	AssertFailureActorState(GrvProxyInterface const& remote,Future<ErrorOr<GetReadVersionReply>> const& reply) 
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : remote(remote),
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   reply(reply)
															#line 3632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("assertFailure", reinterpret_cast<unsigned long>(this));

	}
	~AssertFailureActorState() 
	{
		fdb_probe_actor_destroy("assertFailure", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<ErrorOr<GetReadVersionReply>> __when_expr_0 = reply;
															#line 900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<AssertFailureActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 3650 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<AssertFailureActor*>(this)->actor_wait_state = 1;
															#line 900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >*>(static_cast<AssertFailureActor*>(this)));
															#line 3655 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AssertFailureActorState();
		static_cast<AssertFailureActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 914 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<AssertFailureActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AssertFailureActorState(); static_cast<AssertFailureActor*>(this)->destroy(); return 0; }
															#line 3684 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<AssertFailureActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~AssertFailureActorState();
		static_cast<AssertFailureActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 909 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_actor_cancelled)
															#line 3697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 910 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, loopDepth);
															#line 3701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(ErrorOr<GetReadVersionReply> const& res,int loopDepth) 
	{
															#line 901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!res.isError())
															#line 3717 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 902 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "GotStaleReadVersion") .detail("Remote", remote.getConsistentReadVersion.getEndpoint().addresses.address.toString()) .detail("Provisional", remote.provisional) .detail("ReadVersion", res.get().version);
															#line 906 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT_WE_THINK(false);
															#line 3723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(ErrorOr<GetReadVersionReply> && res,int loopDepth) 
	{
															#line 901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!res.isError())
															#line 3733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 902 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "GotStaleReadVersion") .detail("Remote", remote.getConsistentReadVersion.getEndpoint().addresses.address.toString()) .detail("Provisional", remote.provisional) .detail("ReadVersion", res.get().version);
															#line 906 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT_WE_THINK(false);
															#line 3739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1when1(ErrorOr<GetReadVersionReply> const& res,int loopDepth) 
	{
		loopDepth = a_body1cont2(res, loopDepth);

		return loopDepth;
	}
	int a_body1when1(ErrorOr<GetReadVersionReply> && res,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(res), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AssertFailureActor*>(this)->actor_wait_state > 0) static_cast<AssertFailureActor*>(this)->actor_wait_state = 0;
		static_cast<AssertFailureActor*>(this)->ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >::remove();

	}
	void a_callback_fire(ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >*,ErrorOr<GetReadVersionReply> const& value) 
	{
		fdb_probe_actor_enter("assertFailure", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("assertFailure", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >*,ErrorOr<GetReadVersionReply> && value) 
	{
		fdb_probe_actor_enter("assertFailure", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("assertFailure", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >*,Error err) 
	{
		fdb_probe_actor_enter("assertFailure", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("assertFailure", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GrvProxyInterface remote;
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<ErrorOr<GetReadVersionReply>> reply;
															#line 3825 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via assertFailure()
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class AssertFailureActor final : public Actor<Void>, public ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >, public FastAllocated<AssertFailureActor>, public AssertFailureActorState<AssertFailureActor> {
															#line 3830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<AssertFailureActor>::operator new;
	using FastAllocated<AssertFailureActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >;
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	AssertFailureActor(GrvProxyInterface const& remote,Future<ErrorOr<GetReadVersionReply>> const& reply) 
															#line 3841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   AssertFailureActorState<AssertFailureActor>(remote, reply)
	{
		fdb_probe_actor_enter("assertFailure", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("assertFailure");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("assertFailure", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AssertFailureActor, 0, ErrorOr<GetReadVersionReply> >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> assertFailure( GrvProxyInterface const& remote, Future<ErrorOr<GetReadVersionReply>> const& reply ) {
															#line 898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new AssertFailureActor(remote, reply));
															#line 3869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 916 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> attemptGRVFromOldProxies(std::vector<GrvProxyInterface> oldProxies,
                                      std::vector<GrvProxyInterface> newProxies) {
	Span span(deterministicRandom()->randomUniqueID(), "VerifyCausalReadRisky"_loc);
	std::vector<Future<Void>> replies;
	replies.reserve(oldProxies.size());
	GetReadVersionRequest req(
	    span.context, 1, TransactionPriority::IMMEDIATE, GetReadVersionRequest::FLAG_CAUSAL_READ_RISKY);
	TraceEvent evt("AttemptGRVFromOldProxies");
	evt.detail("NumOldProxies", oldProxies.size()).detail("NumNewProxies", newProxies.size());
	auto traceProxies = [&](std::vector<GrvProxyInterface>& proxies, std::string const& key) {
		for (int i = 0; i < proxies.size(); ++i) {
			auto k = key + std::to_string(i);
			evt.detail(k.c_str(), proxies[i].id());
		}
	};
	traceProxies(oldProxies, "OldProxy"s);
	traceProxies(newProxies, "NewProxy"s);
	evt.log();
	for (auto& i : oldProxies) {
		req.reply = ReplyPromise<GetReadVersionReply>();
		replies.push_back(assertFailure(i, i.getConsistentReadVersion.tryGetReply(req)));
	}
	return waitForAll(replies);
}

															#line 3899 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via monitorClientDBInfoChange()
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class MonitorClientDBInfoChangeActor>
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MonitorClientDBInfoChangeActorState {
															#line 3906 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MonitorClientDBInfoChangeActorState(DatabaseContext* const& cx,Reference<AsyncVar<ClientDBInfo> const> const& clientDBInfo,AsyncTrigger* const& proxiesChangeTrigger) 
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   clientDBInfo(clientDBInfo),
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   proxiesChangeTrigger(proxiesChangeTrigger),
															#line 945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   curCommitProxies(),
															#line 946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   curGrvProxies(),
															#line 947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   actors(false),
															#line 948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   clientDBInfoOnChange(clientDBInfo->onChange())
															#line 3925 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this));

	}
	~MonitorClientDBInfoChangeActorState() 
	{
		fdb_probe_actor_destroy("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			curCommitProxies = clientDBInfo->get().commitProxies;
															#line 950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			curGrvProxies = clientDBInfo->get().grvProxies;
															#line 952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 3944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MonitorClientDBInfoChangeActorState();
		static_cast<MonitorClientDBInfoChangeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = clientDBInfoOnChange;
															#line 953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MonitorClientDBInfoChangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 3976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 975 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = actors.getResult();
															#line 3980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
		static_cast<MonitorClientDBInfoChangeActor*>(this)->actor_wait_state = 1;
															#line 954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >*>(static_cast<MonitorClientDBInfoChangeActor*>(this)));
															#line 975 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< MonitorClientDBInfoChangeActor, 1, Void >*>(static_cast<MonitorClientDBInfoChangeActor*>(this)));
															#line 3987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
															#line 955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		clientDBInfoOnChange = clientDBInfo->onChange();
															#line 956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (clientDBInfo->get().commitProxies != curCommitProxies || clientDBInfo->get().grvProxies != curGrvProxies)
															#line 4004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 966 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (deterministicRandom()->random01() < cx->verifyCausalReadsProp && !curGrvProxies.empty() && !clientDBInfo->get().grvProxies.empty() && !clientDBInfo->get().grvProxies[0].provisional)
															#line 4008 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				actors.add(attemptGRVFromOldProxies(curGrvProxies, clientDBInfo->get().grvProxies));
															#line 4012 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			curCommitProxies = clientDBInfo->get().commitProxies;
															#line 971 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			curGrvProxies = clientDBInfo->get().grvProxies;
															#line 972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			proxiesChangeTrigger->trigger();
															#line 4020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
															#line 955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		clientDBInfoOnChange = clientDBInfo->onChange();
															#line 956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (clientDBInfo->get().commitProxies != curCommitProxies || clientDBInfo->get().grvProxies != curGrvProxies)
															#line 4032 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 966 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (deterministicRandom()->random01() < cx->verifyCausalReadsProp && !curGrvProxies.empty() && !clientDBInfo->get().grvProxies.empty() && !clientDBInfo->get().grvProxies[0].provisional)
															#line 4036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				actors.add(attemptGRVFromOldProxies(curGrvProxies, clientDBInfo->get().grvProxies));
															#line 4040 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			curCommitProxies = clientDBInfo->get().commitProxies;
															#line 971 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			curGrvProxies = clientDBInfo->get().grvProxies;
															#line 972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			proxiesChangeTrigger->trigger();
															#line 4048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
															#line 976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		UNSTOPPABLE_ASSERT(false);
															#line 4058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
															#line 976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		UNSTOPPABLE_ASSERT(false);
															#line 4067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MonitorClientDBInfoChangeActor*>(this)->actor_wait_state > 0) static_cast<MonitorClientDBInfoChangeActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorClientDBInfoChangeActor*>(this)->ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >::remove();
		static_cast<MonitorClientDBInfoChangeActor*>(this)->ActorCallback< MonitorClientDBInfoChangeActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MonitorClientDBInfoChangeActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< MonitorClientDBInfoChangeActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< MonitorClientDBInfoChangeActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<AsyncVar<ClientDBInfo> const> clientDBInfo;
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	AsyncTrigger* proxiesChangeTrigger;
															#line 945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<CommitProxyInterface> curCommitProxies;
															#line 946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<GrvProxyInterface> curGrvProxies;
															#line 947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ActorCollection actors;
															#line 948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> clientDBInfoOnChange;
															#line 4183 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via monitorClientDBInfoChange()
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MonitorClientDBInfoChangeActor final : public Actor<Void>, public ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >, public ActorCallback< MonitorClientDBInfoChangeActor, 1, Void >, public FastAllocated<MonitorClientDBInfoChangeActor>, public MonitorClientDBInfoChangeActorState<MonitorClientDBInfoChangeActor> {
															#line 4188 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<MonitorClientDBInfoChangeActor>::operator new;
	using FastAllocated<MonitorClientDBInfoChangeActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >;
friend struct ActorCallback< MonitorClientDBInfoChangeActor, 1, Void >;
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MonitorClientDBInfoChangeActor(DatabaseContext* const& cx,Reference<AsyncVar<ClientDBInfo> const> const& clientDBInfo,AsyncTrigger* const& proxiesChangeTrigger) 
															#line 4200 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   MonitorClientDBInfoChangeActorState<MonitorClientDBInfoChangeActor>(cx, clientDBInfo, proxiesChangeTrigger)
	{
		fdb_probe_actor_enter("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("monitorClientDBInfoChange");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("monitorClientDBInfoChange", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MonitorClientDBInfoChangeActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> monitorClientDBInfoChange( DatabaseContext* const& cx, Reference<AsyncVar<ClientDBInfo> const> const& clientDBInfo, AsyncTrigger* const& proxiesChangeTrigger ) {
															#line 942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new MonitorClientDBInfoChangeActor(cx, clientDBInfo, proxiesChangeTrigger));
															#line 4228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 981 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

void updateLocationCacheWithCaches(DatabaseContext* self,
                                   const std::map<UID, StorageServerInterface>& removed,
                                   const std::map<UID, StorageServerInterface>& added) {
	// TODO: this needs to be more clever in the future
	auto ranges = self->locationCache.ranges();
	for (auto iter = ranges.begin(); iter != ranges.end(); ++iter) {
		if (iter->value() && iter->value()->hasCaches) {
			auto& val = iter->value();
			std::vector<Reference<ReferencedInterface<StorageServerInterface>>> interfaces;
			interfaces.reserve(val->size() - removed.size() + added.size());
			for (int i = 0; i < val->size(); ++i) {
				const auto& interf = (*val)[i];
				if (removed.count(interf->interf.id()) == 0) {
					interfaces.emplace_back(interf);
				}
			}
			for (const auto& p : added) {
				interfaces.push_back(makeReference<ReferencedInterface<StorageServerInterface>>(p.second));
			}
			iter->value() = makeReference<LocationInfo>(interfaces, true);
		}
	}
}

Reference<LocationInfo> addCaches(const Reference<LocationInfo>& loc,
                                  const std::vector<Reference<ReferencedInterface<StorageServerInterface>>>& other) {
	std::vector<Reference<ReferencedInterface<StorageServerInterface>>> interfaces;
	interfaces.reserve(loc->size() + other.size());
	for (int i = 0; i < loc->size(); ++i) {
		interfaces.emplace_back((*loc)[i]);
	}
	interfaces.insert(interfaces.end(), other.begin(), other.end());
	return makeReference<LocationInfo>(interfaces, true);
}

															#line 4268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via updateCachedRanges()
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class UpdateCachedRangesActor>
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class UpdateCachedRangesActorState {
															#line 4275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UpdateCachedRangesActorState(DatabaseContext* const& self,std::map<UID, StorageServerInterface>* const& cacheServers) 
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self),
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cacheServers(cacheServers),
															#line 1018 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(),
															#line 1019 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   trueValue(storageCacheValue(std::vector<uint16_t>{ 0 })),
															#line 1020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   falseValue(storageCacheValue(std::vector<uint16_t>{}))
															#line 4290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("updateCachedRanges", reinterpret_cast<unsigned long>(this));

	}
	~UpdateCachedRangesActorState() 
	{
		fdb_probe_actor_destroy("updateCachedRanges", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				;
															#line 4306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~UpdateCachedRangesActorState();
		static_cast<UpdateCachedRangesActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "UpdateCachedRangesFailed").error(e);
															#line 1090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 4338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 1025 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr = Transaction();
															#line 1026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = delay(0);
															#line 1026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 4363 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 1;
															#line 1026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 0, Void >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4368 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 1027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = brokenPromiseToNever(self->updateCache.onTrigger());
															#line 1027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 4379 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 2;
															#line 1027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 1, Void >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 1027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = brokenPromiseToNever(self->updateCache.onTrigger());
															#line 1027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 4395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 2;
															#line 1027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 1, Void >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state > 0) static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 0;
		static_cast<UpdateCachedRangesActor*>(this)->ActorCallback< UpdateCachedRangesActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< UpdateCachedRangesActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 1029 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr = Transaction(Database(Reference<DatabaseContext>::addRef(self)));
															#line 1030 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 1031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr.setOption(FDBTransactionOptions::READ_LOCK_AWARE);
															#line 4476 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 1033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<RangeResult> __when_expr_2 = tr.getRange(storageCacheKeys, CLIENT_KNOBS->TOO_MANY);
															#line 1033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2Catch1(actor_cancelled(), loopDepth);
															#line 4482 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont2Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 3;
															#line 1033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 2, RangeResult >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont2Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont2Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 1029 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr = Transaction(Database(Reference<DatabaseContext>::addRef(self)));
															#line 1030 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 1031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr.setOption(FDBTransactionOptions::READ_LOCK_AWARE);
															#line 4506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 1033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<RangeResult> __when_expr_2 = tr.getRange(storageCacheKeys, CLIENT_KNOBS->TOO_MANY);
															#line 1033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2Catch1(actor_cancelled(), loopDepth);
															#line 4512 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont2Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 3;
															#line 1033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 2, RangeResult >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont2Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont2Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state > 0) static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 0;
		static_cast<UpdateCachedRangesActor*>(this)->ActorCallback< UpdateCachedRangesActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< UpdateCachedRangesActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1085 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = tr.onError(e);
															#line 1085 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 4604 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch2(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont2Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 5;
															#line 1085 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 4, Void >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4609 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont4(RangeResult const& range,int loopDepth) 
	{
															#line 1034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!range.more);
															#line 1035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<Reference<ReferencedInterface<StorageServerInterface>>> cacheInterfaces;
															#line 1036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cacheInterfaces.reserve(cacheServers->size());
															#line 1037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& p : *cacheServers ) {
															#line 1038 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cacheInterfaces.push_back(makeReference<ReferencedInterface<StorageServerInterface>>(p.second));
															#line 4632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 1040 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool currCached = false;
															#line 1041 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRef begin, end;
															#line 1042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& kv : range ) {
															#line 1044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(currCached == (kv.value == falseValue));
															#line 1045 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (kv.value == trueValue)
															#line 4644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 1046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				begin = kv.key.substr(storageCacheKeys.begin.size());
															#line 1047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				currCached = true;
															#line 4650 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 1049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				currCached = false;
															#line 1050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				end = kv.key.substr(storageCacheKeys.begin.size());
															#line 1051 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRangeRef cachedRange{ begin, end };
															#line 1052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto ranges = self->locationCache.containedRanges(cachedRange);
															#line 1053 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRef containedRangesBegin, containedRangesEnd, prevKey;
															#line 1054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!ranges.empty())
															#line 4666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 1055 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					containedRangesBegin = ranges.begin().range().begin;
															#line 4670 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 1057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for(auto iter = ranges.begin();iter != ranges.end();++iter) {
															#line 1058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					containedRangesEnd = iter->range().end;
															#line 1059 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (iter->value() && !iter->value()->hasCaches)
															#line 4678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 1060 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						iter->value() = addCaches(iter->value(), cacheInterfaces);
															#line 4682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
															#line 1063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto iter = self->locationCache.rangeContaining(begin);
															#line 1064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (iter->value() && !iter->value()->hasCaches)
															#line 4689 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 1065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (end >= iter->range().end)
															#line 4693 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 1066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						Key endCopy = iter->range().end;
															#line 1067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						self->locationCache.insert(KeyRangeRef{ begin, endCopy }, addCaches(iter->value(), cacheInterfaces));
															#line 4699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
					else
					{
															#line 1070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						self->locationCache.insert(KeyRangeRef{ begin, end }, addCaches(iter->value(), cacheInterfaces));
															#line 4705 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
															#line 1074 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				iter = self->locationCache.rangeContainingKeyBefore(end);
															#line 1075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (iter->value() && !iter->value()->hasCaches)
															#line 4712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 1076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					Key beginCopy = iter->range().begin;
															#line 1077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					self->locationCache.insert(KeyRangeRef{ beginCopy, end }, addCaches(iter->value(), cacheInterfaces));
															#line 4718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 1082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = delay(2.0);
															#line 1082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2Catch1(actor_cancelled(), loopDepth);
															#line 4726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1cont2Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 4;
															#line 1082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 3, Void >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont4(RangeResult && range,int loopDepth) 
	{
															#line 1034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!range.more);
															#line 1035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<Reference<ReferencedInterface<StorageServerInterface>>> cacheInterfaces;
															#line 1036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cacheInterfaces.reserve(cacheServers->size());
															#line 1037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& p : *cacheServers ) {
															#line 1038 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cacheInterfaces.push_back(makeReference<ReferencedInterface<StorageServerInterface>>(p.second));
															#line 4748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 1040 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool currCached = false;
															#line 1041 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRef begin, end;
															#line 1042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& kv : range ) {
															#line 1044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(currCached == (kv.value == falseValue));
															#line 1045 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (kv.value == trueValue)
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 1046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				begin = kv.key.substr(storageCacheKeys.begin.size());
															#line 1047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				currCached = true;
															#line 4766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 1049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				currCached = false;
															#line 1050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				end = kv.key.substr(storageCacheKeys.begin.size());
															#line 1051 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRangeRef cachedRange{ begin, end };
															#line 1052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto ranges = self->locationCache.containedRanges(cachedRange);
															#line 1053 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRef containedRangesBegin, containedRangesEnd, prevKey;
															#line 1054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!ranges.empty())
															#line 4782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 1055 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					containedRangesBegin = ranges.begin().range().begin;
															#line 4786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 1057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for(auto iter = ranges.begin();iter != ranges.end();++iter) {
															#line 1058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					containedRangesEnd = iter->range().end;
															#line 1059 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (iter->value() && !iter->value()->hasCaches)
															#line 4794 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 1060 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						iter->value() = addCaches(iter->value(), cacheInterfaces);
															#line 4798 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
															#line 1063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto iter = self->locationCache.rangeContaining(begin);
															#line 1064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (iter->value() && !iter->value()->hasCaches)
															#line 4805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 1065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (end >= iter->range().end)
															#line 4809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 1066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						Key endCopy = iter->range().end;
															#line 1067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						self->locationCache.insert(KeyRangeRef{ begin, endCopy }, addCaches(iter->value(), cacheInterfaces));
															#line 4815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
					else
					{
															#line 1070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						self->locationCache.insert(KeyRangeRef{ begin, end }, addCaches(iter->value(), cacheInterfaces));
															#line 4821 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
															#line 1074 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				iter = self->locationCache.rangeContainingKeyBefore(end);
															#line 1075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (iter->value() && !iter->value()->hasCaches)
															#line 4828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 1076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					Key beginCopy = iter->range().begin;
															#line 1077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					self->locationCache.insert(KeyRangeRef{ beginCopy, end }, addCaches(iter->value(), cacheInterfaces));
															#line 4834 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 1082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = delay(2.0);
															#line 1082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2Catch1(actor_cancelled(), loopDepth);
															#line 4842 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1cont2Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 4;
															#line 1082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< UpdateCachedRangesActor, 3, Void >*>(static_cast<UpdateCachedRangesActor*>(this)));
															#line 4847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(RangeResult const& range,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(range, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(RangeResult && range,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(std::move(range), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state > 0) static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 0;
		static_cast<UpdateCachedRangesActor*>(this)->ActorCallback< UpdateCachedRangesActor, 2, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 2, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 2, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< UpdateCachedRangesActor, 2, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont17(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont17(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state > 0) static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 0;
		static_cast<UpdateCachedRangesActor*>(this)->ActorCallback< UpdateCachedRangesActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< UpdateCachedRangesActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont2Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont17(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state > 0) static_cast<UpdateCachedRangesActor*>(this)->actor_wait_state = 0;
		static_cast<UpdateCachedRangesActor*>(this)->ActorCallback< UpdateCachedRangesActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont2Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< UpdateCachedRangesActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont2Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< UpdateCachedRangesActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* self;
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::map<UID, StorageServerInterface>* cacheServers;
															#line 1018 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 1019 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Value trueValue;
															#line 1020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Value falseValue;
															#line 5088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via updateCachedRanges()
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class UpdateCachedRangesActor final : public Actor<Void>, public ActorCallback< UpdateCachedRangesActor, 0, Void >, public ActorCallback< UpdateCachedRangesActor, 1, Void >, public ActorCallback< UpdateCachedRangesActor, 2, RangeResult >, public ActorCallback< UpdateCachedRangesActor, 3, Void >, public ActorCallback< UpdateCachedRangesActor, 4, Void >, public FastAllocated<UpdateCachedRangesActor>, public UpdateCachedRangesActorState<UpdateCachedRangesActor> {
															#line 5093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<UpdateCachedRangesActor>::operator new;
	using FastAllocated<UpdateCachedRangesActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< UpdateCachedRangesActor, 0, Void >;
friend struct ActorCallback< UpdateCachedRangesActor, 1, Void >;
friend struct ActorCallback< UpdateCachedRangesActor, 2, RangeResult >;
friend struct ActorCallback< UpdateCachedRangesActor, 3, Void >;
friend struct ActorCallback< UpdateCachedRangesActor, 4, Void >;
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UpdateCachedRangesActor(DatabaseContext* const& self,std::map<UID, StorageServerInterface>* const& cacheServers) 
															#line 5108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   UpdateCachedRangesActorState<UpdateCachedRangesActor>(self, cacheServers)
	{
		fdb_probe_actor_enter("updateCachedRanges", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("updateCachedRanges");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("updateCachedRanges", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< UpdateCachedRangesActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< UpdateCachedRangesActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< UpdateCachedRangesActor, 2, RangeResult >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< UpdateCachedRangesActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< UpdateCachedRangesActor, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> updateCachedRanges( DatabaseContext* const& self, std::map<UID, StorageServerInterface>* const& cacheServers ) {
															#line 1017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new UpdateCachedRangesActor(self, cacheServers));
															#line 5140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 1093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// The reason for getting a pointer to DatabaseContext instead of a reference counted object is because reference
// counting will increment reference count for DatabaseContext which holds the future of this actor. This creates a
// cyclic reference and hence this actor and Database object will not be destroyed at all.
															#line 5148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via monitorCacheList()
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class MonitorCacheListActor>
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MonitorCacheListActorState {
															#line 5155 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MonitorCacheListActorState(DatabaseContext* const& self) 
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self),
															#line 1098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(),
															#line 1099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cacheServerMap(),
															#line 1100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   updateRanges(updateCachedRanges(self, &cacheServerMap))
															#line 5168 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("monitorCacheList", reinterpret_cast<unsigned long>(this));

	}
	~MonitorCacheListActorState() 
	{
		fdb_probe_actor_destroy("monitorCacheList", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = self->updateCache.onTrigger();
															#line 1103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 5185 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 1;
															#line 1103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MonitorCacheListActor, 0, Void >*>(static_cast<MonitorCacheListActor*>(this)));
															#line 5190 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MonitorCacheListActorState();
		static_cast<MonitorCacheListActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
		try {
															#line 1105 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 5214 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
		try {
															#line 1105 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 5230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state > 0) static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorCacheListActor*>(this)->ActorCallback< MonitorCacheListActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MonitorCacheListActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1143 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "MonitorCacheListFailed").error(e);
															#line 1144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 5311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 1108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = refreshTransaction(self, &tr);
															#line 1108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state < 0) return a_body1cont1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 5334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 2;
															#line 1108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< MonitorCacheListActor, 1, Void >*>(static_cast<MonitorCacheListActor*>(this)));
															#line 5339 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(Void const& _,int loopDepth) 
	{
		try {
															#line 1110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<RangeResult> __when_expr_2 = tr.getRange(storageCacheServerKeys, CLIENT_KNOBS->TOO_MANY);
															#line 1110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 5351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1cont1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont1when1(__when_expr_2.get(), loopDepth); };
			static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 3;
															#line 1110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< MonitorCacheListActor, 2, RangeResult >*>(static_cast<MonitorCacheListActor*>(this)));
															#line 5356 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(Void && _,int loopDepth) 
	{
		try {
															#line 1110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<RangeResult> __when_expr_2 = tr.getRange(storageCacheServerKeys, CLIENT_KNOBS->TOO_MANY);
															#line 1110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 5374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1cont1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont1when1(__when_expr_2.get(), loopDepth); };
			static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 3;
															#line 1110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< MonitorCacheListActor, 2, RangeResult >*>(static_cast<MonitorCacheListActor*>(this)));
															#line 5379 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state > 0) static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorCacheListActor*>(this)->ActorCallback< MonitorCacheListActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< MonitorCacheListActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = tr.onError(e);
															#line 1139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state < 0) return a_body1cont1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 5466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1cont1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 5;
															#line 1139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< MonitorCacheListActor, 4, Void >*>(static_cast<MonitorCacheListActor*>(this)));
															#line 5471 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1cont1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(RangeResult const& cacheList,int loopDepth) 
	{
															#line 1111 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!cacheList.more);
															#line 1112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool hasChanges = false;
															#line 1113 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::map<UID, StorageServerInterface> allCacheServers;
															#line 1114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto kv : cacheList ) {
															#line 1115 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto ssi = BinaryReader::fromStringRef<StorageServerInterface>(kv.value, IncludeVersion());
															#line 1116 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			allCacheServers.emplace(ssi.id(), ssi);
															#line 5496 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 1118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::map<UID, StorageServerInterface> newCacheServers;
															#line 1119 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::map<UID, StorageServerInterface> deletedCacheServers;
															#line 1120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::set_difference(allCacheServers.begin(), allCacheServers.end(), cacheServerMap.begin(), cacheServerMap.end(), std::insert_iterator<std::map<UID, StorageServerInterface>>( newCacheServers, newCacheServers.begin()));
															#line 1126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::set_difference(cacheServerMap.begin(), cacheServerMap.end(), allCacheServers.begin(), allCacheServers.end(), std::insert_iterator<std::map<UID, StorageServerInterface>>( deletedCacheServers, deletedCacheServers.begin()));
															#line 1132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		hasChanges = !(newCacheServers.empty() && deletedCacheServers.empty());
															#line 1133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (hasChanges)
															#line 5510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1134 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			updateLocationCacheWithCaches(self, deletedCacheServers, newCacheServers);
															#line 5514 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 1136 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cacheServerMap = std::move(allCacheServers);
															#line 1137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = delay(5.0);
															#line 1137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 5522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1cont1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 4;
															#line 1137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< MonitorCacheListActor, 3, Void >*>(static_cast<MonitorCacheListActor*>(this)));
															#line 5527 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(RangeResult && cacheList,int loopDepth) 
	{
															#line 1111 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!cacheList.more);
															#line 1112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool hasChanges = false;
															#line 1113 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::map<UID, StorageServerInterface> allCacheServers;
															#line 1114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto kv : cacheList ) {
															#line 1115 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto ssi = BinaryReader::fromStringRef<StorageServerInterface>(kv.value, IncludeVersion());
															#line 1116 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			allCacheServers.emplace(ssi.id(), ssi);
															#line 5546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 1118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::map<UID, StorageServerInterface> newCacheServers;
															#line 1119 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::map<UID, StorageServerInterface> deletedCacheServers;
															#line 1120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::set_difference(allCacheServers.begin(), allCacheServers.end(), cacheServerMap.begin(), cacheServerMap.end(), std::insert_iterator<std::map<UID, StorageServerInterface>>( newCacheServers, newCacheServers.begin()));
															#line 1126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::set_difference(cacheServerMap.begin(), cacheServerMap.end(), allCacheServers.begin(), allCacheServers.end(), std::insert_iterator<std::map<UID, StorageServerInterface>>( deletedCacheServers, deletedCacheServers.begin()));
															#line 1132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		hasChanges = !(newCacheServers.empty() && deletedCacheServers.empty());
															#line 1133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (hasChanges)
															#line 5560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1134 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			updateLocationCacheWithCaches(self, deletedCacheServers, newCacheServers);
															#line 5564 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 1136 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cacheServerMap = std::move(allCacheServers);
															#line 1137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = delay(5.0);
															#line 1137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 5572 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1cont1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 4;
															#line 1137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< MonitorCacheListActor, 3, Void >*>(static_cast<MonitorCacheListActor*>(this)));
															#line 5577 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when1(RangeResult const& cacheList,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(cacheList, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when1(RangeResult && cacheList,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(cacheList), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state > 0) static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorCacheListActor*>(this)->ActorCallback< MonitorCacheListActor, 2, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 2, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 2, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< MonitorCacheListActor, 2, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state > 0) static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorCacheListActor*>(this)->ActorCallback< MonitorCacheListActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< MonitorCacheListActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1cont7(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1cont1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<MonitorCacheListActor*>(this)->actor_wait_state > 0) static_cast<MonitorCacheListActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorCacheListActor*>(this)->ActorCallback< MonitorCacheListActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< MonitorCacheListActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< MonitorCacheListActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* self;
															#line 1098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 1099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::map<UID, StorageServerInterface> cacheServerMap;
															#line 1100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> updateRanges;
															#line 5816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via monitorCacheList()
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MonitorCacheListActor final : public Actor<Void>, public ActorCallback< MonitorCacheListActor, 0, Void >, public ActorCallback< MonitorCacheListActor, 1, Void >, public ActorCallback< MonitorCacheListActor, 2, RangeResult >, public ActorCallback< MonitorCacheListActor, 3, Void >, public ActorCallback< MonitorCacheListActor, 4, Void >, public FastAllocated<MonitorCacheListActor>, public MonitorCacheListActorState<MonitorCacheListActor> {
															#line 5821 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<MonitorCacheListActor>::operator new;
	using FastAllocated<MonitorCacheListActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< MonitorCacheListActor, 0, Void >;
friend struct ActorCallback< MonitorCacheListActor, 1, Void >;
friend struct ActorCallback< MonitorCacheListActor, 2, RangeResult >;
friend struct ActorCallback< MonitorCacheListActor, 3, Void >;
friend struct ActorCallback< MonitorCacheListActor, 4, Void >;
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MonitorCacheListActor(DatabaseContext* const& self) 
															#line 5836 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   MonitorCacheListActorState<MonitorCacheListActor>(self)
	{
		fdb_probe_actor_enter("monitorCacheList", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("monitorCacheList");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("monitorCacheList", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MonitorCacheListActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< MonitorCacheListActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< MonitorCacheListActor, 2, RangeResult >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< MonitorCacheListActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< MonitorCacheListActor, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> monitorCacheList( DatabaseContext* const& self ) {
															#line 1097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new MonitorCacheListActor(self));
															#line 5868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 1147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 5873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via handleTssMismatches()
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class HandleTssMismatchesActor>
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class HandleTssMismatchesActorState {
															#line 5880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	HandleTssMismatchesActorState(DatabaseContext* const& cx) 
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 1149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(),
															#line 1150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tssMapDB(KeyBackedMap<UID, UID>(tssMappingKeys.begin)),
															#line 1151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tssMismatchDB(KeyBackedMap<Tuple, std::string>(tssMismatchKeys.begin))
															#line 5893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("handleTssMismatches", reinterpret_cast<unsigned long>(this));

	}
	~HandleTssMismatchesActorState() 
	{
		fdb_probe_actor_destroy("handleTssMismatches", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1152 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 5908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~HandleTssMismatchesActorState();
		static_cast<HandleTssMismatchesActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 1154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		FutureStream<std::pair<UID, std::vector<DetailedTSSMismatch>>> __when_expr_0 = cx->tssMismatchStream.getFuture();
															#line 1154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 5940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
		static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 1;
															#line 1154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >*>(static_cast<HandleTssMismatchesActor*>(this)));
															#line 5945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 1156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = delay(0);
															#line 1156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 5956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 2;
															#line 1156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< HandleTssMismatchesActor, 1, Void >*>(static_cast<HandleTssMismatchesActor*>(this)));
															#line 5961 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(std::pair<UID, std::vector<DetailedTSSMismatch>> const& __data,int loopDepth) 
	{
															#line 1154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		data = __data;
															#line 5970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::pair<UID, std::vector<DetailedTSSMismatch>> && __data,int loopDepth) 
	{
		data = std::move(__data);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state > 0) static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 0;
		static_cast<HandleTssMismatchesActor*>(this)->ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >::remove();

	}
	void a_callback_fire(ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >*,std::pair<UID, std::vector<DetailedTSSMismatch>> const& value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >*,std::pair<UID, std::vector<DetailedTSSMismatch>> && value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >*,Error err) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 1158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tssPairID = UID();
															#line 1159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool found = false;
															#line 1160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& it : cx->tssMapping ) {
															#line 1161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second.id() == data.first)
															#line 6043 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 1162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tssPairID = it.first;
															#line 1163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				found = true;
															#line 6049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				break;
			}
		}
															#line 1167 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (found)
															#line 6055 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1168 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			quarantine = CLIENT_KNOBS->QUARANTINE_TSS_ON_MISMATCH;
															#line 1169 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarnAlways, quarantine ? "TSS_QuarantineMismatch" : "TSS_KillMismatch") .detail("TSSID", data.first.toString());
															#line 1171 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(quarantine);
															#line 1172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(!quarantine);
															#line 1174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr = makeReference<ReadYourWritesTransaction>(Database(Reference<DatabaseContext>::addRef(cx)));
															#line 1175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tries = 0;
															#line 1176 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 6071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont2loopHead1(loopDepth);
		}
		else
		{
															#line 1211 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 6078 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 1158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tssPairID = UID();
															#line 1159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool found = false;
															#line 1160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& it : cx->tssMapping ) {
															#line 1161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it.second.id() == data.first)
															#line 6094 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 1162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tssPairID = it.first;
															#line 1163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				found = true;
															#line 6100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				break;
			}
		}
															#line 1167 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (found)
															#line 6106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1168 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			quarantine = CLIENT_KNOBS->QUARANTINE_TSS_ON_MISMATCH;
															#line 1169 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarnAlways, quarantine ? "TSS_QuarantineMismatch" : "TSS_KillMismatch") .detail("TSSID", data.first.toString());
															#line 1171 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(quarantine);
															#line 1172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(!quarantine);
															#line 1174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr = makeReference<ReadYourWritesTransaction>(Database(Reference<DatabaseContext>::addRef(cx)));
															#line 1175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tries = 0;
															#line 1176 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 6122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont2loopHead1(loopDepth);
		}
		else
		{
															#line 1211 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 6129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state > 0) static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 0;
		static_cast<HandleTssMismatchesActor*>(this)->ActorCallback< HandleTssMismatchesActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< HandleTssMismatchesActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< HandleTssMismatchesActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< HandleTssMismatchesActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
															#line 1209 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr = makeReference<ReadYourWritesTransaction>();
															#line 6208 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1(int loopDepth) 
	{
		try {
															#line 1178 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE);
															#line 1179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 1180 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (quarantine)
															#line 6229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 1181 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr->set(tssQuarantineKeyFor(data.first), LiteralStringRef(""));
															#line 6233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 1183 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr->clear(serverTagKeyFor(data.first));
															#line 6239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 1185 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tssMapDB.erase(tr, tssPairID);
															#line 1187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( const DetailedTSSMismatch& d : data.second ) {
															#line 1189 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tssMismatchDB.set( tr, Tuple().append(data.first.toString()).append(d.timestamp).append(d.mismatchId.toString()), d.traceString);
															#line 6247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 1195 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 1195 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 6253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont2loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2loopBody1when1(__when_expr_2.get(), loopDepth); };
			static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 3;
															#line 1195 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< HandleTssMismatchesActor, 2, Void >*>(static_cast<HandleTssMismatchesActor*>(this)));
															#line 6258 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont2loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont2loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont1(int loopDepth) 
	{
															#line 1201 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tries++;
															#line 1202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tries > 10)
															#line 6288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("TSS_MismatchGaveUp").detail("TSSID", data.first.toString());
															#line 6292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return a_body1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
		if (loopDepth == 0) return a_body1loopBody1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1199 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr->onError(e);
															#line 1199 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 6306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1cont2loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 4;
															#line 1199 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< HandleTssMismatchesActor, 3, Void >*>(static_cast<HandleTssMismatchesActor*>(this)));
															#line 6311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2(Void const& _,int loopDepth) 
	{
		return a_body1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2(Void && _,int loopDepth) 
	{
		return a_body1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state > 0) static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 0;
		static_cast<HandleTssMismatchesActor*>(this)->ActorCallback< HandleTssMismatchesActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< HandleTssMismatchesActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< HandleTssMismatchesActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< HandleTssMismatchesActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont2loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state > 0) static_cast<HandleTssMismatchesActor*>(this)->actor_wait_state = 0;
		static_cast<HandleTssMismatchesActor*>(this)->ActorCallback< HandleTssMismatchesActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< HandleTssMismatchesActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont2loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< HandleTssMismatchesActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont2loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< HandleTssMismatchesActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 1149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyBackedMap<UID, UID> tssMapDB;
															#line 1151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyBackedMap<Tuple, std::string> tssMismatchDB;
															#line 1154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::pair<UID, std::vector<DetailedTSSMismatch>> data;
															#line 1158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID tssPairID;
															#line 1168 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool quarantine;
															#line 1175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int tries;
															#line 6488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via handleTssMismatches()
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class HandleTssMismatchesActor final : public Actor<Void>, public ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >, public ActorCallback< HandleTssMismatchesActor, 1, Void >, public ActorCallback< HandleTssMismatchesActor, 2, Void >, public ActorCallback< HandleTssMismatchesActor, 3, Void >, public FastAllocated<HandleTssMismatchesActor>, public HandleTssMismatchesActorState<HandleTssMismatchesActor> {
															#line 6493 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<HandleTssMismatchesActor>::operator new;
	using FastAllocated<HandleTssMismatchesActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >;
friend struct ActorCallback< HandleTssMismatchesActor, 1, Void >;
friend struct ActorCallback< HandleTssMismatchesActor, 2, Void >;
friend struct ActorCallback< HandleTssMismatchesActor, 3, Void >;
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	HandleTssMismatchesActor(DatabaseContext* const& cx) 
															#line 6507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   HandleTssMismatchesActorState<HandleTssMismatchesActor>(cx)
	{
		fdb_probe_actor_enter("handleTssMismatches", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("handleTssMismatches");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("handleTssMismatches", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< HandleTssMismatchesActor, 0, std::pair<UID, std::vector<DetailedTSSMismatch>> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< HandleTssMismatchesActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< HandleTssMismatchesActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< HandleTssMismatchesActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> handleTssMismatches( DatabaseContext* const& cx ) {
															#line 1148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new HandleTssMismatchesActor(cx));
															#line 6538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 1215 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 6543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via backgroundGrvUpdater()
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class BackgroundGrvUpdaterActor>
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class BackgroundGrvUpdaterActorState {
															#line 6550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	BackgroundGrvUpdaterActorState(DatabaseContext* const& cx) 
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 1217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(),
															#line 1218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   grvDelay(0.001)
															#line 6561 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this));

	}
	~BackgroundGrvUpdaterActorState() 
	{
		fdb_probe_actor_destroy("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 1220 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				;
															#line 6577 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~BackgroundGrvUpdaterActorState();
		static_cast<BackgroundGrvUpdaterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1258 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevInfo, "BackgroundGrvUpdaterFailed").errorUnsuppressed(e);
															#line 1259 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 6609 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 1221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (CLIENT_KNOBS->FORCE_GRV_CACHE_OFF)
															#line 6630 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1222 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<BackgroundGrvUpdaterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~BackgroundGrvUpdaterActorState(); static_cast<BackgroundGrvUpdaterActor*>(this)->destroy(); return 0; }
															#line 6634 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<BackgroundGrvUpdaterActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~BackgroundGrvUpdaterActorState();
			static_cast<BackgroundGrvUpdaterActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1223 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = refreshTransaction(cx, &tr);
															#line 1223 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 6644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 1;
															#line 1223 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< BackgroundGrvUpdaterActor, 0, Void >*>(static_cast<BackgroundGrvUpdaterActor*>(this)));
															#line 6649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 1224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		curTime = now();
															#line 1225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastTime = cx->getLastGrvTime();
															#line 1226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastProxyTime = cx->lastProxyRequestTime;
															#line 1227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent(SevDebug, "BackgroundGrvUpdaterBefore") .detail("CurTime", curTime) .detail("LastTime", lastTime) .detail("GrvDelay", grvDelay) .detail("CachedReadVersion", cx->getCachedReadVersion()) .detail("CachedTime", cx->getLastGrvTime()) .detail("Gap", curTime - lastTime) .detail("Bound", CLIENT_KNOBS->MAX_VERSION_CACHE_LAG - grvDelay);
															#line 1235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (curTime - lastTime >= (CLIENT_KNOBS->MAX_VERSION_CACHE_LAG - grvDelay) || curTime - lastProxyTime > CLIENT_KNOBS->MAX_PROXY_CONTACT_LAG)
															#line 6666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			try {
															#line 1238 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr.setOption(FDBTransactionOptions::SKIP_GRV_CACHE);
															#line 1239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_1 = success(tr.getReadVersion());
															#line 1239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 6675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
				static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 2;
															#line 1239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< BackgroundGrvUpdaterActor, 1, Void >*>(static_cast<BackgroundGrvUpdaterActor*>(this)));
															#line 6680 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
															#line 1251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = delay(std::max(0.001, std::min(CLIENT_KNOBS->MAX_PROXY_CONTACT_LAG - (curTime - lastProxyTime), (CLIENT_KNOBS->MAX_VERSION_CACHE_LAG - grvDelay) - (curTime - lastTime))));
															#line 1251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch2(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when2(__when_expr_3.get(), loopDepth); };
			static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 4;
															#line 1251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< BackgroundGrvUpdaterActor, 3, Void >*>(static_cast<BackgroundGrvUpdaterActor*>(this)));
															#line 6700 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 1224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		curTime = now();
															#line 1225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastTime = cx->getLastGrvTime();
															#line 1226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastProxyTime = cx->lastProxyRequestTime;
															#line 1227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent(SevDebug, "BackgroundGrvUpdaterBefore") .detail("CurTime", curTime) .detail("LastTime", lastTime) .detail("GrvDelay", grvDelay) .detail("CachedReadVersion", cx->getCachedReadVersion()) .detail("CachedTime", cx->getLastGrvTime()) .detail("Gap", curTime - lastTime) .detail("Bound", CLIENT_KNOBS->MAX_VERSION_CACHE_LAG - grvDelay);
															#line 1235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (curTime - lastTime >= (CLIENT_KNOBS->MAX_VERSION_CACHE_LAG - grvDelay) || curTime - lastProxyTime > CLIENT_KNOBS->MAX_PROXY_CONTACT_LAG)
															#line 6718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			try {
															#line 1238 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr.setOption(FDBTransactionOptions::SKIP_GRV_CACHE);
															#line 1239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_1 = success(tr.getReadVersion());
															#line 1239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 6727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
				static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 2;
															#line 1239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< BackgroundGrvUpdaterActor, 1, Void >*>(static_cast<BackgroundGrvUpdaterActor*>(this)));
															#line 6732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
															#line 1251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = delay(std::max(0.001, std::min(CLIENT_KNOBS->MAX_PROXY_CONTACT_LAG - (curTime - lastProxyTime), (CLIENT_KNOBS->MAX_VERSION_CACHE_LAG - grvDelay) - (curTime - lastTime))));
															#line 1251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 6747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch2(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when2(__when_expr_3.get(), loopDepth); };
			static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 4;
															#line 1251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< BackgroundGrvUpdaterActor, 3, Void >*>(static_cast<BackgroundGrvUpdaterActor*>(this)));
															#line 6752 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state > 0) static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<BackgroundGrvUpdaterActor*>(this)->ActorCallback< BackgroundGrvUpdaterActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< BackgroundGrvUpdaterActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevInfo, "BackgroundGrvUpdaterTxnError").errorUnsuppressed(e);
															#line 1248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr.onError(e);
															#line 1248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 6842 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch2(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 3;
															#line 1248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< BackgroundGrvUpdaterActor, 2, Void >*>(static_cast<BackgroundGrvUpdaterActor*>(this)));
															#line 6847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont5(Void const& _,int loopDepth) 
	{
															#line 1240 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->lastProxyRequestTime = curTime;
															#line 1241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		grvDelay = (grvDelay + (now() - curTime)) / 2.0;
															#line 1242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent(SevDebug, "BackgroundGrvUpdaterSuccess") .detail("GrvDelay", grvDelay) .detail("CachedReadVersion", cx->getCachedReadVersion()) .detail("CachedTime", cx->getLastGrvTime());
															#line 6866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont5(Void && _,int loopDepth) 
	{
															#line 1240 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->lastProxyRequestTime = curTime;
															#line 1241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		grvDelay = (grvDelay + (now() - curTime)) / 2.0;
															#line 1242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent(SevDebug, "BackgroundGrvUpdaterSuccess") .detail("GrvDelay", grvDelay) .detail("CachedReadVersion", cx->getCachedReadVersion()) .detail("CachedTime", cx->getLastGrvTime());
															#line 6879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state > 0) static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<BackgroundGrvUpdaterActor*>(this)->ActorCallback< BackgroundGrvUpdaterActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< BackgroundGrvUpdaterActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont7(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state > 0) static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<BackgroundGrvUpdaterActor*>(this)->ActorCallback< BackgroundGrvUpdaterActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< BackgroundGrvUpdaterActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont8(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont8(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state > 0) static_cast<BackgroundGrvUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<BackgroundGrvUpdaterActor*>(this)->ActorCallback< BackgroundGrvUpdaterActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< BackgroundGrvUpdaterActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< BackgroundGrvUpdaterActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 1217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 1218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double grvDelay;
															#line 1224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double curTime;
															#line 1225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double lastTime;
															#line 1226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double lastProxyTime;
															#line 7122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via backgroundGrvUpdater()
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class BackgroundGrvUpdaterActor final : public Actor<Void>, public ActorCallback< BackgroundGrvUpdaterActor, 0, Void >, public ActorCallback< BackgroundGrvUpdaterActor, 1, Void >, public ActorCallback< BackgroundGrvUpdaterActor, 2, Void >, public ActorCallback< BackgroundGrvUpdaterActor, 3, Void >, public FastAllocated<BackgroundGrvUpdaterActor>, public BackgroundGrvUpdaterActorState<BackgroundGrvUpdaterActor> {
															#line 7127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<BackgroundGrvUpdaterActor>::operator new;
	using FastAllocated<BackgroundGrvUpdaterActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< BackgroundGrvUpdaterActor, 0, Void >;
friend struct ActorCallback< BackgroundGrvUpdaterActor, 1, Void >;
friend struct ActorCallback< BackgroundGrvUpdaterActor, 2, Void >;
friend struct ActorCallback< BackgroundGrvUpdaterActor, 3, Void >;
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	BackgroundGrvUpdaterActor(DatabaseContext* const& cx) 
															#line 7141 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   BackgroundGrvUpdaterActorState<BackgroundGrvUpdaterActor>(cx)
	{
		fdb_probe_actor_enter("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("backgroundGrvUpdater");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("backgroundGrvUpdater", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< BackgroundGrvUpdaterActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< BackgroundGrvUpdaterActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< BackgroundGrvUpdaterActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< BackgroundGrvUpdaterActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> backgroundGrvUpdater( DatabaseContext* const& cx ) {
															#line 1216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new BackgroundGrvUpdaterActor(cx));
															#line 7172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 1262 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 7177 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getHealthMetricsActor()
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetHealthMetricsActorActor>
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetHealthMetricsActorActorState {
															#line 7184 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetHealthMetricsActorActorState(DatabaseContext* const& cx,bool const& detailed) 
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   detailed(detailed)
															#line 7193 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getHealthMetricsActor", reinterpret_cast<unsigned long>(this));

	}
	~GetHealthMetricsActorActorState() 
	{
		fdb_probe_actor_destroy("getHealthMetricsActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1264 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (now() - cx->healthMetricsLastUpdated < CLIENT_KNOBS->AGGREGATE_HEALTH_METRICS_MAX_STALENESS)
															#line 7208 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 1265 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (detailed)
															#line 7212 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 1266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!static_cast<GetHealthMetricsActorActor*>(this)->SAV<HealthMetrics>::futures) { (void)(cx->healthMetrics); this->~GetHealthMetricsActorActorState(); static_cast<GetHealthMetricsActorActor*>(this)->destroy(); return 0; }
															#line 7216 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					new (&static_cast<GetHealthMetricsActorActor*>(this)->SAV< HealthMetrics >::value()) HealthMetrics(cx->healthMetrics);
					this->~GetHealthMetricsActorActorState();
					static_cast<GetHealthMetricsActorActor*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
				else
				{
															#line 1268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					HealthMetrics result;
															#line 1269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					result.update(cx->healthMetrics, false, false);
															#line 1270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!static_cast<GetHealthMetricsActorActor*>(this)->SAV<HealthMetrics>::futures) { (void)(result); this->~GetHealthMetricsActorActorState(); static_cast<GetHealthMetricsActorActor*>(this)->destroy(); return 0; }
															#line 7230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					new (&static_cast<GetHealthMetricsActorActor*>(this)->SAV< HealthMetrics >::value()) HealthMetrics(result);
					this->~GetHealthMetricsActorActorState();
					static_cast<GetHealthMetricsActorActor*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
			}
															#line 1273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			sendDetailedRequest = detailed && now() - cx->detailedHealthMetricsLastUpdated > CLIENT_KNOBS->DETAILED_HEALTH_METRICS_MAX_STALENESS;
															#line 1275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 7241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetHealthMetricsActorActorState();
		static_cast<GetHealthMetricsActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 1277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = cx->onProxiesChanged();
															#line 1276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetHealthMetricsActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 7273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 1278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<GetHealthMetricsReply> __when_expr_1 = basicLoadBalance(cx->getGrvProxies(UseProvisionalProxies::False), &GrvProxyInterface::getHealthMetrics, GetHealthMetricsRequest(sendDetailedRequest));
															#line 7277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
		static_cast<GetHealthMetricsActorActor*>(this)->actor_wait_state = 1;
															#line 1277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetHealthMetricsActorActor, 0, Void >*>(static_cast<GetHealthMetricsActorActor*>(this)));
															#line 1278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetHealthMetricsActorActor, 1, GetHealthMetricsReply >*>(static_cast<GetHealthMetricsActorActor*>(this)));
															#line 7284 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(GetHealthMetricsReply const& rep,int loopDepth) 
	{
															#line 1281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->healthMetrics.update(rep.healthMetrics, detailed, true);
															#line 1282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (detailed)
															#line 7313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->healthMetricsLastUpdated = now();
															#line 1284 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->detailedHealthMetricsLastUpdated = now();
															#line 1285 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetHealthMetricsActorActor*>(this)->SAV<HealthMetrics>::futures) { (void)(cx->healthMetrics); this->~GetHealthMetricsActorActorState(); static_cast<GetHealthMetricsActorActor*>(this)->destroy(); return 0; }
															#line 7321 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetHealthMetricsActorActor*>(this)->SAV< HealthMetrics >::value()) HealthMetrics(cx->healthMetrics);
			this->~GetHealthMetricsActorActorState();
			static_cast<GetHealthMetricsActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 1287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->healthMetricsLastUpdated = now();
															#line 1288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			HealthMetrics result;
															#line 1289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			result.update(cx->healthMetrics, false, false);
															#line 1290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetHealthMetricsActorActor*>(this)->SAV<HealthMetrics>::futures) { (void)(result); this->~GetHealthMetricsActorActorState(); static_cast<GetHealthMetricsActorActor*>(this)->destroy(); return 0; }
															#line 7337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetHealthMetricsActorActor*>(this)->SAV< HealthMetrics >::value()) HealthMetrics(result);
			this->~GetHealthMetricsActorActorState();
			static_cast<GetHealthMetricsActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1when2(GetHealthMetricsReply && rep,int loopDepth) 
	{
															#line 1281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->healthMetrics.update(rep.healthMetrics, detailed, true);
															#line 1282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (detailed)
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 1283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->healthMetricsLastUpdated = now();
															#line 1284 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->detailedHealthMetricsLastUpdated = now();
															#line 1285 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetHealthMetricsActorActor*>(this)->SAV<HealthMetrics>::futures) { (void)(cx->healthMetrics); this->~GetHealthMetricsActorActorState(); static_cast<GetHealthMetricsActorActor*>(this)->destroy(); return 0; }
															#line 7360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetHealthMetricsActorActor*>(this)->SAV< HealthMetrics >::value()) HealthMetrics(cx->healthMetrics);
			this->~GetHealthMetricsActorActorState();
			static_cast<GetHealthMetricsActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 1287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->healthMetricsLastUpdated = now();
															#line 1288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			HealthMetrics result;
															#line 1289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			result.update(cx->healthMetrics, false, false);
															#line 1290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetHealthMetricsActorActor*>(this)->SAV<HealthMetrics>::futures) { (void)(result); this->~GetHealthMetricsActorActorState(); static_cast<GetHealthMetricsActorActor*>(this)->destroy(); return 0; }
															#line 7376 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetHealthMetricsActorActor*>(this)->SAV< HealthMetrics >::value()) HealthMetrics(result);
			this->~GetHealthMetricsActorActorState();
			static_cast<GetHealthMetricsActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetHealthMetricsActorActor*>(this)->actor_wait_state > 0) static_cast<GetHealthMetricsActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetHealthMetricsActorActor*>(this)->ActorCallback< GetHealthMetricsActorActor, 0, Void >::remove();
		static_cast<GetHealthMetricsActorActor*>(this)->ActorCallback< GetHealthMetricsActorActor, 1, GetHealthMetricsReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetHealthMetricsActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetHealthMetricsActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetHealthMetricsActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetHealthMetricsActorActor, 1, GetHealthMetricsReply >*,GetHealthMetricsReply const& value) 
	{
		fdb_probe_actor_enter("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetHealthMetricsActorActor, 1, GetHealthMetricsReply >*,GetHealthMetricsReply && value) 
	{
		fdb_probe_actor_enter("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetHealthMetricsActorActor, 1, GetHealthMetricsReply >*,Error err) 
	{
		fdb_probe_actor_enter("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool detailed;
															#line 1273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool sendDetailedRequest;
															#line 7488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getHealthMetricsActor()
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetHealthMetricsActorActor final : public Actor<HealthMetrics>, public ActorCallback< GetHealthMetricsActorActor, 0, Void >, public ActorCallback< GetHealthMetricsActorActor, 1, GetHealthMetricsReply >, public FastAllocated<GetHealthMetricsActorActor>, public GetHealthMetricsActorActorState<GetHealthMetricsActorActor> {
															#line 7493 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetHealthMetricsActorActor>::operator new;
	using FastAllocated<GetHealthMetricsActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<HealthMetrics>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetHealthMetricsActorActor, 0, Void >;
friend struct ActorCallback< GetHealthMetricsActorActor, 1, GetHealthMetricsReply >;
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetHealthMetricsActorActor(DatabaseContext* const& cx,bool const& detailed) 
															#line 7505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<HealthMetrics>(),
		   GetHealthMetricsActorActorState<GetHealthMetricsActorActor>(cx, detailed)
	{
		fdb_probe_actor_enter("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getHealthMetricsActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getHealthMetricsActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetHealthMetricsActorActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<HealthMetrics> getHealthMetricsActor( DatabaseContext* const& cx, bool const& detailed ) {
															#line 1263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<HealthMetrics>(new GetHealthMetricsActorActor(cx, detailed));
															#line 7533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 1296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<HealthMetrics> DatabaseContext::getHealthMetrics(bool detailed = false) {
	return getHealthMetricsActor(this, detailed);
}

void DatabaseContext::registerSpecialKeySpaceModule(SpecialKeySpace::MODULE module,
                                                    SpecialKeySpace::IMPLTYPE type,
                                                    std::unique_ptr<SpecialKeyRangeReadImpl>&& impl) {
	specialKeySpace->registerKeyRange(module, type, impl->getKeyRange(), impl.get());
	specialKeySpaceModules.push_back(std::move(impl));
}

															#line 7549 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
[[nodiscard]] Future<RangeResult> getWorkerInterfaces( Reference<IClusterConnectionRecord> const& clusterRecord );

#line 1309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
[[nodiscard]] Future<Optional<Value>> getJSON( Database const& db );

#line 1310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

struct WorkerInterfacesSpecialKeyImpl : SpecialKeyRangeReadImpl {
	Future<RangeResult> getRange(ReadYourWritesTransaction* ryw,
	                             KeyRangeRef kr,
	                             GetRangeLimits limitsHint) const override {
		if (ryw->getDatabase().getPtr() && ryw->getDatabase()->getConnectionRecord()) {
			Key prefix = Key(getKeyRange().begin);
			return map(getWorkerInterfaces(ryw->getDatabase()->getConnectionRecord()),
			           [prefix = prefix, kr = KeyRange(kr)](const RangeResult& in) {
				           RangeResult result;
				           for (const auto& [k_, v] : in) {
					           auto k = k_.withPrefix(prefix);
					           if (kr.contains(k))
						           result.push_back_deep(result.arena(), KeyValueRef(k, v));
				           }

				           std::sort(result.begin(), result.end(), KeyValueRef::OrderByKey{});
				           return result;
			           });
		} else {
			return RangeResult();
		}
	}

	explicit WorkerInterfacesSpecialKeyImpl(KeyRangeRef kr) : SpecialKeyRangeReadImpl(kr) {}
};

struct SingleSpecialKeyImpl : SpecialKeyRangeReadImpl {
	Future<RangeResult> getRange(ReadYourWritesTransaction* ryw,
	                             KeyRangeRef kr,
	                             GetRangeLimits limitsHint) const override {
		ASSERT(kr.contains(k));
		return map(f(ryw), [k = k](Optional<Value> v) {
			RangeResult result;
			if (v.present()) {
				result.push_back_deep(result.arena(), KeyValueRef(k, v.get()));
			}
			return result;
		});
	}

	SingleSpecialKeyImpl(KeyRef k, const std::function<Future<Optional<Value>>(ReadYourWritesTransaction*)>& f)
	  : SpecialKeyRangeReadImpl(singleKeyRange(k)), k(k), f(f) {}

private:
	Key k;
	std::function<Future<Optional<Value>>(ReadYourWritesTransaction*)> f;
};

class HealthMetricsRangeImpl : public SpecialKeyRangeAsyncImpl {
public:
	explicit HealthMetricsRangeImpl(KeyRangeRef kr);
	Future<RangeResult> getRange(ReadYourWritesTransaction* ryw,
	                             KeyRangeRef kr,
	                             GetRangeLimits limitsHint) const override;
};

static RangeResult healthMetricsToKVPairs(const HealthMetrics& metrics, KeyRangeRef kr) {
	RangeResult result;
	if (CLIENT_BUGGIFY)
		return result;
	if (kr.contains(LiteralStringRef("\xff\xff/metrics/health/aggregate")) && metrics.worstStorageDurabilityLag != 0) {
		json_spirit::mObject statsObj;
		statsObj["batch_limited"] = metrics.batchLimited;
		statsObj["tps_limit"] = metrics.tpsLimit;
		statsObj["worst_storage_durability_lag"] = metrics.worstStorageDurabilityLag;
		statsObj["limiting_storage_durability_lag"] = metrics.limitingStorageDurabilityLag;
		statsObj["worst_storage_queue"] = metrics.worstStorageQueue;
		statsObj["limiting_storage_queue"] = metrics.limitingStorageQueue;
		statsObj["worst_log_queue"] = metrics.worstTLogQueue;
		std::string statsString =
		    json_spirit::write_string(json_spirit::mValue(statsObj), json_spirit::Output_options::raw_utf8);
		ValueRef bytes(result.arena(), statsString);
		result.push_back(result.arena(), KeyValueRef(LiteralStringRef("\xff\xff/metrics/health/aggregate"), bytes));
	}
	// tlog stats
	{
		int phase = 0; // Avoid comparing twice per loop iteration
		for (const auto& [uid, logStats] : metrics.tLogQueue) {
			StringRef k{
				StringRef(uid.toString()).withPrefix(LiteralStringRef("\xff\xff/metrics/health/log/"), result.arena())
			};
			if (phase == 0 && k >= kr.begin) {
				phase = 1;
			}
			if (phase == 1) {
				if (k < kr.end) {
					json_spirit::mObject statsObj;
					statsObj["log_queue"] = logStats;
					std::string statsString =
					    json_spirit::write_string(json_spirit::mValue(statsObj), json_spirit::Output_options::raw_utf8);
					ValueRef bytes(result.arena(), statsString);
					result.push_back(result.arena(), KeyValueRef(k, bytes));
				} else {
					break;
				}
			}
		}
	}
	// Storage stats
	{
		int phase = 0; // Avoid comparing twice per loop iteration
		for (const auto& [uid, storageStats] : metrics.storageStats) {
			StringRef k{ StringRef(uid.toString())
				             .withPrefix(LiteralStringRef("\xff\xff/metrics/health/storage/"), result.arena()) };
			if (phase == 0 && k >= kr.begin) {
				phase = 1;
			}
			if (phase == 1) {
				if (k < kr.end) {
					json_spirit::mObject statsObj;
					statsObj["storage_durability_lag"] = storageStats.storageDurabilityLag;
					statsObj["storage_queue"] = storageStats.storageQueue;
					statsObj["cpu_usage"] = storageStats.cpuUsage;
					statsObj["disk_usage"] = storageStats.diskUsage;
					std::string statsString =
					    json_spirit::write_string(json_spirit::mValue(statsObj), json_spirit::Output_options::raw_utf8);
					ValueRef bytes(result.arena(), statsString);
					result.push_back(result.arena(), KeyValueRef(k, bytes));
				} else {
					break;
				}
			}
		}
	}
	return result;
}

															#line 7685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via healthMetricsGetRangeActor()
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class HealthMetricsGetRangeActorActor>
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class HealthMetricsGetRangeActorActorState {
															#line 7692 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	HealthMetricsGetRangeActorActorState(ReadYourWritesTransaction* const& ryw,KeyRangeRef const& kr) 
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : ryw(ryw),
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   kr(kr)
															#line 7701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this));

	}
	~HealthMetricsGetRangeActorActorState() 
	{
		fdb_probe_actor_destroy("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<HealthMetrics> __when_expr_0 = ryw->getDatabase()->getHealthMetrics( kr.intersects(KeyRangeRef(LiteralStringRef("\xff\xff/metrics/health/storage/"), LiteralStringRef("\xff\xff/metrics/health/storage0"))) || kr.intersects(KeyRangeRef(LiteralStringRef("\xff\xff/metrics/health/log/"), LiteralStringRef("\xff\xff/metrics/health/log0"))));
															#line 1439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<HealthMetricsGetRangeActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<HealthMetricsGetRangeActorActor*>(this)->actor_wait_state = 1;
															#line 1439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >*>(static_cast<HealthMetricsGetRangeActorActor*>(this)));
															#line 7723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~HealthMetricsGetRangeActorActorState();
		static_cast<HealthMetricsGetRangeActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(HealthMetrics const& metrics,int loopDepth) 
	{
															#line 1444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<HealthMetricsGetRangeActorActor*>(this)->SAV<RangeResult>::futures) { (void)(healthMetricsToKVPairs(metrics, kr)); this->~HealthMetricsGetRangeActorActorState(); static_cast<HealthMetricsGetRangeActorActor*>(this)->destroy(); return 0; }
															#line 7746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<HealthMetricsGetRangeActorActor*>(this)->SAV< RangeResult >::value()) RangeResult(healthMetricsToKVPairs(metrics, kr));
		this->~HealthMetricsGetRangeActorActorState();
		static_cast<HealthMetricsGetRangeActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(HealthMetrics && metrics,int loopDepth) 
	{
															#line 1444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<HealthMetricsGetRangeActorActor*>(this)->SAV<RangeResult>::futures) { (void)(healthMetricsToKVPairs(metrics, kr)); this->~HealthMetricsGetRangeActorActorState(); static_cast<HealthMetricsGetRangeActorActor*>(this)->destroy(); return 0; }
															#line 7758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<HealthMetricsGetRangeActorActor*>(this)->SAV< RangeResult >::value()) RangeResult(healthMetricsToKVPairs(metrics, kr));
		this->~HealthMetricsGetRangeActorActorState();
		static_cast<HealthMetricsGetRangeActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(HealthMetrics const& metrics,int loopDepth) 
	{
		loopDepth = a_body1cont1(metrics, loopDepth);

		return loopDepth;
	}
	int a_body1when1(HealthMetrics && metrics,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(metrics), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<HealthMetricsGetRangeActorActor*>(this)->actor_wait_state > 0) static_cast<HealthMetricsGetRangeActorActor*>(this)->actor_wait_state = 0;
		static_cast<HealthMetricsGetRangeActorActor*>(this)->ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >::remove();

	}
	void a_callback_fire(ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >*,HealthMetrics const& value) 
	{
		fdb_probe_actor_enter("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >*,HealthMetrics && value) 
	{
		fdb_probe_actor_enter("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >*,Error err) 
	{
		fdb_probe_actor_enter("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadYourWritesTransaction* ryw;
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeRef kr;
															#line 7833 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via healthMetricsGetRangeActor()
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class HealthMetricsGetRangeActorActor final : public Actor<RangeResult>, public ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >, public FastAllocated<HealthMetricsGetRangeActorActor>, public HealthMetricsGetRangeActorActorState<HealthMetricsGetRangeActorActor> {
															#line 7838 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<HealthMetricsGetRangeActorActor>::operator new;
	using FastAllocated<HealthMetricsGetRangeActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<RangeResult>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >;
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	HealthMetricsGetRangeActorActor(ReadYourWritesTransaction* const& ryw,KeyRangeRef const& kr) 
															#line 7849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<RangeResult>(),
		   HealthMetricsGetRangeActorActorState<HealthMetricsGetRangeActorActor>(ryw, kr)
	{
		fdb_probe_actor_enter("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("healthMetricsGetRangeActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("healthMetricsGetRangeActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< HealthMetricsGetRangeActorActor, 0, HealthMetrics >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<RangeResult> healthMetricsGetRangeActor( ReadYourWritesTransaction* const& ryw, KeyRangeRef const& kr ) {
															#line 1438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<RangeResult>(new HealthMetricsGetRangeActorActor(ryw, kr));
															#line 7877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 1446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

HealthMetricsRangeImpl::HealthMetricsRangeImpl(KeyRangeRef kr) : SpecialKeyRangeAsyncImpl(kr) {}

Future<RangeResult> HealthMetricsRangeImpl::getRange(ReadYourWritesTransaction* ryw,
                                                     KeyRangeRef kr,
                                                     GetRangeLimits limitsHint) const {
	return healthMetricsGetRangeActor(ryw, kr);
}

KeyRangeRef toRelativeRange(KeyRangeRef range, KeyRef prefix) {
	if (prefix.empty()) {
		return range;
	} else {
		KeyRef begin = range.begin.startsWith(prefix) ? range.begin.removePrefix(prefix) : allKeys.begin;
		KeyRef end = range.end.startsWith(prefix) ? range.end.removePrefix(prefix) : allKeys.end;
		return KeyRangeRef(begin, end);
	}
}

DatabaseContext::DatabaseContext(Reference<AsyncVar<Reference<IClusterConnectionRecord>>> connectionRecord,
                                 Reference<AsyncVar<ClientDBInfo>> clientInfo,
                                 Reference<AsyncVar<Optional<ClientLeaderRegInterface>> const> coordinator,
                                 Future<Void> clientInfoMonitor,
                                 TaskPriority taskID,
                                 LocalityData const& clientLocality,
                                 EnableLocalityLoadBalance enableLocalityLoadBalance,
                                 LockAware lockAware,
                                 IsInternal internal,
                                 int apiVersion,
                                 IsSwitchable switchable,
                                 Optional<TenantName> defaultTenant)
  : lockAware(lockAware), switchable(switchable), connectionRecord(connectionRecord), proxyProvisional(false),
    clientLocality(clientLocality), enableLocalityLoadBalance(enableLocalityLoadBalance), defaultTenant(defaultTenant),
    internal(internal), cc("TransactionMetrics"), transactionReadVersions("ReadVersions", cc),
    transactionReadVersionsThrottled("ReadVersionsThrottled", cc),
    transactionReadVersionsCompleted("ReadVersionsCompleted", cc),
    transactionReadVersionBatches("ReadVersionBatches", cc),
    transactionBatchReadVersions("BatchPriorityReadVersions", cc),
    transactionDefaultReadVersions("DefaultPriorityReadVersions", cc),
    transactionImmediateReadVersions("ImmediatePriorityReadVersions", cc),
    transactionBatchReadVersionsCompleted("BatchPriorityReadVersionsCompleted", cc),
    transactionDefaultReadVersionsCompleted("DefaultPriorityReadVersionsCompleted", cc),
    transactionImmediateReadVersionsCompleted("ImmediatePriorityReadVersionsCompleted", cc),
    transactionLogicalReads("LogicalUncachedReads", cc), transactionPhysicalReads("PhysicalReadRequests", cc),
    transactionPhysicalReadsCompleted("PhysicalReadRequestsCompleted", cc),
    transactionGetKeyRequests("GetKeyRequests", cc), transactionGetValueRequests("GetValueRequests", cc),
    transactionGetRangeRequests("GetRangeRequests", cc),
    transactionGetMappedRangeRequests("GetMappedRangeRequests", cc),
    transactionGetRangeStreamRequests("GetRangeStreamRequests", cc), transactionWatchRequests("WatchRequests", cc),
    transactionGetAddressesForKeyRequests("GetAddressesForKeyRequests", cc), transactionBytesRead("BytesRead", cc),
    transactionKeysRead("KeysRead", cc), transactionMetadataVersionReads("MetadataVersionReads", cc),
    transactionCommittedMutations("CommittedMutations", cc),
    transactionCommittedMutationBytes("CommittedMutationBytes", cc), transactionSetMutations("SetMutations", cc),
    transactionClearMutations("ClearMutations", cc), transactionAtomicMutations("AtomicMutations", cc),
    transactionsCommitStarted("CommitStarted", cc), transactionsCommitCompleted("CommitCompleted", cc),
    transactionKeyServerLocationRequests("KeyServerLocationRequests", cc),
    transactionKeyServerLocationRequestsCompleted("KeyServerLocationRequestsCompleted", cc),
    transactionStatusRequests("StatusRequests", cc), transactionsTooOld("TooOld", cc),
    transactionsFutureVersions("FutureVersions", cc), transactionsNotCommitted("NotCommitted", cc),
    transactionsMaybeCommitted("MaybeCommitted", cc), transactionsResourceConstrained("ResourceConstrained", cc),
    transactionsProcessBehind("ProcessBehind", cc), transactionsThrottled("Throttled", cc),
    transactionsExpensiveClearCostEstCount("ExpensiveClearCostEstCount", cc),
    transactionGrvFullBatches("NumGrvFullBatches", cc), transactionGrvTimedOutBatches("NumGrvTimedOutBatches", cc),
    transactionCommitVersionNotFoundForSS("CommitVersionNotFoundForSS", cc), latencies(1000), readLatencies(1000),
    commitLatencies(1000), GRVLatencies(1000), mutationsPerCommit(1000), bytesPerCommit(1000), bgLatencies(1000),
    bgGranulesPerRequest(1000), outstandingWatches(0), sharedStatePtr(nullptr), lastGrvTime(0.0), cachedReadVersion(0),
    lastRkBatchThrottleTime(0.0), lastRkDefaultThrottleTime(0.0), lastProxyRequestTime(0.0),
    transactionTracingSample(false), taskID(taskID), clientInfo(clientInfo), clientInfoMonitor(clientInfoMonitor),
    coordinator(coordinator), apiVersion(apiVersion), mvCacheInsertLocation(0), healthMetricsLastUpdated(0),
    detailedHealthMetricsLastUpdated(0), smoothMidShardSize(CLIENT_KNOBS->SHARD_STAT_SMOOTH_AMOUNT),
    specialKeySpace(std::make_unique<SpecialKeySpace>(specialKeys.begin, specialKeys.end, /* test */ false)),
    connectToDatabaseEventCacheHolder(format("ConnectToDatabase/%s", dbId.toString().c_str())) {

	dbId = deterministicRandom()->randomUniqueID();

	TraceEvent("DatabaseContextCreated", dbId).backtrace();

	connected = (clientInfo->get().commitProxies.size() && clientInfo->get().grvProxies.size())
	                ? Void()
	                : clientInfo->onChange();

	metadataVersionCache.resize(CLIENT_KNOBS->METADATA_VERSION_CACHE_SIZE);
	maxOutstandingWatches = CLIENT_KNOBS->DEFAULT_MAX_OUTSTANDING_WATCHES;

	snapshotRywEnabled = apiVersionAtLeast(300) ? 1 : 0;

	logger = databaseLogger(this) && tssLogger(this);
	locationCacheSize = g_network->isSimulated() ? CLIENT_KNOBS->LOCATION_CACHE_EVICTION_SIZE_SIM
	                                             : CLIENT_KNOBS->LOCATION_CACHE_EVICTION_SIZE;
	tenantCacheSize = g_network->isSimulated() ? CLIENT_KNOBS->TENANT_CACHE_EVICTION_SIZE_SIM
	                                           : CLIENT_KNOBS->TENANT_CACHE_EVICTION_SIZE;

	getValueSubmitted.init(LiteralStringRef("NativeAPI.GetValueSubmitted"));
	getValueCompleted.init(LiteralStringRef("NativeAPI.GetValueCompleted"));

	clientDBInfoMonitor = monitorClientDBInfoChange(this, clientInfo, &proxiesChangeTrigger);
	tssMismatchHandler = handleTssMismatches(this);
	clientStatusUpdater.actor = clientStatusUpdateActor(this);
	cacheListMonitor = monitorCacheList(this);

	smoothMidShardSize.reset(CLIENT_KNOBS->INIT_MID_SHARD_BYTES);
	globalConfig = std::make_unique<GlobalConfig>(this);

	if (apiVersionAtLeast(710)) {
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<TenantMapRangeImpl>(SpecialKeySpace::getManagementApiCommandRange("tenantmap")));
	}
	if (apiVersionAtLeast(700)) {
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::ERRORMSG,
		                              SpecialKeySpace::IMPLTYPE::READONLY,
		                              std::make_unique<SingleSpecialKeyImpl>(
		                                  SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::ERRORMSG).begin,
		                                  [](ReadYourWritesTransaction* ryw) -> Future<Optional<Value>> {
			                                  if (ryw->getSpecialKeySpaceErrorMsg().present())
				                                  return Optional<Value>(ryw->getSpecialKeySpaceErrorMsg().get());
			                                  else
				                                  return Optional<Value>();
		                                  }));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<ManagementCommandsOptionsImpl>(
		        KeyRangeRef(LiteralStringRef("options/"), LiteralStringRef("options0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<ExcludeServersRangeImpl>(SpecialKeySpace::getManagementApiCommandRange("exclude")));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<FailedServersRangeImpl>(SpecialKeySpace::getManagementApiCommandRange("failed")));
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::MANAGEMENT,
		                              SpecialKeySpace::IMPLTYPE::READWRITE,
		                              std::make_unique<ExcludedLocalitiesRangeImpl>(
		                                  SpecialKeySpace::getManagementApiCommandRange("excludedlocality")));
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::MANAGEMENT,
		                              SpecialKeySpace::IMPLTYPE::READWRITE,
		                              std::make_unique<FailedLocalitiesRangeImpl>(
		                                  SpecialKeySpace::getManagementApiCommandRange("failedlocality")));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<ExclusionInProgressRangeImpl>(
		        KeyRangeRef(LiteralStringRef("in_progress_exclusion/"), LiteralStringRef("in_progress_exclusion0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::CONFIGURATION,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<ProcessClassRangeImpl>(
		        KeyRangeRef(LiteralStringRef("process/class_type/"), LiteralStringRef("process/class_type0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::CONFIGURATION).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::CONFIGURATION,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<ProcessClassSourceRangeImpl>(
		        KeyRangeRef(LiteralStringRef("process/class_source/"), LiteralStringRef("process/class_source0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::CONFIGURATION).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<LockDatabaseImpl>(
		        singleKeyRange(LiteralStringRef("db_locked"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<ConsistencyCheckImpl>(
		        singleKeyRange(LiteralStringRef("consistency_check_suspended"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::GLOBALCONFIG,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<GlobalConfigImpl>(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::GLOBALCONFIG)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::TRACING,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<TracingOptionsImpl>(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::TRACING)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::CONFIGURATION,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<CoordinatorsImpl>(
		        KeyRangeRef(LiteralStringRef("coordinators/"), LiteralStringRef("coordinators0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::CONFIGURATION).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<CoordinatorsAutoImpl>(
		        singleKeyRange(LiteralStringRef("auto_coordinators"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<AdvanceVersionImpl>(
		        singleKeyRange(LiteralStringRef("min_required_commit_version"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<VersionEpochImpl>(
		        singleKeyRange(LiteralStringRef("version_epoch"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<ClientProfilingImpl>(
		        KeyRangeRef(LiteralStringRef("profiling/"), LiteralStringRef("profiling0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<MaintenanceImpl>(
		        KeyRangeRef(LiteralStringRef("maintenance/"), LiteralStringRef("maintenance0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::MANAGEMENT,
		    SpecialKeySpace::IMPLTYPE::READWRITE,
		    std::make_unique<DataDistributionImpl>(
		        KeyRangeRef(LiteralStringRef("data_distribution/"), LiteralStringRef("data_distribution0"))
		            .withPrefix(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::MANAGEMENT).begin)));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::ACTORLINEAGE,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<ActorLineageImpl>(SpecialKeySpace::getModuleRange(SpecialKeySpace::MODULE::ACTORLINEAGE)));
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::ACTOR_PROFILER_CONF,
		                              SpecialKeySpace::IMPLTYPE::READWRITE,
		                              std::make_unique<ActorProfilerConf>(SpecialKeySpace::getModuleRange(
		                                  SpecialKeySpace::MODULE::ACTOR_PROFILER_CONF)));
	}
	if (apiVersionAtLeast(630)) {
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::TRANSACTION,
		                              SpecialKeySpace::IMPLTYPE::READONLY,
		                              std::make_unique<ConflictingKeysImpl>(conflictingKeysRange));
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::TRANSACTION,
		                              SpecialKeySpace::IMPLTYPE::READONLY,
		                              std::make_unique<ReadConflictRangeImpl>(readConflictRangeKeysRange));
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::TRANSACTION,
		                              SpecialKeySpace::IMPLTYPE::READONLY,
		                              std::make_unique<WriteConflictRangeImpl>(writeConflictRangeKeysRange));
		registerSpecialKeySpaceModule(SpecialKeySpace::MODULE::METRICS,
		                              SpecialKeySpace::IMPLTYPE::READONLY,
		                              std::make_unique<DDStatsRangeImpl>(ddStatsRange));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::METRICS,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<HealthMetricsRangeImpl>(KeyRangeRef(LiteralStringRef("\xff\xff/metrics/health/"),
		                                                         LiteralStringRef("\xff\xff/metrics/health0"))));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::WORKERINTERFACE,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<WorkerInterfacesSpecialKeyImpl>(KeyRangeRef(
		        LiteralStringRef("\xff\xff/worker_interfaces/"), LiteralStringRef("\xff\xff/worker_interfaces0"))));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::STATUSJSON,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<SingleSpecialKeyImpl>(LiteralStringRef("\xff\xff/status/json"),
		                                           [](ReadYourWritesTransaction* ryw) -> Future<Optional<Value>> {
			                                           if (ryw->getDatabase().getPtr() &&
			                                               ryw->getDatabase()->getConnectionRecord()) {
				                                           ++ryw->getDatabase()->transactionStatusRequests;
				                                           return getJSON(ryw->getDatabase());
			                                           } else {
				                                           return Optional<Value>();
			                                           }
		                                           }));
		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::CLUSTERFILEPATH,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<SingleSpecialKeyImpl>(
		        LiteralStringRef("\xff\xff/cluster_file_path"),
		        [](ReadYourWritesTransaction* ryw) -> Future<Optional<Value>> {
			        try {
				        if (ryw->getDatabase().getPtr() && ryw->getDatabase()->getConnectionRecord()) {
					        Optional<Value> output =
					            StringRef(ryw->getDatabase()->getConnectionRecord()->getLocation());
					        return output;
				        }
			        } catch (Error& e) {
				        return e;
			        }
			        return Optional<Value>();
		        }));

		registerSpecialKeySpaceModule(
		    SpecialKeySpace::MODULE::CONNECTIONSTRING,
		    SpecialKeySpace::IMPLTYPE::READONLY,
		    std::make_unique<SingleSpecialKeyImpl>(
		        LiteralStringRef("\xff\xff/connection_string"),
		        [](ReadYourWritesTransaction* ryw) -> Future<Optional<Value>> {
			        try {
				        if (ryw->getDatabase().getPtr() && ryw->getDatabase()->getConnectionRecord()) {
					        Reference<IClusterConnectionRecord> f = ryw->getDatabase()->getConnectionRecord();
					        Optional<Value> output = StringRef(f->getConnectionString().toString());
					        return output;
				        }
			        } catch (Error& e) {
				        return e;
			        }
			        return Optional<Value>();
		        }));
	}
	throttleExpirer = recurring([this]() { expireThrottles(); }, CLIENT_KNOBS->TAG_THROTTLE_EXPIRATION_INTERVAL);

	if (BUGGIFY) {
		DatabaseContext::debugUseTags = true;
	}
}

DatabaseContext::DatabaseContext(const Error& err)
  : deferredError(err), internal(IsInternal::False), cc("TransactionMetrics"),
    transactionReadVersions("ReadVersions", cc), transactionReadVersionsThrottled("ReadVersionsThrottled", cc),
    transactionReadVersionsCompleted("ReadVersionsCompleted", cc),
    transactionReadVersionBatches("ReadVersionBatches", cc),
    transactionBatchReadVersions("BatchPriorityReadVersions", cc),
    transactionDefaultReadVersions("DefaultPriorityReadVersions", cc),
    transactionImmediateReadVersions("ImmediatePriorityReadVersions", cc),
    transactionBatchReadVersionsCompleted("BatchPriorityReadVersionsCompleted", cc),
    transactionDefaultReadVersionsCompleted("DefaultPriorityReadVersionsCompleted", cc),
    transactionImmediateReadVersionsCompleted("ImmediatePriorityReadVersionsCompleted", cc),
    transactionLogicalReads("LogicalUncachedReads", cc), transactionPhysicalReads("PhysicalReadRequests", cc),
    transactionPhysicalReadsCompleted("PhysicalReadRequestsCompleted", cc),
    transactionGetKeyRequests("GetKeyRequests", cc), transactionGetValueRequests("GetValueRequests", cc),
    transactionGetRangeRequests("GetRangeRequests", cc),
    transactionGetMappedRangeRequests("GetMappedRangeRequests", cc),
    transactionGetRangeStreamRequests("GetRangeStreamRequests", cc), transactionWatchRequests("WatchRequests", cc),
    transactionGetAddressesForKeyRequests("GetAddressesForKeyRequests", cc), transactionBytesRead("BytesRead", cc),
    transactionKeysRead("KeysRead", cc), transactionMetadataVersionReads("MetadataVersionReads", cc),
    transactionCommittedMutations("CommittedMutations", cc),
    transactionCommittedMutationBytes("CommittedMutationBytes", cc), transactionSetMutations("SetMutations", cc),
    transactionClearMutations("ClearMutations", cc), transactionAtomicMutations("AtomicMutations", cc),
    transactionsCommitStarted("CommitStarted", cc), transactionsCommitCompleted("CommitCompleted", cc),
    transactionKeyServerLocationRequests("KeyServerLocationRequests", cc),
    transactionKeyServerLocationRequestsCompleted("KeyServerLocationRequestsCompleted", cc),
    transactionStatusRequests("StatusRequests", cc), transactionsTooOld("TooOld", cc),
    transactionsFutureVersions("FutureVersions", cc), transactionsNotCommitted("NotCommitted", cc),
    transactionsMaybeCommitted("MaybeCommitted", cc), transactionsResourceConstrained("ResourceConstrained", cc),
    transactionsProcessBehind("ProcessBehind", cc), transactionsThrottled("Throttled", cc),
    transactionsExpensiveClearCostEstCount("ExpensiveClearCostEstCount", cc),
    transactionGrvFullBatches("NumGrvFullBatches", cc), transactionGrvTimedOutBatches("NumGrvTimedOutBatches", cc),
    transactionCommitVersionNotFoundForSS("CommitVersionNotFoundForSS", cc), latencies(1000), readLatencies(1000),
    commitLatencies(1000), GRVLatencies(1000), mutationsPerCommit(1000), bytesPerCommit(1000), bgLatencies(1000),
    bgGranulesPerRequest(1000), transactionTracingSample(false),
    smoothMidShardSize(CLIENT_KNOBS->SHARD_STAT_SMOOTH_AMOUNT),
    connectToDatabaseEventCacheHolder(format("ConnectToDatabase/%s", dbId.toString().c_str())) {}

// Static constructor used by server processes to create a DatabaseContext
// For internal (fdbserver) use only
Database DatabaseContext::create(Reference<AsyncVar<ClientDBInfo>> clientInfo,
                                 Future<Void> clientInfoMonitor,
                                 LocalityData clientLocality,
                                 EnableLocalityLoadBalance enableLocalityLoadBalance,
                                 TaskPriority taskID,
                                 LockAware lockAware,
                                 int apiVersion,
                                 IsSwitchable switchable) {
	return Database(new DatabaseContext(Reference<AsyncVar<Reference<IClusterConnectionRecord>>>(),
	                                    clientInfo,
	                                    makeReference<AsyncVar<Optional<ClientLeaderRegInterface>>>(),
	                                    clientInfoMonitor,
	                                    taskID,
	                                    clientLocality,
	                                    enableLocalityLoadBalance,
	                                    lockAware,
	                                    IsInternal::True,
	                                    apiVersion,
	                                    switchable));
}

DatabaseContext::~DatabaseContext() {
	cacheListMonitor.cancel();
	clientDBInfoMonitor.cancel();
	monitorTssInfoChange.cancel();
	tssMismatchHandler.cancel();
	if (grvUpdateHandler.isValid()) {
		grvUpdateHandler.cancel();
	}
	if (sharedStatePtr) {
		sharedStatePtr->delRef(sharedStatePtr);
	}
	for (auto it = server_interf.begin(); it != server_interf.end(); it = server_interf.erase(it))
		it->second->notifyContextDestroyed();
	ASSERT_ABORT(server_interf.empty());
	locationCache.insert(allKeys, Reference<LocationInfo>());

	TraceEvent("DatabaseContextDestructed", dbId).backtrace();
}

Optional<KeyRangeLocationInfo> DatabaseContext::getCachedLocation(const Optional<TenantName>& tenantName,
                                                                  const KeyRef& key,
                                                                  Reverse isBackward) {
	TenantMapEntry tenantEntry;
	Arena arena;
	KeyRef resolvedKey = key;

	if (tenantName.present()) {
		auto itr = tenantCache.find(tenantName.get());
		if (itr != tenantCache.end()) {
			tenantEntry = itr->second;
			resolvedKey = resolvedKey.withPrefix(tenantEntry.prefix, arena);
		} else {
			return Optional<KeyRangeLocationInfo>();
		}
	}

	auto range =
	    isBackward ? locationCache.rangeContainingKeyBefore(resolvedKey) : locationCache.rangeContaining(resolvedKey);
	if (range->value()) {
		return KeyRangeLocationInfo(tenantEntry, toRelativeRange(range->range(), tenantEntry.prefix), range->value());
	}

	return Optional<KeyRangeLocationInfo>();
}

bool DatabaseContext::getCachedLocations(const Optional<TenantName>& tenantName,
                                         const KeyRangeRef& range,
                                         std::vector<KeyRangeLocationInfo>& result,
                                         int limit,
                                         Reverse reverse) {
	result.clear();

	TenantMapEntry tenantEntry;
	Arena arena;
	KeyRangeRef resolvedRange = range;

	if (tenantName.present()) {
		auto itr = tenantCache.find(tenantName.get());
		if (itr != tenantCache.end()) {
			tenantEntry = itr->second;
			resolvedRange = resolvedRange.withPrefix(tenantEntry.prefix, arena);
		} else {
			return false;
		}
	}

	auto begin = locationCache.rangeContaining(resolvedRange.begin);
	auto end = locationCache.rangeContainingKeyBefore(resolvedRange.end);

	loop {
		auto r = reverse ? end : begin;
		if (!r->value()) {
			TEST(result.size()); // had some but not all cached locations
			result.clear();
			return false;
		}
		result.emplace_back(tenantEntry, toRelativeRange(r->range() & resolvedRange, tenantEntry.prefix), r->value());
		if (result.size() == limit || begin == end) {
			break;
		}

		if (reverse)
			--end;
		else
			++begin;
	}

	return true;
}

void DatabaseContext::cacheTenant(const TenantName& tenant, const TenantMapEntry& tenantEntry) {
	if (tenantCacheSize > 0) {
		// Naive cache eviction just erases the entire cache when it gets full.
		// We don't expect a single client to fill the tenant cache typically, so this should work reasonably well.
		if (tenantCache.size() > tenantCacheSize) {
			tenantCache.clear();
		}

		tenantCache[tenant] = tenantEntry;
	}
}

Reference<LocationInfo> DatabaseContext::setCachedLocation(const Optional<TenantName>& tenant,
                                                           const TenantMapEntry& tenantEntry,
                                                           const KeyRangeRef& absoluteKeys,
                                                           const std::vector<StorageServerInterface>& servers) {
	if (tenant.present()) {
		cacheTenant(tenant.get(), tenantEntry);
	}

	std::vector<Reference<ReferencedInterface<StorageServerInterface>>> serverRefs;
	serverRefs.reserve(servers.size());
	for (const auto& interf : servers) {
		serverRefs.push_back(StorageServerInfo::getInterface(this, interf, clientLocality));
	}

	int maxEvictionAttempts = 100, attempts = 0;
	auto loc = makeReference<LocationInfo>(serverRefs);
	while (locationCache.size() > locationCacheSize && attempts < maxEvictionAttempts) {
		TEST(true); // NativeAPI storage server locationCache entry evicted
		attempts++;
		auto r = locationCache.randomRange();
		Key begin = r.begin(), end = r.end(); // insert invalidates r, so can't be passed a mere reference into it
		locationCache.insert(KeyRangeRef(begin, end), Reference<LocationInfo>());
	}
	locationCache.insert(absoluteKeys, loc);
	return loc;
}

void DatabaseContext::invalidateCachedTenant(const TenantNameRef& tenant) {
	tenantCache.erase(tenant);
}

void DatabaseContext::invalidateCache(const KeyRef& tenantPrefix, const KeyRef& key, Reverse isBackward) {
	Arena arena;
	KeyRef resolvedKey = key;
	if (!tenantPrefix.empty()) {
		resolvedKey = resolvedKey.withPrefix(tenantPrefix, arena);
	}

	if (isBackward) {
		locationCache.rangeContainingKeyBefore(resolvedKey)->value() = Reference<LocationInfo>();
	} else {
		locationCache.rangeContaining(resolvedKey)->value() = Reference<LocationInfo>();
	}
}

void DatabaseContext::invalidateCache(const KeyRef& tenantPrefix, const KeyRangeRef& keys) {
	Arena arena;
	KeyRangeRef resolvedKeys = keys;
	if (!tenantPrefix.empty()) {
		resolvedKeys = resolvedKeys.withPrefix(tenantPrefix, arena);
	}

	auto rs = locationCache.intersectingRanges(resolvedKeys);
	Key begin = rs.begin().begin(),
	    end = rs.end().begin(); // insert invalidates rs, so can't be passed a mere reference into it
	locationCache.insert(KeyRangeRef(begin, end), Reference<LocationInfo>());
}

void DatabaseContext::setFailedEndpointOnHealthyServer(const Endpoint& endpoint) {
	if (failedEndpointsOnHealthyServersInfo.find(endpoint) == failedEndpointsOnHealthyServersInfo.end()) {
		failedEndpointsOnHealthyServersInfo[endpoint] =
		    EndpointFailureInfo{ .startTime = now(), .lastRefreshTime = now() };
	}
}

void DatabaseContext::updateFailedEndpointRefreshTime(const Endpoint& endpoint) {
	if (failedEndpointsOnHealthyServersInfo.find(endpoint) == failedEndpointsOnHealthyServersInfo.end()) {
		// The endpoint is not failed. Nothing to update.
		return;
	}
	failedEndpointsOnHealthyServersInfo[endpoint].lastRefreshTime = now();
}

Optional<EndpointFailureInfo> DatabaseContext::getEndpointFailureInfo(const Endpoint& endpoint) {
	if (failedEndpointsOnHealthyServersInfo.find(endpoint) == failedEndpointsOnHealthyServersInfo.end()) {
		return Optional<EndpointFailureInfo>();
	}
	return failedEndpointsOnHealthyServersInfo[endpoint];
}

void DatabaseContext::clearFailedEndpointOnHealthyServer(const Endpoint& endpoint) {
	failedEndpointsOnHealthyServersInfo.erase(endpoint);
}

Future<Void> DatabaseContext::onProxiesChanged() {
	backoffDelay = 0.0;
	return this->proxiesChangeTrigger.onTrigger();
}

bool DatabaseContext::sampleReadTags() const {
	double sampleRate = globalConfig->get(transactionTagSampleRate, CLIENT_KNOBS->READ_TAG_SAMPLE_RATE);
	return sampleRate > 0 && deterministicRandom()->random01() <= sampleRate;
}

bool DatabaseContext::sampleOnCost(uint64_t cost) const {
	double sampleCost = globalConfig->get<double>(transactionTagSampleCost, CLIENT_KNOBS->COMMIT_SAMPLE_COST);
	if (sampleCost <= 0)
		return false;
	return deterministicRandom()->random01() <= (double)cost / sampleCost;
}

int64_t extractIntOption(Optional<StringRef> value, int64_t minValue, int64_t maxValue) {
	validateOptionValuePresent(value);
	if (value.get().size() != 8) {
		throw invalid_option_value();
	}

	int64_t passed = *((int64_t*)(value.get().begin()));
	if (passed > maxValue || passed < minValue) {
		throw invalid_option_value();
	}

	return passed;
}

uint64_t extractHexOption(StringRef value) {
	char* end;
	uint64_t id = strtoull(value.toString().c_str(), &end, 16);
	if (*end)
		throw invalid_option_value();
	return id;
}

void DatabaseContext::setOption(FDBDatabaseOptions::Option option, Optional<StringRef> value) {
	int defaultFor = FDBDatabaseOptions::optionInfo.getMustExist(option).defaultFor;
	if (defaultFor >= 0) {
		ASSERT(FDBTransactionOptions::optionInfo.find((FDBTransactionOptions::Option)defaultFor) !=
		       FDBTransactionOptions::optionInfo.end());
		transactionDefaults.addOption((FDBTransactionOptions::Option)defaultFor, value.castTo<Standalone<StringRef>>());
	} else {
		switch (option) {
		case FDBDatabaseOptions::LOCATION_CACHE_SIZE:
			locationCacheSize = (int)extractIntOption(value, 0, std::numeric_limits<int>::max());
			break;
		case FDBDatabaseOptions::MACHINE_ID:
			clientLocality =
			    LocalityData(clientLocality.processId(),
			                 value.present() ? Standalone<StringRef>(value.get()) : Optional<Standalone<StringRef>>(),
			                 clientLocality.machineId(),
			                 clientLocality.dcId());
			if (clientInfo->get().commitProxies.size())
				commitProxies = makeReference<CommitProxyInfo>(clientInfo->get().commitProxies);
			if (clientInfo->get().grvProxies.size())
				grvProxies = makeReference<GrvProxyInfo>(clientInfo->get().grvProxies, BalanceOnRequests::True);
			server_interf.clear();
			locationCache.insert(allKeys, Reference<LocationInfo>());
			break;
		case FDBDatabaseOptions::MAX_WATCHES:
			maxOutstandingWatches = (int)extractIntOption(value, 0, CLIENT_KNOBS->ABSOLUTE_MAX_WATCHES);
			break;
		case FDBDatabaseOptions::DATACENTER_ID:
			clientLocality =
			    LocalityData(clientLocality.processId(),
			                 clientLocality.zoneId(),
			                 clientLocality.machineId(),
			                 value.present() ? Standalone<StringRef>(value.get()) : Optional<Standalone<StringRef>>());
			if (clientInfo->get().commitProxies.size())
				commitProxies = makeReference<CommitProxyInfo>(clientInfo->get().commitProxies);
			if (clientInfo->get().grvProxies.size())
				grvProxies = makeReference<GrvProxyInfo>(clientInfo->get().grvProxies, BalanceOnRequests::True);
			server_interf.clear();
			locationCache.insert(allKeys, Reference<LocationInfo>());
			break;
		case FDBDatabaseOptions::SNAPSHOT_RYW_ENABLE:
			validateOptionValueNotPresent(value);
			snapshotRywEnabled++;
			break;
		case FDBDatabaseOptions::SNAPSHOT_RYW_DISABLE:
			validateOptionValueNotPresent(value);
			snapshotRywEnabled--;
			break;
		case FDBDatabaseOptions::USE_CONFIG_DATABASE:
			validateOptionValueNotPresent(value);
			useConfigDatabase = true;
			break;
		case FDBDatabaseOptions::TEST_CAUSAL_READ_RISKY:
			verifyCausalReadsProp = double(extractIntOption(value, 0, 100)) / 100.0;
			break;
		default:
			break;
		}
	}
}

void DatabaseContext::addWatch() {
	if (outstandingWatches >= maxOutstandingWatches)
		throw too_many_watches();

	++outstandingWatches;
}

void DatabaseContext::removeWatch() {
	--outstandingWatches;
	ASSERT(outstandingWatches >= 0);
}

Future<Void> DatabaseContext::onConnected() {
	return connected;
}

															#line 8553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via switchConnectionRecordImpl()
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SwitchConnectionRecordImplActor>
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SwitchConnectionRecordImplActorState {
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SwitchConnectionRecordImplActorState(Reference<IClusterConnectionRecord> const& connRecord,DatabaseContext* const& self) 
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : connRecord(connRecord),
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   self(self)
															#line 8569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this));

	}
	~SwitchConnectionRecordImplActorState() 
	{
		fdb_probe_actor_destroy("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 2121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("SwitchConnectionRecord") .detail("ClusterFile", connRecord->toString()) .detail("ConnectionString", connRecord->getConnectionString().toString());
															#line 2126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->commitProxies.clear();
															#line 2127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->grvProxies.clear();
															#line 2128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->minAcceptableReadVersion = std::numeric_limits<Version>::max();
															#line 2129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->tenantCache.clear();
															#line 2130 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->invalidateCache(Key(), allKeys);
															#line 2132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->ssVersionVectorCache.clear();
															#line 2134 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto clearedClientInfo = self->clientInfo->get();
															#line 2135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			clearedClientInfo.commitProxies.clear();
															#line 2136 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			clearedClientInfo.grvProxies.clear();
															#line 2137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			clearedClientInfo.id = deterministicRandom()->randomUniqueID();
															#line 2138 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->clientInfo->set(clearedClientInfo);
															#line 2139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->connectionRecord->set(connRecord);
															#line 2141 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			db = Database(Reference<DatabaseContext>::addRef(self));
															#line 2142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr = Transaction(db);
															#line 2143 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 8616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SwitchConnectionRecordImplActorState();
		static_cast<SwitchConnectionRecordImplActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 2144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr.setOption(FDBTransactionOptions::READ_LOCK_AWARE);
															#line 8646 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 2146 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("SwitchConnectionRecordAttemptingGRV").log();
															#line 2147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Version> __when_expr_0 = tr.getReadVersion();
															#line 2147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 8654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state = 1;
															#line 2147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SwitchConnectionRecordImplActor, 0, Version >*>(static_cast<SwitchConnectionRecordImplActor*>(this)));
															#line 8659 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2155 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("SwitchConnectionRecordError").detail("Error", e.what());
															#line 2156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = tr.onError(e);
															#line 2156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 8685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_1.get(), loopDepth); };
			static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state = 2;
															#line 2156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SwitchConnectionRecordImplActor, 1, Void >*>(static_cast<SwitchConnectionRecordImplActor*>(this)));
															#line 8690 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Version const& v,int loopDepth) 
	{
															#line 2148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("SwitchConnectionRecordGotRV") .detail("ReadVersion", v) .detail("MinAcceptableReadVersion", self->minAcceptableReadVersion);
															#line 2151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(self->minAcceptableReadVersion != std::numeric_limits<Version>::max());
															#line 2152 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->connectionFileChangedTrigger.trigger();
															#line 2153 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SwitchConnectionRecordImplActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SwitchConnectionRecordImplActorState(); static_cast<SwitchConnectionRecordImplActor*>(this)->destroy(); return 0; }
															#line 8711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SwitchConnectionRecordImplActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SwitchConnectionRecordImplActorState();
		static_cast<SwitchConnectionRecordImplActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Version && v,int loopDepth) 
	{
															#line 2148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("SwitchConnectionRecordGotRV") .detail("ReadVersion", v) .detail("MinAcceptableReadVersion", self->minAcceptableReadVersion);
															#line 2151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(self->minAcceptableReadVersion != std::numeric_limits<Version>::max());
															#line 2152 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->connectionFileChangedTrigger.trigger();
															#line 2153 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SwitchConnectionRecordImplActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SwitchConnectionRecordImplActorState(); static_cast<SwitchConnectionRecordImplActor*>(this)->destroy(); return 0; }
															#line 8729 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SwitchConnectionRecordImplActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SwitchConnectionRecordImplActorState();
		static_cast<SwitchConnectionRecordImplActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Version const& v,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(v, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Version && v,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state > 0) static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state = 0;
		static_cast<SwitchConnectionRecordImplActor*>(this)->ActorCallback< SwitchConnectionRecordImplActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< SwitchConnectionRecordImplActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SwitchConnectionRecordImplActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SwitchConnectionRecordImplActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state > 0) static_cast<SwitchConnectionRecordImplActor*>(this)->actor_wait_state = 0;
		static_cast<SwitchConnectionRecordImplActor*>(this)->ActorCallback< SwitchConnectionRecordImplActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SwitchConnectionRecordImplActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SwitchConnectionRecordImplActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SwitchConnectionRecordImplActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<IClusterConnectionRecord> connRecord;
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* self;
															#line 2141 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database db;
															#line 2142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 8883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via switchConnectionRecordImpl()
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SwitchConnectionRecordImplActor final : public Actor<Void>, public ActorCallback< SwitchConnectionRecordImplActor, 0, Version >, public ActorCallback< SwitchConnectionRecordImplActor, 1, Void >, public FastAllocated<SwitchConnectionRecordImplActor>, public SwitchConnectionRecordImplActorState<SwitchConnectionRecordImplActor> {
															#line 8888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SwitchConnectionRecordImplActor>::operator new;
	using FastAllocated<SwitchConnectionRecordImplActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SwitchConnectionRecordImplActor, 0, Version >;
friend struct ActorCallback< SwitchConnectionRecordImplActor, 1, Void >;
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SwitchConnectionRecordImplActor(Reference<IClusterConnectionRecord> const& connRecord,DatabaseContext* const& self) 
															#line 8900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   SwitchConnectionRecordImplActorState<SwitchConnectionRecordImplActor>(connRecord, self)
	{
		fdb_probe_actor_enter("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("switchConnectionRecordImpl");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("switchConnectionRecordImpl", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SwitchConnectionRecordImplActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SwitchConnectionRecordImplActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> switchConnectionRecordImpl( Reference<IClusterConnectionRecord> const& connRecord, DatabaseContext* const& self ) {
															#line 2118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new SwitchConnectionRecordImplActor(connRecord, self));
															#line 8929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 2160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Reference<IClusterConnectionRecord> DatabaseContext::getConnectionRecord() {
	if (connectionRecord) {
		return connectionRecord->get();
	}
	return Reference<IClusterConnectionRecord>();
}

Future<Void> DatabaseContext::switchConnectionRecord(Reference<IClusterConnectionRecord> standby) {
	ASSERT(switchable);
	return switchConnectionRecordImpl(standby, this);
}

Future<Void> DatabaseContext::connectionFileChanged() {
	return connectionFileChangedTrigger.onTrigger();
}

void DatabaseContext::expireThrottles() {
	for (auto& priorityItr : throttledTags) {
		for (auto tagItr = priorityItr.second.begin(); tagItr != priorityItr.second.end();) {
			if (tagItr->second.expired()) {
				TEST(true); // Expiring client throttle
				tagItr = priorityItr.second.erase(tagItr);
			} else {
				++tagItr;
			}
		}
	}
}

extern IPAddress determinePublicIPAutomatically(ClusterConnectionString& ccs);

// Creates a database object that represents a connection to a cluster
// This constructor uses a preallocated DatabaseContext that may have been created
// on another thread
Database Database::createDatabase(Reference<IClusterConnectionRecord> connRecord,
                                  int apiVersion,
                                  IsInternal internal,
                                  LocalityData const& clientLocality,
                                  DatabaseContext* preallocatedDb) {
	if (!g_network)
		throw network_not_setup();

	ASSERT(TraceEvent::isNetworkThread());

	platform::ImageInfo imageInfo = platform::getImageInfo();

	if (connRecord) {
		if (networkOptions.traceDirectory.present() && !traceFileIsOpen()) {
			g_network->initMetrics();
			FlowTransport::transport().initMetrics();
			initTraceEventMetrics();

			auto publicIP = determinePublicIPAutomatically(connRecord->getConnectionString());
			selectTraceFormatter(networkOptions.traceFormat);
			selectTraceClockSource(networkOptions.traceClockSource);
			addUniversalTraceField("ClientDescription",
			                       format("%s-%s-%" PRIu64,
			                              networkOptions.primaryClient ? "primary" : "external",
			                              FDB_VT_VERSION,
			                              getTraceThreadId()));

			openTraceFile(NetworkAddress(publicIP, ::getpid()),
			              networkOptions.traceRollSize,
			              networkOptions.traceMaxLogsSize,
			              networkOptions.traceDirectory.get(),
			              "trace",
			              networkOptions.traceLogGroup,
			              networkOptions.traceFileIdentifier,
			              networkOptions.tracePartialFileSuffix);

			TraceEvent("ClientStart")
			    .detail("SourceVersion", getSourceVersion())
			    .detail("Version", FDB_VT_VERSION)
			    .detail("PackageName", FDB_VT_PACKAGE_NAME)
			    .detailf("ActualTime", "%lld", DEBUG_DETERMINISM ? 0 : time(nullptr))
			    .detail("ApiVersion", apiVersion)
			    .detail("ClientLibrary", imageInfo.fileName)
			    .detailf("ImageOffset", "%p", imageInfo.offset)
			    .detail("Primary", networkOptions.primaryClient)
			    .trackLatest("ClientStart");

			initializeSystemMonitorMachineState(SystemMonitorMachineState(IPAddress(publicIP)));

			systemMonitor();
			uncancellable(recurring(&systemMonitor, CLIENT_KNOBS->SYSTEM_MONITOR_INTERVAL, TaskPriority::FlushTrace));
		}
	}

	g_network->initTLS();

	auto clientInfo = makeReference<AsyncVar<ClientDBInfo>>();
	auto coordinator = makeReference<AsyncVar<Optional<ClientLeaderRegInterface>>>();
	auto connectionRecord = makeReference<AsyncVar<Reference<IClusterConnectionRecord>>>();
	connectionRecord->set(connRecord);
	Future<Void> clientInfoMonitor = monitorProxies(connectionRecord,
	                                                clientInfo,
	                                                coordinator,
	                                                networkOptions.supportedVersions,
	                                                StringRef(networkOptions.traceLogGroup),
	                                                internal);

	DatabaseContext* db;
	if (preallocatedDb) {
		db = new (preallocatedDb) DatabaseContext(connectionRecord,
		                                          clientInfo,
		                                          coordinator,
		                                          clientInfoMonitor,
		                                          TaskPriority::DefaultEndpoint,
		                                          clientLocality,
		                                          EnableLocalityLoadBalance::True,
		                                          LockAware::False,
		                                          internal,
		                                          apiVersion,
		                                          IsSwitchable::True);
	} else {
		db = new DatabaseContext(connectionRecord,
		                         clientInfo,
		                         coordinator,
		                         clientInfoMonitor,
		                         TaskPriority::DefaultEndpoint,
		                         clientLocality,
		                         EnableLocalityLoadBalance::True,
		                         LockAware::False,
		                         internal,
		                         apiVersion,
		                         IsSwitchable::True);
	}

	auto database = Database(db);
	database->globalConfig->init(Reference<AsyncVar<ClientDBInfo> const>(clientInfo),
	                             std::addressof(clientInfo->get()));
	database->globalConfig->trigger(samplingFrequency, samplingProfilerUpdateFrequency);
	database->globalConfig->trigger(samplingWindow, samplingProfilerUpdateWindow);

	TraceEvent("ConnectToDatabase", database->dbId)
	    .detail("Version", FDB_VT_VERSION)
	    .detail("ClusterFile", connRecord ? connRecord->toString() : "None")
	    .detail("ConnectionString", connRecord ? connRecord->getConnectionString().toString() : "None")
	    .detail("ClientLibrary", imageInfo.fileName)
	    .detail("Primary", networkOptions.primaryClient)
	    .detail("Internal", internal)
	    .trackLatest(database->connectToDatabaseEventCacheHolder.trackingKey);

	return database;
}

Database Database::createDatabase(std::string connFileName,
                                  int apiVersion,
                                  IsInternal internal,
                                  LocalityData const& clientLocality) {
	Reference<IClusterConnectionRecord> rccr = Reference<IClusterConnectionRecord>(
	    new ClusterConnectionFile(ClusterConnectionFile::lookupClusterFileName(connFileName).first));
	return Database::createDatabase(rccr, apiVersion, internal, clientLocality);
}

Reference<WatchMetadata> DatabaseContext::getWatchMetadata(int64_t tenantId, KeyRef key) const {
	const auto it = watchMap.find(std::make_pair(tenantId, key));
	if (it == watchMap.end())
		return Reference<WatchMetadata>();
	return it->second;
}

void DatabaseContext::setWatchMetadata(Reference<WatchMetadata> metadata) {
	watchMap[std::make_pair(metadata->parameters->tenant.tenantId, metadata->parameters->key)] = metadata;
}

void DatabaseContext::deleteWatchMetadata(int64_t tenantId, KeyRef key) {
	watchMap.erase(std::make_pair(tenantId, key));
}

void DatabaseContext::clearWatchMetadata() {
	watchMap.clear();
}

const UniqueOrderedOptionList<FDBTransactionOptions>& Database::getTransactionDefaults() const {
	ASSERT(db);
	return db->transactionDefaults;
}

void setNetworkOption(FDBNetworkOptions::Option option, Optional<StringRef> value) {
	std::regex identifierRegex("^[a-zA-Z0-9_]*$");
	switch (option) {
	// SOMEDAY: If the network is already started, should these five throw an error?
	case FDBNetworkOptions::TRACE_ENABLE:
		networkOptions.traceDirectory = value.present() ? value.get().toString() : "";
		break;
	case FDBNetworkOptions::TRACE_ROLL_SIZE:
		validateOptionValuePresent(value);
		networkOptions.traceRollSize = extractIntOption(value, 0, std::numeric_limits<int64_t>::max());
		break;
	case FDBNetworkOptions::TRACE_MAX_LOGS_SIZE:
		validateOptionValuePresent(value);
		networkOptions.traceMaxLogsSize = extractIntOption(value, 0, std::numeric_limits<int64_t>::max());
		break;
	case FDBNetworkOptions::TRACE_FORMAT:
		validateOptionValuePresent(value);
		networkOptions.traceFormat = value.get().toString();
		if (!validateTraceFormat(networkOptions.traceFormat)) {
			fprintf(stderr, "Unrecognized trace format: `%s'\n", networkOptions.traceFormat.c_str());
			throw invalid_option_value();
		}
		break;
	case FDBNetworkOptions::TRACE_FILE_IDENTIFIER:
		validateOptionValuePresent(value);
		networkOptions.traceFileIdentifier = value.get().toString();
		if (networkOptions.traceFileIdentifier.length() > CLIENT_KNOBS->TRACE_LOG_FILE_IDENTIFIER_MAX_LENGTH) {
			fprintf(stderr, "Trace file identifier provided is too long.\n");
			throw invalid_option_value();
		} else if (!std::regex_match(networkOptions.traceFileIdentifier, identifierRegex)) {
			fprintf(stderr, "Trace file identifier should only contain alphanumerics and underscores.\n");
			throw invalid_option_value();
		}
		break;

	case FDBNetworkOptions::TRACE_LOG_GROUP:
		if (value.present()) {
			if (traceFileIsOpen()) {
				setTraceLogGroup(value.get().toString());
			} else {
				networkOptions.traceLogGroup = value.get().toString();
			}
		}
		break;
	case FDBNetworkOptions::TRACE_CLOCK_SOURCE:
		validateOptionValuePresent(value);
		networkOptions.traceClockSource = value.get().toString();
		if (!validateTraceClockSource(networkOptions.traceClockSource)) {
			fprintf(stderr, "Unrecognized trace clock source: `%s'\n", networkOptions.traceClockSource.c_str());
			throw invalid_option_value();
		}
		break;
	case FDBNetworkOptions::TRACE_PARTIAL_FILE_SUFFIX:
		validateOptionValuePresent(value);
		networkOptions.tracePartialFileSuffix = value.get().toString();
		break;
	case FDBNetworkOptions::KNOB: {
		validateOptionValuePresent(value);

		std::string optionValue = value.get().toString();
		TraceEvent("SetKnob").detail("KnobString", optionValue);

		size_t eq = optionValue.find_first_of('=');
		if (eq == optionValue.npos) {
			TraceEvent(SevWarnAlways, "InvalidKnobString").detail("KnobString", optionValue);
			throw invalid_option_value();
		}

		std::string knobName = optionValue.substr(0, eq);
		std::string knobValueString = optionValue.substr(eq + 1);

		try {
			auto knobValue = IKnobCollection::parseKnobValue(knobName, knobValueString, IKnobCollection::Type::CLIENT);
			if (g_network) {
				IKnobCollection::getMutableGlobalKnobCollection().setKnob(knobName, knobValue);
			} else {
				networkOptions.knobs[knobName] = knobValue;
			}
		} catch (Error& e) {
			TraceEvent(SevWarnAlways, "UnrecognizedKnob").detail("Knob", knobName.c_str());
			fprintf(stderr, "FoundationDB client ignoring unrecognized knob option '%s'\n", knobName.c_str());
		}
		break;
	}
	case FDBNetworkOptions::TLS_PLUGIN:
		validateOptionValuePresent(value);
		break;
	case FDBNetworkOptions::TLS_CERT_PATH:
		validateOptionValuePresent(value);
		tlsConfig.setCertificatePath(value.get().toString());
		break;
	case FDBNetworkOptions::TLS_CERT_BYTES: {
		validateOptionValuePresent(value);
		tlsConfig.setCertificateBytes(value.get().toString());
		break;
	}
	case FDBNetworkOptions::TLS_CA_PATH: {
		validateOptionValuePresent(value);
		tlsConfig.setCAPath(value.get().toString());
		break;
	}
	case FDBNetworkOptions::TLS_CA_BYTES: {
		validateOptionValuePresent(value);
		tlsConfig.setCABytes(value.get().toString());
		break;
	}
	case FDBNetworkOptions::TLS_PASSWORD:
		validateOptionValuePresent(value);
		tlsConfig.setPassword(value.get().toString());
		break;
	case FDBNetworkOptions::TLS_KEY_PATH:
		validateOptionValuePresent(value);
		tlsConfig.setKeyPath(value.get().toString());
		break;
	case FDBNetworkOptions::TLS_KEY_BYTES: {
		validateOptionValuePresent(value);
		tlsConfig.setKeyBytes(value.get().toString());
		break;
	}
	case FDBNetworkOptions::TLS_VERIFY_PEERS:
		validateOptionValuePresent(value);
		tlsConfig.clearVerifyPeers();
		tlsConfig.addVerifyPeers(value.get().toString());
		break;
	case FDBNetworkOptions::CLIENT_BUGGIFY_ENABLE:
		enableBuggify(true, BuggifyType::Client);
		break;
	case FDBNetworkOptions::CLIENT_BUGGIFY_DISABLE:
		enableBuggify(false, BuggifyType::Client);
		break;
	case FDBNetworkOptions::CLIENT_BUGGIFY_SECTION_ACTIVATED_PROBABILITY:
		validateOptionValuePresent(value);
		clearBuggifySections(BuggifyType::Client);
		P_BUGGIFIED_SECTION_ACTIVATED[int(BuggifyType::Client)] = double(extractIntOption(value, 0, 100)) / 100.0;
		break;
	case FDBNetworkOptions::CLIENT_BUGGIFY_SECTION_FIRED_PROBABILITY:
		validateOptionValuePresent(value);
		P_BUGGIFIED_SECTION_FIRES[int(BuggifyType::Client)] = double(extractIntOption(value, 0, 100)) / 100.0;
		break;
	case FDBNetworkOptions::DISABLE_CLIENT_STATISTICS_LOGGING:
		validateOptionValueNotPresent(value);
		networkOptions.logClientInfo = false;
		break;
	case FDBNetworkOptions::SUPPORTED_CLIENT_VERSIONS: {
		// The multi-version API should be providing us these guarantees
		ASSERT(g_network);
		ASSERT(value.present());

		Standalone<VectorRef<ClientVersionRef>> supportedVersions;
		std::vector<StringRef> supportedVersionsStrings = value.get().splitAny(LiteralStringRef(";"));
		for (StringRef versionString : supportedVersionsStrings) {
#ifdef ADDRESS_SANITIZER
			__lsan_disable();
#endif
			// LSAN reports that we leak this allocation in client
			// tests, but I cannot seem to figure out why. AFAICT
			// it's not actually leaking. If it is a leak, it's only a few bytes.
			supportedVersions.push_back_deep(supportedVersions.arena(), ClientVersionRef(versionString));
#ifdef ADDRESS_SANITIZER
			__lsan_enable();
#endif
		}

		ASSERT(supportedVersions.size() > 0);
		networkOptions.supportedVersions->set(supportedVersions);

		break;
	}
	case FDBNetworkOptions::ENABLE_RUN_LOOP_PROFILING: // Same as ENABLE_SLOW_TASK_PROFILING
		validateOptionValueNotPresent(value);
		networkOptions.runLoopProfilingEnabled = true;
		break;
	case FDBNetworkOptions::DISTRIBUTED_CLIENT_TRACER: {
		validateOptionValuePresent(value);
		std::string tracer = value.get().toString();
		if (tracer == "none" || tracer == "disabled") {
			openTracer(TracerType::DISABLED);
		} else if (tracer == "logfile" || tracer == "file" || tracer == "log_file") {
			openTracer(TracerType::LOG_FILE);
		} else if (tracer == "network_lossy") {
			openTracer(TracerType::NETWORK_LOSSY);
		} else {
			fprintf(stderr, "ERROR: Unknown or unsupported tracer: `%s'", tracer.c_str());
			throw invalid_option_value();
		}
		break;
	}
	case FDBNetworkOptions::EXTERNAL_CLIENT:
		networkOptions.primaryClient = false;
		break;
	default:
		break;
	}
}

// update the network busyness on a 1s cadence
															#line 9309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via monitorNetworkBusyness()
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class MonitorNetworkBusynessActor>
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MonitorNetworkBusynessActorState {
															#line 9316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MonitorNetworkBusynessActorState() 
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 2537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : prevTime(now())
															#line 9323 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this));

	}
	~MonitorNetworkBusynessActorState() 
	{
		fdb_probe_actor_destroy("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 9338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MonitorNetworkBusynessActorState();
		static_cast<MonitorNetworkBusynessActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 2539 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = delay(CLIENT_KNOBS->NETWORK_BUSYNESS_MONITOR_INTERVAL, TaskPriority::FlushTrace);
															#line 2539 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MonitorNetworkBusynessActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 9370 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<MonitorNetworkBusynessActor*>(this)->actor_wait_state = 1;
															#line 2539 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MonitorNetworkBusynessActor, 0, Void >*>(static_cast<MonitorNetworkBusynessActor*>(this)));
															#line 9375 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 2540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double elapsed = now() - prevTime;
															#line 2541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		prevTime = now();
															#line 2542 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		struct NetworkMetrics::PriorityStats& tracker = g_network->networkInfo.metrics.starvationTrackerNetworkBusyness;
															#line 2544 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tracker.active)
															#line 9390 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2545 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracker.duration += now() - tracker.windowedTimer;
															#line 2546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracker.maxDuration = std::max(tracker.maxDuration, now() - tracker.timer);
															#line 2547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracker.windowedTimer = now();
															#line 9398 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double busyFraction = std::min(elapsed, tracker.duration) / elapsed;
															#line 2558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double burstiness = 0;
															#line 2559 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD >= 0 && CLIENT_KNOBS->BUSYNESS_SPIKE_SATURATED_THRESHOLD >= CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD)
															#line 9406 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2561 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			burstiness = std::min(1.0, std::max(0.0, tracker.maxDuration - CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD) / std::max(1e-6, CLIENT_KNOBS->BUSYNESS_SPIKE_SATURATED_THRESHOLD - CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD));
															#line 9410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		g_network->networkInfo.metrics.networkBusyness = std::max(busyFraction, burstiness);
															#line 2570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tracker.duration = 0;
															#line 2571 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tracker.maxDuration = 0;
															#line 9418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 2540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double elapsed = now() - prevTime;
															#line 2541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		prevTime = now();
															#line 2542 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		struct NetworkMetrics::PriorityStats& tracker = g_network->networkInfo.metrics.starvationTrackerNetworkBusyness;
															#line 2544 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tracker.active)
															#line 9433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2545 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracker.duration += now() - tracker.windowedTimer;
															#line 2546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracker.maxDuration = std::max(tracker.maxDuration, now() - tracker.timer);
															#line 2547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tracker.windowedTimer = now();
															#line 9441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double busyFraction = std::min(elapsed, tracker.duration) / elapsed;
															#line 2558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double burstiness = 0;
															#line 2559 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD >= 0 && CLIENT_KNOBS->BUSYNESS_SPIKE_SATURATED_THRESHOLD >= CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD)
															#line 9449 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2561 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			burstiness = std::min(1.0, std::max(0.0, tracker.maxDuration - CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD) / std::max(1e-6, CLIENT_KNOBS->BUSYNESS_SPIKE_SATURATED_THRESHOLD - CLIENT_KNOBS->BUSYNESS_SPIKE_START_THRESHOLD));
															#line 9453 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		g_network->networkInfo.metrics.networkBusyness = std::max(busyFraction, burstiness);
															#line 2570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tracker.duration = 0;
															#line 2571 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tracker.maxDuration = 0;
															#line 9461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MonitorNetworkBusynessActor*>(this)->actor_wait_state > 0) static_cast<MonitorNetworkBusynessActor*>(this)->actor_wait_state = 0;
		static_cast<MonitorNetworkBusynessActor*>(this)->ActorCallback< MonitorNetworkBusynessActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MonitorNetworkBusynessActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MonitorNetworkBusynessActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MonitorNetworkBusynessActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double prevTime;
															#line 9531 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via monitorNetworkBusyness()
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MonitorNetworkBusynessActor final : public Actor<Void>, public ActorCallback< MonitorNetworkBusynessActor, 0, Void >, public FastAllocated<MonitorNetworkBusynessActor>, public MonitorNetworkBusynessActorState<MonitorNetworkBusynessActor> {
															#line 9536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<MonitorNetworkBusynessActor>::operator new;
	using FastAllocated<MonitorNetworkBusynessActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< MonitorNetworkBusynessActor, 0, Void >;
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MonitorNetworkBusynessActor() 
															#line 9547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   MonitorNetworkBusynessActorState<MonitorNetworkBusynessActor>()
	{
		fdb_probe_actor_enter("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("monitorNetworkBusyness");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("monitorNetworkBusyness", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MonitorNetworkBusynessActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> monitorNetworkBusyness(  ) {
															#line 2536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new MonitorNetworkBusynessActor());
															#line 9575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 2574 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

static void setupGlobalKnobs() {
	IKnobCollection::setGlobalKnobCollection(IKnobCollection::Type::CLIENT, Randomize::False, IsSimulated::False);
	for (const auto& [knobName, knobValue] : networkOptions.knobs) {
		IKnobCollection::getMutableGlobalKnobCollection().setKnob(knobName, knobValue);
	}
}

// Setup g_network and start monitoring for network busyness
void setupNetwork(uint64_t transportId, UseMetrics useMetrics) {
	if (g_network)
		throw network_already_setup();

	if (!networkOptions.logClientInfo.present())
		networkOptions.logClientInfo = true;

	setupGlobalKnobs();
	g_network = newNet2(tlsConfig, false, useMetrics || networkOptions.traceDirectory.present());
	g_network->addStopCallback(Net2FileSystem::stop);
	FlowTransport::createInstance(true, transportId, WLTOKEN_RESERVED_COUNT);
	Net2FileSystem::newFileSystem();

	uncancellable(monitorNetworkBusyness());
}

void runNetwork() {
	if (!g_network) {
		throw network_not_setup();
	}

	if (!g_network->checkRunnable()) {
		throw network_cannot_be_restarted();
	}

	if (networkOptions.traceDirectory.present() && networkOptions.runLoopProfilingEnabled) {
		setupRunLoopProfiler();
	}

	g_network->run();

	if (networkOptions.traceDirectory.present())
		systemMonitor();
}

void stopNetwork() {
	if (!g_network)
		throw network_not_setup();

	TraceEvent("ClientStopNetwork");
	g_network->stop();
	closeTraceFile();
}

void DatabaseContext::updateProxies() {
	if (proxiesLastChange == clientInfo->get().id)
		return;
	proxiesLastChange = clientInfo->get().id;
	commitProxies.clear();
	grvProxies.clear();
	ssVersionVectorCache.clear();
	bool commitProxyProvisional = false, grvProxyProvisional = false;
	if (clientInfo->get().commitProxies.size()) {
		commitProxies = makeReference<CommitProxyInfo>(clientInfo->get().commitProxies);
		commitProxyProvisional = clientInfo->get().commitProxies[0].provisional;
	}
	if (clientInfo->get().grvProxies.size()) {
		grvProxies = makeReference<GrvProxyInfo>(clientInfo->get().grvProxies, BalanceOnRequests::True);
		grvProxyProvisional = clientInfo->get().grvProxies[0].provisional;
	}
	if (clientInfo->get().commitProxies.size() && clientInfo->get().grvProxies.size()) {
		ASSERT(commitProxyProvisional == grvProxyProvisional);
		proxyProvisional = commitProxyProvisional;
	}
}

Reference<CommitProxyInfo> DatabaseContext::getCommitProxies(UseProvisionalProxies useProvisionalProxies) {
	updateProxies();
	if (proxyProvisional && !useProvisionalProxies) {
		return Reference<CommitProxyInfo>();
	}
	return commitProxies;
}

Reference<GrvProxyInfo> DatabaseContext::getGrvProxies(UseProvisionalProxies useProvisionalProxies) {
	updateProxies();
	if (proxyProvisional && !useProvisionalProxies) {
		return Reference<GrvProxyInfo>();
	}
	return grvProxies;
}

bool DatabaseContext::isCurrentGrvProxy(UID proxyId) const {
	for (const auto& proxy : clientInfo->get().grvProxies) {
		if (proxy.id() == proxyId)
			return true;
	}
	TEST(true); // stale GRV proxy detected
	return false;
}

// Actor which will wait until the MultiInterface<CommitProxyInterface> returned by the DatabaseContext cx is not
// nullptr
															#line 9681 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getCommitProxiesFuture()
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetCommitProxiesFutureActor>
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCommitProxiesFutureActorState {
															#line 9688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCommitProxiesFutureActorState(DatabaseContext* const& cx,UseProvisionalProxies const& useProvisionalProxies) 
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useProvisionalProxies(useProvisionalProxies)
															#line 9697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this));

	}
	~GetCommitProxiesFutureActorState() 
	{
		fdb_probe_actor_destroy("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 9712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetCommitProxiesFutureActorState();
		static_cast<GetCommitProxiesFutureActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 2679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Reference<CommitProxyInfo> commitProxies = cx->getCommitProxies(useProvisionalProxies);
															#line 2680 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (commitProxies)
															#line 9744 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2681 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetCommitProxiesFutureActor*>(this)->SAV<Reference<CommitProxyInfo>>::futures) { (void)(commitProxies); this->~GetCommitProxiesFutureActorState(); static_cast<GetCommitProxiesFutureActor*>(this)->destroy(); return 0; }
															#line 9748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetCommitProxiesFutureActor*>(this)->SAV< Reference<CommitProxyInfo> >::value()) Reference<CommitProxyInfo>(commitProxies);
			this->~GetCommitProxiesFutureActorState();
			static_cast<GetCommitProxiesFutureActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = cx->onProxiesChanged();
															#line 2682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetCommitProxiesFutureActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 9758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<GetCommitProxiesFutureActor*>(this)->actor_wait_state = 1;
															#line 2682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetCommitProxiesFutureActor, 0, Void >*>(static_cast<GetCommitProxiesFutureActor*>(this)));
															#line 9763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetCommitProxiesFutureActor*>(this)->actor_wait_state > 0) static_cast<GetCommitProxiesFutureActor*>(this)->actor_wait_state = 0;
		static_cast<GetCommitProxiesFutureActor*>(this)->ActorCallback< GetCommitProxiesFutureActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetCommitProxiesFutureActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetCommitProxiesFutureActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetCommitProxiesFutureActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseProvisionalProxies useProvisionalProxies;
															#line 9847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getCommitProxiesFuture()
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCommitProxiesFutureActor final : public Actor<Reference<CommitProxyInfo>>, public ActorCallback< GetCommitProxiesFutureActor, 0, Void >, public FastAllocated<GetCommitProxiesFutureActor>, public GetCommitProxiesFutureActorState<GetCommitProxiesFutureActor> {
															#line 9852 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetCommitProxiesFutureActor>::operator new;
	using FastAllocated<GetCommitProxiesFutureActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Reference<CommitProxyInfo>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetCommitProxiesFutureActor, 0, Void >;
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCommitProxiesFutureActor(DatabaseContext* const& cx,UseProvisionalProxies const& useProvisionalProxies) 
															#line 9863 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Reference<CommitProxyInfo>>(),
		   GetCommitProxiesFutureActorState<GetCommitProxiesFutureActor>(cx, useProvisionalProxies)
	{
		fdb_probe_actor_enter("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getCommitProxiesFuture");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getCommitProxiesFuture", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetCommitProxiesFutureActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Reference<CommitProxyInfo>> getCommitProxiesFuture( DatabaseContext* const& cx, UseProvisionalProxies const& useProvisionalProxies ) {
															#line 2676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Reference<CommitProxyInfo>>(new GetCommitProxiesFutureActor(cx, useProvisionalProxies));
															#line 9891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 2685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Returns a future which will not be set until the CommitProxyInfo of this DatabaseContext is not nullptr
Future<Reference<CommitProxyInfo>> DatabaseContext::getCommitProxiesFuture(
    UseProvisionalProxies useProvisionalProxies) {
	return ::getCommitProxiesFuture(this, useProvisionalProxies);
}

void GetRangeLimits::decrement(VectorRef<KeyValueRef> const& data) {
	if (rows != GetRangeLimits::ROW_LIMIT_UNLIMITED) {
		ASSERT(data.size() <= rows);
		rows -= data.size();
	}

	minRows = std::max(0, minRows - data.size());

	if (bytes != GetRangeLimits::BYTE_LIMIT_UNLIMITED)
		bytes = std::max(0, bytes - (int)data.expectedSize() - (8 - (int)sizeof(KeyValueRef)) * data.size());
}

void GetRangeLimits::decrement(KeyValueRef const& data) {
	minRows = std::max(0, minRows - 1);
	if (rows != GetRangeLimits::ROW_LIMIT_UNLIMITED)
		rows--;
	if (bytes != GetRangeLimits::BYTE_LIMIT_UNLIMITED)
		bytes = std::max(0, bytes - (int)8 - (int)data.expectedSize());
}

void GetRangeLimits::decrement(VectorRef<MappedKeyValueRef> const& data) {
	if (rows != GetRangeLimits::ROW_LIMIT_UNLIMITED) {
		ASSERT(data.size() <= rows);
		rows -= data.size();
	}

	minRows = std::max(0, minRows - data.size());

	// TODO: For now, expectedSize only considers the size of the original key values, but not the underlying queries or
	// results. Also, double check it is correct when dealing with sizeof(MappedKeyValueRef).
	if (bytes != GetRangeLimits::BYTE_LIMIT_UNLIMITED)
		bytes = std::max(0, bytes - (int)data.expectedSize() - (8 - (int)sizeof(MappedKeyValueRef)) * data.size());
}

void GetRangeLimits::decrement(MappedKeyValueRef const& data) {
	minRows = std::max(0, minRows - 1);
	if (rows != GetRangeLimits::ROW_LIMIT_UNLIMITED)
		rows--;
	// TODO: For now, expectedSize only considers the size of the original key values, but not the underlying queries or
	// results. Also, double check it is correct when dealing with sizeof(MappedKeyValueRef).
	if (bytes != GetRangeLimits::BYTE_LIMIT_UNLIMITED)
		bytes = std::max(0, bytes - (int)8 - (int)data.expectedSize());
}

// True if either the row or byte limit has been reached
bool GetRangeLimits::isReached() {
	return rows == 0 || (bytes == 0 && minRows == 0);
}

// True if data would cause the row or byte limit to be reached
bool GetRangeLimits::reachedBy(VectorRef<KeyValueRef> const& data) {
	return (rows != GetRangeLimits::ROW_LIMIT_UNLIMITED && data.size() >= rows) ||
	       (bytes != GetRangeLimits::BYTE_LIMIT_UNLIMITED &&
	        (int)data.expectedSize() + (8 - (int)sizeof(KeyValueRef)) * data.size() >= bytes && data.size() >= minRows);
}

bool GetRangeLimits::hasByteLimit() {
	return bytes != GetRangeLimits::BYTE_LIMIT_UNLIMITED;
}

bool GetRangeLimits::hasRowLimit() {
	return rows != GetRangeLimits::ROW_LIMIT_UNLIMITED;
}

bool GetRangeLimits::hasSatisfiedMinRows() {
	return hasByteLimit() && minRows == 0;
}

AddressExclusion AddressExclusion::parse(StringRef const& key) {
	// Must not change: serialized to the database!
	auto parsedIp = IPAddress::parse(key.toString());
	if (parsedIp.present()) {
		return AddressExclusion(parsedIp.get());
	}

	// Not a whole machine, includes `port'.
	try {
		auto addr = NetworkAddress::parse(key.toString());
		if (addr.isTLS()) {
			TraceEvent(SevWarnAlways, "AddressExclusionParseError")
			    .detail("String", key)
			    .detail("Description", "Address inclusion string should not include `:tls' suffix.");
			return AddressExclusion();
		}
		return AddressExclusion(addr.ip, addr.port);
	} catch (Error&) {
		TraceEvent(SevWarnAlways, "AddressExclusionParseError").detail("String", key);
		return AddressExclusion();
	}
}

Future<Optional<Value>> getValue(Reference<TransactionState> const& trState,
                                 Key const& key,
                                 Future<Version> const& version,
                                 UseTenant const& useTenant = UseTenant::True,
                                 TransactionRecordLogInfo const& recordLogInfo = TransactionRecordLogInfo::True);

Future<RangeResult> getRange(Reference<TransactionState> const& trState,
                             Future<Version> const& fVersion,
                             KeySelector const& begin,
                             KeySelector const& end,
                             GetRangeLimits const& limits,
                             Reverse const& reverse,
                             UseTenant const& useTenant);

															#line 10007 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via fetchServerInterface()
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class FetchServerInterfaceActor>
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class FetchServerInterfaceActorState {
															#line 10014 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	FetchServerInterfaceActorState(Reference<TransactionState> const& trState,Future<Version> const& ver,UID const& id) 
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ver(ver),
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   id(id)
															#line 10025 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("fetchServerInterface", reinterpret_cast<unsigned long>(this));

	}
	~FetchServerInterfaceActorState() 
	{
		fdb_probe_actor_destroy("fetchServerInterface", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2800 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = getValue(trState, serverListKeyFor(id), ver, UseTenant::False, TransactionRecordLogInfo::False);
															#line 2800 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<FetchServerInterfaceActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<FetchServerInterfaceActor*>(this)->actor_wait_state = 1;
															#line 2800 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >*>(static_cast<FetchServerInterfaceActor*>(this)));
															#line 10047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~FetchServerInterfaceActorState();
		static_cast<FetchServerInterfaceActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Optional<Value> const& val,int loopDepth) 
	{
															#line 2803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!val.present())
															#line 10070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<FetchServerInterfaceActor*>(this)->SAV<Optional<StorageServerInterface>>::futures) { (void)(Optional<StorageServerInterface>()); this->~FetchServerInterfaceActorState(); static_cast<FetchServerInterfaceActor*>(this)->destroy(); return 0; }
															#line 10074 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<FetchServerInterfaceActor*>(this)->SAV< Optional<StorageServerInterface> >::value()) Optional<StorageServerInterface>(Optional<StorageServerInterface>());
			this->~FetchServerInterfaceActorState();
			static_cast<FetchServerInterfaceActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<FetchServerInterfaceActor*>(this)->SAV<Optional<StorageServerInterface>>::futures) { (void)(decodeServerListValue(val.get())); this->~FetchServerInterfaceActorState(); static_cast<FetchServerInterfaceActor*>(this)->destroy(); return 0; }
															#line 10082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<FetchServerInterfaceActor*>(this)->SAV< Optional<StorageServerInterface> >::value()) Optional<StorageServerInterface>(decodeServerListValue(val.get()));
		this->~FetchServerInterfaceActorState();
		static_cast<FetchServerInterfaceActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Optional<Value> && val,int loopDepth) 
	{
															#line 2803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!val.present())
															#line 10094 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<FetchServerInterfaceActor*>(this)->SAV<Optional<StorageServerInterface>>::futures) { (void)(Optional<StorageServerInterface>()); this->~FetchServerInterfaceActorState(); static_cast<FetchServerInterfaceActor*>(this)->destroy(); return 0; }
															#line 10098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<FetchServerInterfaceActor*>(this)->SAV< Optional<StorageServerInterface> >::value()) Optional<StorageServerInterface>(Optional<StorageServerInterface>());
			this->~FetchServerInterfaceActorState();
			static_cast<FetchServerInterfaceActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<FetchServerInterfaceActor*>(this)->SAV<Optional<StorageServerInterface>>::futures) { (void)(decodeServerListValue(val.get())); this->~FetchServerInterfaceActorState(); static_cast<FetchServerInterfaceActor*>(this)->destroy(); return 0; }
															#line 10106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<FetchServerInterfaceActor*>(this)->SAV< Optional<StorageServerInterface> >::value()) Optional<StorageServerInterface>(decodeServerListValue(val.get()));
		this->~FetchServerInterfaceActorState();
		static_cast<FetchServerInterfaceActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Optional<Value> const& val,int loopDepth) 
	{
		loopDepth = a_body1cont1(val, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Optional<Value> && val,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<FetchServerInterfaceActor*>(this)->actor_wait_state > 0) static_cast<FetchServerInterfaceActor*>(this)->actor_wait_state = 0;
		static_cast<FetchServerInterfaceActor*>(this)->ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("fetchServerInterface", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("fetchServerInterface", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("fetchServerInterface", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("fetchServerInterface", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("fetchServerInterface", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("fetchServerInterface", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> ver;
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID id;
															#line 10183 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via fetchServerInterface()
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class FetchServerInterfaceActor final : public Actor<Optional<StorageServerInterface>>, public ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >, public FastAllocated<FetchServerInterfaceActor>, public FetchServerInterfaceActorState<FetchServerInterfaceActor> {
															#line 10188 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<FetchServerInterfaceActor>::operator new;
	using FastAllocated<FetchServerInterfaceActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Optional<StorageServerInterface>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >;
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	FetchServerInterfaceActor(Reference<TransactionState> const& trState,Future<Version> const& ver,UID const& id) 
															#line 10199 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Optional<StorageServerInterface>>(),
		   FetchServerInterfaceActorState<FetchServerInterfaceActor>(trState, ver, id)
	{
		fdb_probe_actor_enter("fetchServerInterface", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("fetchServerInterface");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("fetchServerInterface", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< FetchServerInterfaceActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Optional<StorageServerInterface>> fetchServerInterface( Reference<TransactionState> const& trState, Future<Version> const& ver, UID const& id ) {
															#line 2797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Optional<StorageServerInterface>>(new FetchServerInterfaceActor(trState, ver, id));
															#line 10227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 2810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 10232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via transactionalGetServerInterfaces()
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class TransactionalGetServerInterfacesActor>
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TransactionalGetServerInterfacesActorState {
															#line 10239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionalGetServerInterfacesActorState(Reference<TransactionState> const& trState,Future<Version> const& ver,std::vector<UID> const& ids) 
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ver(ver),
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ids(ids),
															#line 2813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   serverListEntries()
															#line 10252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this));

	}
	~TransactionalGetServerInterfacesActorState() 
	{
		fdb_probe_actor_destroy("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			serverListEntries.reserve(ids.size());
															#line 2815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int s = 0;s < ids.size();s++) {
															#line 2816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				serverListEntries.push_back(fetchServerInterface(trState, ver, ids[s]));
															#line 10271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 2819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<std::vector<Optional<StorageServerInterface>>> __when_expr_0 = getAll(serverListEntries);
															#line 2819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<TransactionalGetServerInterfacesActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<TransactionalGetServerInterfacesActor*>(this)->actor_wait_state = 1;
															#line 2819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >*>(static_cast<TransactionalGetServerInterfacesActor*>(this)));
															#line 10282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TransactionalGetServerInterfacesActorState();
		static_cast<TransactionalGetServerInterfacesActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(std::vector<Optional<StorageServerInterface>> const& serverListValues,int loopDepth) 
	{
															#line 2820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<StorageServerInterface> serverInterfaces;
															#line 2821 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int s = 0;s < serverListValues.size();s++) {
															#line 2822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!serverListValues[s].present())
															#line 10309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 2824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV<Optional<std::vector<StorageServerInterface>>>::futures) { (void)(Optional<std::vector<StorageServerInterface>>()); this->~TransactionalGetServerInterfacesActorState(); static_cast<TransactionalGetServerInterfacesActor*>(this)->destroy(); return 0; }
															#line 10313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV< Optional<std::vector<StorageServerInterface>> >::value()) Optional<std::vector<StorageServerInterface>>(Optional<std::vector<StorageServerInterface>>());
				this->~TransactionalGetServerInterfacesActorState();
				static_cast<TransactionalGetServerInterfacesActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 2826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			serverInterfaces.push_back(serverListValues[s].get());
															#line 10321 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV<Optional<std::vector<StorageServerInterface>>>::futures) { (void)(serverInterfaces); this->~TransactionalGetServerInterfacesActorState(); static_cast<TransactionalGetServerInterfacesActor*>(this)->destroy(); return 0; }
															#line 10325 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV< Optional<std::vector<StorageServerInterface>> >::value()) Optional<std::vector<StorageServerInterface>>(serverInterfaces);
		this->~TransactionalGetServerInterfacesActorState();
		static_cast<TransactionalGetServerInterfacesActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(std::vector<Optional<StorageServerInterface>> && serverListValues,int loopDepth) 
	{
															#line 2820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<StorageServerInterface> serverInterfaces;
															#line 2821 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int s = 0;s < serverListValues.size();s++) {
															#line 2822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!serverListValues[s].present())
															#line 10341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 2824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV<Optional<std::vector<StorageServerInterface>>>::futures) { (void)(Optional<std::vector<StorageServerInterface>>()); this->~TransactionalGetServerInterfacesActorState(); static_cast<TransactionalGetServerInterfacesActor*>(this)->destroy(); return 0; }
															#line 10345 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV< Optional<std::vector<StorageServerInterface>> >::value()) Optional<std::vector<StorageServerInterface>>(Optional<std::vector<StorageServerInterface>>());
				this->~TransactionalGetServerInterfacesActorState();
				static_cast<TransactionalGetServerInterfacesActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 2826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			serverInterfaces.push_back(serverListValues[s].get());
															#line 10353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV<Optional<std::vector<StorageServerInterface>>>::futures) { (void)(serverInterfaces); this->~TransactionalGetServerInterfacesActorState(); static_cast<TransactionalGetServerInterfacesActor*>(this)->destroy(); return 0; }
															#line 10357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<TransactionalGetServerInterfacesActor*>(this)->SAV< Optional<std::vector<StorageServerInterface>> >::value()) Optional<std::vector<StorageServerInterface>>(serverInterfaces);
		this->~TransactionalGetServerInterfacesActorState();
		static_cast<TransactionalGetServerInterfacesActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(std::vector<Optional<StorageServerInterface>> const& serverListValues,int loopDepth) 
	{
		loopDepth = a_body1cont1(serverListValues, loopDepth);

		return loopDepth;
	}
	int a_body1when1(std::vector<Optional<StorageServerInterface>> && serverListValues,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(serverListValues), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TransactionalGetServerInterfacesActor*>(this)->actor_wait_state > 0) static_cast<TransactionalGetServerInterfacesActor*>(this)->actor_wait_state = 0;
		static_cast<TransactionalGetServerInterfacesActor*>(this)->ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >::remove();

	}
	void a_callback_fire(ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >*,std::vector<Optional<StorageServerInterface>> const& value) 
	{
		fdb_probe_actor_enter("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >*,std::vector<Optional<StorageServerInterface>> && value) 
	{
		fdb_probe_actor_enter("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >*,Error err) 
	{
		fdb_probe_actor_enter("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> ver;
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<UID> ids;
															#line 2813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<Optional<StorageServerInterface>>> serverListEntries;
															#line 10436 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via transactionalGetServerInterfaces()
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TransactionalGetServerInterfacesActor final : public Actor<Optional<std::vector<StorageServerInterface>>>, public ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >, public FastAllocated<TransactionalGetServerInterfacesActor>, public TransactionalGetServerInterfacesActorState<TransactionalGetServerInterfacesActor> {
															#line 10441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<TransactionalGetServerInterfacesActor>::operator new;
	using FastAllocated<TransactionalGetServerInterfacesActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Optional<std::vector<StorageServerInterface>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >;
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionalGetServerInterfacesActor(Reference<TransactionState> const& trState,Future<Version> const& ver,std::vector<UID> const& ids) 
															#line 10452 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Optional<std::vector<StorageServerInterface>>>(),
		   TransactionalGetServerInterfacesActorState<TransactionalGetServerInterfacesActor>(trState, ver, ids)
	{
		fdb_probe_actor_enter("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("transactionalGetServerInterfaces");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("transactionalGetServerInterfaces", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TransactionalGetServerInterfacesActor, 0, std::vector<Optional<StorageServerInterface>> >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Optional<std::vector<StorageServerInterface>>> transactionalGetServerInterfaces( Reference<TransactionState> const& trState, Future<Version> const& ver, std::vector<UID> const& ids ) {
															#line 2811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Optional<std::vector<StorageServerInterface>>>(new TransactionalGetServerInterfacesActor(trState, ver, ids));
															#line 10480 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 2830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

void updateTssMappings(Database cx, const GetKeyServerLocationsReply& reply) {
	// Since a ss -> tss mapping is included in resultsTssMapping iff that SS is in results and has a tss pair,
	// all SS in results that do not have a mapping present must not have a tss pair.
	std::unordered_map<UID, const StorageServerInterface*> ssiById;
	for (const auto& [_, shard] : reply.results) {
		for (auto& ssi : shard) {
			ssiById[ssi.id()] = &ssi;
		}
	}

	for (const auto& mapping : reply.resultsTssMapping) {
		auto ssi = ssiById.find(mapping.first);
		ASSERT(ssi != ssiById.end());
		cx->addTssMapping(*ssi->second, mapping.second);
		ssiById.erase(mapping.first);
	}

	// if SS didn't have a mapping above, it's still in the ssiById map, so remove its tss mapping
	for (const auto& it : ssiById) {
		cx->removeTssMapping(*it.second);
	}
}

void updateTagMappings(Database cx, const GetKeyServerLocationsReply& reply) {
	for (const auto& mapping : reply.resultsTagMapping) {
		cx->addSSIdTagMapping(mapping.first, mapping.second);
	}
}

// If isBackward == true, returns the shard containing the key before 'key' (an infinitely long, inexpressible key).
// Otherwise returns the shard containing key
															#line 10516 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getKeyLocation_internal()
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyLocation_internalActor>
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyLocation_internalActorState {
															#line 10523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyLocation_internalActorState(Database const& cx,Optional<TenantName> const& tenant,Key const& key,SpanID const& spanID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies,Reverse const& isBackward,Version const& version) 
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tenant(tenant),
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   key(key),
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   spanID(spanID),
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugID(debugID),
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useProvisionalProxies(useProvisionalProxies),
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   isBackward(isBackward),
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 2871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:getKeyLocation"_loc, spanID)
															#line 10546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getKeyLocation_internal", reinterpret_cast<unsigned long>(this));

	}
	~GetKeyLocation_internalActorState() 
	{
		fdb_probe_actor_destroy("getKeyLocation_internal", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2872 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (isBackward)
															#line 10561 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 2873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ASSERT(key != allKeys.begin && key <= allKeys.end);
															#line 10565 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 2875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ASSERT(key < allKeys.end);
															#line 10571 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 2878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 10575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 2879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("TransactionDebug", debugID.get().first(), "NativeAPI.getKeyLocation.Before");
															#line 10579 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 2881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 10583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetKeyLocation_internalActorState();
		static_cast<GetKeyLocation_internalActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 2883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = cx->getBackoff();
															#line 2883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 10616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state = 1;
															#line 2883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetKeyLocation_internalActor, 0, Void >*>(static_cast<GetKeyLocation_internalActor*>(this)));
															#line 10621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_proxy_memory_limit_exceeded)
															#line 10643 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 2920 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevWarnAlways, "CommitProxyOverloadedForKeyLocation").suppressFor(5);
															#line 2921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->updateBackoff(e);
															#line 10649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				return a_body1loopHead1(loopDepth); // continue
			}
															#line 2924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_tenant_not_found)
															#line 10654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 2925 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ASSERT(tenant.present());
															#line 2926 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->invalidateCachedTenant(tenant.get());
															#line 10660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 2929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 10664 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 2884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequests;
															#line 2886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = cx->onProxiesChanged();
															#line 2885 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 10682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
															#line 2887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<GetKeyServerLocationsReply> __when_expr_2 = basicLoadBalance(cx->getCommitProxies(useProvisionalProxies), &CommitProxyInterface::getKeyServersLocations, GetKeyServerLocationsRequest(span.context, tenant.castTo<TenantNameRef>(), key, Optional<KeyRef>(), 100, isBackward, version, key.arena()), TaskPriority::DefaultPromiseEndpoint);
															#line 10686 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when2(__when_expr_2.get(), loopDepth); };
		static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state = 2;
															#line 2886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetKeyLocation_internalActor, 1, Void >*>(static_cast<GetKeyLocation_internalActor*>(this)));
															#line 2887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >*>(static_cast<GetKeyLocation_internalActor*>(this)));
															#line 10693 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 2884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequests;
															#line 2886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = cx->onProxiesChanged();
															#line 2885 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 10706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
															#line 2887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<GetKeyServerLocationsReply> __when_expr_2 = basicLoadBalance(cx->getCommitProxies(useProvisionalProxies), &CommitProxyInterface::getKeyServersLocations, GetKeyServerLocationsRequest(span.context, tenant.castTo<TenantNameRef>(), key, Optional<KeyRef>(), 100, isBackward, version, key.arena()), TaskPriority::DefaultPromiseEndpoint);
															#line 10710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when2(__when_expr_2.get(), loopDepth); };
		static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state = 2;
															#line 2886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetKeyLocation_internalActor, 1, Void >*>(static_cast<GetKeyLocation_internalActor*>(this)));
															#line 2887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >*>(static_cast<GetKeyLocation_internalActor*>(this)));
															#line 10717 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state > 0) static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyLocation_internalActor*>(this)->ActorCallback< GetKeyLocation_internalActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyLocation_internalActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetKeyLocation_internalActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetKeyLocation_internalActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(GetKeyServerLocationsReply const& rep,int loopDepth) 
	{
															#line 2899 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequestsCompleted;
															#line 2900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (debugID.present())
															#line 10809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", debugID.get().first(), "NativeAPI.getKeyLocation.After");
															#line 10813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(rep.results.size() == 1);
															#line 2905 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		auto locationInfo = cx->setCachedLocation(tenant, rep.tenantEntry, rep.results[0].first, rep.results[0].second);
															#line 2907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		updateTssMappings(cx, rep);
															#line 2908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		updateTagMappings(cx, rep);
															#line 2910 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->updateBackoff(success());
															#line 2911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetKeyLocation_internalActor*>(this)->SAV<KeyRangeLocationInfo>::futures) { (void)(KeyRangeLocationInfo( rep.tenantEntry, KeyRange(toRelativeRange(rep.results[0].first, rep.tenantEntry.prefix), rep.arena), locationInfo)); this->~GetKeyLocation_internalActorState(); static_cast<GetKeyLocation_internalActor*>(this)->destroy(); return 0; }
															#line 10827 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetKeyLocation_internalActor*>(this)->SAV< KeyRangeLocationInfo >::value()) KeyRangeLocationInfo(KeyRangeLocationInfo( rep.tenantEntry, KeyRange(toRelativeRange(rep.results[0].first, rep.tenantEntry.prefix), rep.arena), locationInfo));
		this->~GetKeyLocation_internalActorState();
		static_cast<GetKeyLocation_internalActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(GetKeyServerLocationsReply && rep,int loopDepth) 
	{
															#line 2899 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequestsCompleted;
															#line 2900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (debugID.present())
															#line 10841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 2901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", debugID.get().first(), "NativeAPI.getKeyLocation.After");
															#line 10845 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 2903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(rep.results.size() == 1);
															#line 2905 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		auto locationInfo = cx->setCachedLocation(tenant, rep.tenantEntry, rep.results[0].first, rep.results[0].second);
															#line 2907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		updateTssMappings(cx, rep);
															#line 2908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		updateTagMappings(cx, rep);
															#line 2910 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->updateBackoff(success());
															#line 2911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetKeyLocation_internalActor*>(this)->SAV<KeyRangeLocationInfo>::futures) { (void)(KeyRangeLocationInfo( rep.tenantEntry, KeyRange(toRelativeRange(rep.results[0].first, rep.tenantEntry.prefix), rep.arena), locationInfo)); this->~GetKeyLocation_internalActorState(); static_cast<GetKeyLocation_internalActor*>(this)->destroy(); return 0; }
															#line 10859 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetKeyLocation_internalActor*>(this)->SAV< KeyRangeLocationInfo >::value()) KeyRangeLocationInfo(KeyRangeLocationInfo( rep.tenantEntry, KeyRange(toRelativeRange(rep.results[0].first, rep.tenantEntry.prefix), rep.arena), locationInfo));
		this->~GetKeyLocation_internalActorState();
		static_cast<GetKeyLocation_internalActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state > 0) static_cast<GetKeyLocation_internalActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyLocation_internalActor*>(this)->ActorCallback< GetKeyLocation_internalActor, 1, Void >::remove();
		static_cast<GetKeyLocation_internalActor*>(this)->ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyLocation_internalActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetKeyLocation_internalActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetKeyLocation_internalActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >*,GetKeyServerLocationsReply const& value) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >*,GetKeyServerLocationsReply && value) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<TenantName> tenant;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key key;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID spanID;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> debugID;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseProvisionalProxies useProvisionalProxies;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reverse isBackward;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 2871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 10995 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getKeyLocation_internal()
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyLocation_internalActor final : public Actor<KeyRangeLocationInfo>, public ActorCallback< GetKeyLocation_internalActor, 0, Void >, public ActorCallback< GetKeyLocation_internalActor, 1, Void >, public ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >, public FastAllocated<GetKeyLocation_internalActor>, public GetKeyLocation_internalActorState<GetKeyLocation_internalActor> {
															#line 11000 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetKeyLocation_internalActor>::operator new;
	using FastAllocated<GetKeyLocation_internalActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<KeyRangeLocationInfo>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetKeyLocation_internalActor, 0, Void >;
friend struct ActorCallback< GetKeyLocation_internalActor, 1, Void >;
friend struct ActorCallback< GetKeyLocation_internalActor, 2, GetKeyServerLocationsReply >;
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyLocation_internalActor(Database const& cx,Optional<TenantName> const& tenant,Key const& key,SpanID const& spanID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies,Reverse const& isBackward,Version const& version) 
															#line 11013 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<KeyRangeLocationInfo>(),
		   GetKeyLocation_internalActorState<GetKeyLocation_internalActor>(cx, tenant, key, spanID, debugID, useProvisionalProxies, isBackward, version)
	{
		fdb_probe_actor_enter("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getKeyLocation_internal");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getKeyLocation_internal", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetKeyLocation_internalActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetKeyLocation_internalActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<KeyRangeLocationInfo> getKeyLocation_internal( Database const& cx, Optional<TenantName> const& tenant, Key const& key, SpanID const& spanID, Optional<UID> const& debugID, UseProvisionalProxies const& useProvisionalProxies, Reverse const& isBackward, Version const& version ) {
															#line 2862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<KeyRangeLocationInfo>(new GetKeyLocation_internalActor(cx, tenant, key, spanID, debugID, useProvisionalProxies, isBackward, version));
															#line 11042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 2933 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Checks if `endpoint` is failed on a healthy server or not. Returns true if we need to refresh the location cache for
// the endpoint.
bool checkOnlyEndpointFailed(const Database& cx, const Endpoint& endpoint) {
	if (IFailureMonitor::failureMonitor().onlyEndpointFailed(endpoint)) {
		// This endpoint is failed, but the server is still healthy. There are two cases this can happen:
		//    - There is a recent bounce in the cluster where the endpoints in SSes get updated.
		//    - The SS is failed and terminated on a server, but the server is kept running.
		// To account for the first case, we invalidate the cache and issue GetKeyLocation requests to the proxy to
		// update the cache with the new SS points. However, if the failure is caused by the second case, the
		// requested key location will continue to be the failed endpoint until the data movement is finished. But
		// every read will generate a GetKeyLocation request to the proxies (and still getting the failed endpoint
		// back), which may overload the proxy and affect data movement speed. Therefore, we only refresh the
		// location cache for short period of time, and after the initial grace period that we keep retrying
		// resolving key location, we will slow it down to resolve it only once every
		// `LOCATION_CACHE_FAILED_ENDPOINT_RETRY_INTERVAL`.
		cx->setFailedEndpointOnHealthyServer(endpoint);
		const auto& failureInfo = cx->getEndpointFailureInfo(endpoint);
		ASSERT(failureInfo.present());
		if (now() - failureInfo.get().startTime < CLIENT_KNOBS->LOCATION_CACHE_ENDPOINT_FAILURE_GRACE_PERIOD ||
		    now() - failureInfo.get().lastRefreshTime > CLIENT_KNOBS->LOCATION_CACHE_FAILED_ENDPOINT_RETRY_INTERVAL) {
			cx->updateFailedEndpointRefreshTime(endpoint);
			return true;
		}
	} else {
		cx->clearFailedEndpointOnHealthyServer(endpoint);
	}
	return false;
}

template <class F>
Future<KeyRangeLocationInfo> getKeyLocation(Database const& cx,
                                            Optional<TenantName> const& tenant,
                                            Key const& key,
                                            F StorageServerInterface::*member,
                                            SpanID spanID,
                                            Optional<UID> debugID,
                                            UseProvisionalProxies useProvisionalProxies,
                                            Reverse isBackward,
                                            Version version) {
	// we first check whether this range is cached
	Optional<KeyRangeLocationInfo> locationInfo = cx->getCachedLocation(tenant, key, isBackward);
	if (!locationInfo.present()) {
		return getKeyLocation_internal(cx, tenant, key, spanID, debugID, useProvisionalProxies, isBackward, version);
	}

	bool onlyEndpointFailedAndNeedRefresh = false;
	for (int i = 0; i < locationInfo.get().locations->size(); i++) {
		if (checkOnlyEndpointFailed(cx, locationInfo.get().locations->get(i, member).getEndpoint())) {
			onlyEndpointFailedAndNeedRefresh = true;
		}
	}

	if (onlyEndpointFailedAndNeedRefresh) {
		cx->invalidateCache(locationInfo.get().tenantEntry.prefix, key);

		// Refresh the cache with a new getKeyLocations made to proxies.
		return getKeyLocation_internal(cx, tenant, key, spanID, debugID, useProvisionalProxies, isBackward, version);
	}

	return locationInfo.get();
}

template <class F>
Future<KeyRangeLocationInfo> getKeyLocation(Reference<TransactionState> trState,
                                            Key const& key,
                                            F StorageServerInterface::*member,
                                            Reverse isBackward,
                                            UseTenant useTenant,
                                            Version version) {
	auto f = getKeyLocation(trState->cx,
	                        useTenant ? trState->tenant() : Optional<TenantName>(),
	                        key,
	                        member,
	                        trState->spanID,
	                        trState->debugID,
	                        trState->useProvisionalProxies,
	                        isBackward,
	                        version);

	if (trState->tenant().present() && useTenant) {
		return map(f, [trState](const KeyRangeLocationInfo& locationInfo) {
			trState->tenantId = locationInfo.tenantEntry.id;
			return locationInfo;
		});
	} else {
		return f;
	}
}

void DatabaseContext::updateBackoff(const Error& err) {
	switch (err.code()) {
	case error_code_success:
		backoffDelay = backoffDelay / CLIENT_KNOBS->BACKOFF_GROWTH_RATE;
		if (backoffDelay < CLIENT_KNOBS->DEFAULT_BACKOFF) {
			backoffDelay = 0.0;
		}
		break;

	case error_code_proxy_memory_limit_exceeded:
		++transactionsResourceConstrained;
		if (backoffDelay == 0.0) {
			backoffDelay = CLIENT_KNOBS->DEFAULT_BACKOFF;
		} else {
			backoffDelay = std::min(backoffDelay * CLIENT_KNOBS->BACKOFF_GROWTH_RATE,
			                        CLIENT_KNOBS->RESOURCE_CONSTRAINED_MAX_BACKOFF);
		}
		break;

	default:
		ASSERT_WE_THINK(false);
	}
}

															#line 11160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getKeyRangeLocations_internal()
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyRangeLocations_internalActor>
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyRangeLocations_internalActorState {
															#line 11167 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyRangeLocations_internalActorState(Database const& cx,Optional<TenantName> const& tenant,KeyRange const& keys,int const& limit,Reverse const& reverse,SpanID const& spanID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies,Version const& version) 
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tenant(tenant),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limit(limit),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   reverse(reverse),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   spanID(spanID),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugID(debugID),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useProvisionalProxies(useProvisionalProxies),
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 3057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:getKeyRangeLocations"_loc, spanID)
															#line 11192 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this));

	}
	~GetKeyRangeLocations_internalActorState() 
	{
		fdb_probe_actor_destroy("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 11207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3059 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("TransactionDebug", debugID.get().first(), "NativeAPI.getKeyLocations.Before");
															#line 11211 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3061 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 11215 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetKeyRangeLocations_internalActorState();
		static_cast<GetKeyRangeLocations_internalActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 3063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = cx->getBackoff();
															#line 3063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 11248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state = 1;
															#line 3063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >*>(static_cast<GetKeyRangeLocations_internalActor*>(this)));
															#line 11253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_proxy_memory_limit_exceeded)
															#line 11275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevWarnAlways, "CommitProxyOverloadedForRangeLocation").suppressFor(5);
															#line 3109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->updateBackoff(e);
															#line 11281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				return a_body1loopHead1(loopDepth); // continue
			}
															#line 3112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_tenant_not_found)
															#line 11286 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3113 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ASSERT(tenant.present());
															#line 3114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->invalidateCachedTenant(tenant.get());
															#line 11292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3117 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 11296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 3064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequests;
															#line 3066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = cx->onProxiesChanged();
															#line 3065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 11314 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
															#line 3067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<GetKeyServerLocationsReply> __when_expr_2 = basicLoadBalance(cx->getCommitProxies(useProvisionalProxies), &CommitProxyInterface::getKeyServersLocations, GetKeyServerLocationsRequest(span.context, tenant.castTo<TenantNameRef>(), keys.begin, keys.end, limit, reverse, version, keys.arena()), TaskPriority::DefaultPromiseEndpoint);
															#line 11318 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when2(__when_expr_2.get(), loopDepth); };
		static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state = 2;
															#line 3066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >*>(static_cast<GetKeyRangeLocations_internalActor*>(this)));
															#line 3067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >*>(static_cast<GetKeyRangeLocations_internalActor*>(this)));
															#line 11325 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 3064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequests;
															#line 3066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = cx->onProxiesChanged();
															#line 3065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 11338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
															#line 3067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<GetKeyServerLocationsReply> __when_expr_2 = basicLoadBalance(cx->getCommitProxies(useProvisionalProxies), &CommitProxyInterface::getKeyServersLocations, GetKeyServerLocationsRequest(span.context, tenant.castTo<TenantNameRef>(), keys.begin, keys.end, limit, reverse, version, keys.arena()), TaskPriority::DefaultPromiseEndpoint);
															#line 11342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when2(__when_expr_2.get(), loopDepth); };
		static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state = 2;
															#line 3066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >*>(static_cast<GetKeyRangeLocations_internalActor*>(this)));
															#line 3067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >*>(static_cast<GetKeyRangeLocations_internalActor*>(this)));
															#line 11349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state > 0) static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyRangeLocations_internalActor*>(this)->ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(GetKeyServerLocationsReply const& _rep,int loopDepth) 
	{
															#line 3079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequestsCompleted;
															#line 3080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 3081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (debugID.present())
															#line 11443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", debugID.get().first(), "NativeAPI.getKeyLocations.After");
															#line 11447 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(rep.results.size());
															#line 3086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results = std::vector<KeyRangeLocationInfo>();
															#line 3087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shard = 0;
															#line 3088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 11457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2when2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(GetKeyServerLocationsReply && _rep,int loopDepth) 
	{
															#line 3079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionKeyServerLocationRequestsCompleted;
															#line 3080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 3081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (debugID.present())
															#line 11470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", debugID.get().first(), "NativeAPI.getKeyLocations.After");
															#line 11474 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(rep.results.size());
															#line 3086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results = std::vector<KeyRangeLocationInfo>();
															#line 3087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shard = 0;
															#line 3088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 11484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2when2loopHead1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state > 0) static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyRangeLocations_internalActor*>(this)->ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >::remove();
		static_cast<GetKeyRangeLocations_internalActor*>(this)->ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont2when2cont1(int loopDepth) 
	{
															#line 3098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		updateTssMappings(cx, rep);
															#line 3099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		updateTagMappings(cx, rep);
															#line 3101 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->updateBackoff(success());
															#line 3102 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetKeyRangeLocations_internalActor*>(this)->SAV<std::vector<KeyRangeLocationInfo>>::futures) { (void)(results); this->~GetKeyRangeLocations_internalActorState(); static_cast<GetKeyRangeLocations_internalActor*>(this)->destroy(); return 0; }
															#line 11551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetKeyRangeLocations_internalActor*>(this)->SAV< std::vector<KeyRangeLocationInfo> >::value()) std::vector<KeyRangeLocationInfo>(std::move(results)); // state_var_RVO
		this->~GetKeyRangeLocations_internalActorState();
		static_cast<GetKeyRangeLocations_internalActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont2when2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2loopBody1(int loopDepth) 
	{
															#line 3088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(shard < rep.results.size()))
															#line 11570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1cont2when2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 3091 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.emplace_back( rep.tenantEntry, (toRelativeRange(rep.results[shard].first, rep.tenantEntry.prefix) & keys), cx->setCachedLocation( tenant, rep.tenantEntry, rep.results[shard].first, rep.results[shard].second));
															#line 3096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = yield();
															#line 3096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 11580 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont2when2loopBody1when1(__when_expr_3.get(), loopDepth); };
		static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state = 3;
															#line 3096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >*>(static_cast<GetKeyRangeLocations_internalActor*>(this)));
															#line 11585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when2break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont2when2cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2when2loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 3088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shard++;
															#line 11607 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont2when2loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 3088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shard++;
															#line 11616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont2when2loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2when2loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2when2loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state > 0) static_cast<GetKeyRangeLocations_internalActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyRangeLocations_internalActor*>(this)->ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2when2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2when2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >*,GetKeyServerLocationsReply const& value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >*,GetKeyServerLocationsReply && value) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<TenantName> tenant;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int limit;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reverse reverse;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID spanID;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> debugID;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseProvisionalProxies useProvisionalProxies;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 3057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 3080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyServerLocationsReply rep;
															#line 3086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> results;
															#line 3087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int shard;
															#line 11768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getKeyRangeLocations_internal()
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyRangeLocations_internalActor final : public Actor<std::vector<KeyRangeLocationInfo>>, public ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >, public ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >, public ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >, public ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >, public FastAllocated<GetKeyRangeLocations_internalActor>, public GetKeyRangeLocations_internalActorState<GetKeyRangeLocations_internalActor> {
															#line 11773 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetKeyRangeLocations_internalActor>::operator new;
	using FastAllocated<GetKeyRangeLocations_internalActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<std::vector<KeyRangeLocationInfo>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >;
friend struct ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >;
friend struct ActorCallback< GetKeyRangeLocations_internalActor, 2, GetKeyServerLocationsReply >;
friend struct ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >;
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyRangeLocations_internalActor(Database const& cx,Optional<TenantName> const& tenant,KeyRange const& keys,int const& limit,Reverse const& reverse,SpanID const& spanID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies,Version const& version) 
															#line 11787 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<std::vector<KeyRangeLocationInfo>>(),
		   GetKeyRangeLocations_internalActorState<GetKeyRangeLocations_internalActor>(cx, tenant, keys, limit, reverse, spanID, debugID, useProvisionalProxies, version)
	{
		fdb_probe_actor_enter("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getKeyRangeLocations_internal");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getKeyRangeLocations_internal", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetKeyRangeLocations_internalActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetKeyRangeLocations_internalActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetKeyRangeLocations_internalActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<std::vector<KeyRangeLocationInfo>> getKeyRangeLocations_internal( Database const& cx, Optional<TenantName> const& tenant, KeyRange const& keys, int const& limit, Reverse const& reverse, SpanID const& spanID, Optional<UID> const& debugID, UseProvisionalProxies const& useProvisionalProxies, Version const& version ) {
															#line 3047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<std::vector<KeyRangeLocationInfo>>(new GetKeyRangeLocations_internalActor(cx, tenant, keys, limit, reverse, spanID, debugID, useProvisionalProxies, version));
															#line 11817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Get the SS locations for each shard in the 'keys' key-range;
// Returned vector size is the number of shards in the input keys key-range.
// Returned vector element is <ShardRange, storage server location info> pairs, where
// ShardRange is the whole shard key-range, not a part of the given key range.
// Example: If query the function with  key range (b, d), the returned list of pairs could be something like:
// [([a, b1), locationInfo), ([b1, c), locationInfo), ([c, d1), locationInfo)].
template <class F>
Future<std::vector<KeyRangeLocationInfo>> getKeyRangeLocations(Database const& cx,
                                                               Optional<TenantName> tenant,
                                                               KeyRange const& keys,
                                                               int limit,
                                                               Reverse reverse,
                                                               F StorageServerInterface::*member,
                                                               SpanID const& spanID,
                                                               Optional<UID> const& debugID,
                                                               UseProvisionalProxies useProvisionalProxies,
                                                               Version version) {

	ASSERT(!keys.empty());

	std::vector<KeyRangeLocationInfo> locations;
	if (!cx->getCachedLocations(tenant, keys, locations, limit, reverse)) {
		return getKeyRangeLocations_internal(
		    cx, tenant, keys, limit, reverse, spanID, debugID, useProvisionalProxies, version);
	}

	bool foundFailed = false;
	for (const auto& locationInfo : locations) {
		bool onlyEndpointFailedAndNeedRefresh = false;
		for (int i = 0; i < locationInfo.locations->size(); i++) {
			if (checkOnlyEndpointFailed(cx, locationInfo.locations->get(i, member).getEndpoint())) {
				onlyEndpointFailedAndNeedRefresh = true;
			}
		}

		if (onlyEndpointFailedAndNeedRefresh) {
			cx->invalidateCache(locationInfo.tenantEntry.prefix, locationInfo.range.begin);
			foundFailed = true;
		}
	}

	if (foundFailed) {
		// Refresh the cache with a new getKeyRangeLocations made to proxies.
		return getKeyRangeLocations_internal(
		    cx, tenant, keys, limit, reverse, spanID, debugID, useProvisionalProxies, version);
	}

	return locations;
}

template <class F>
Future<std::vector<KeyRangeLocationInfo>> getKeyRangeLocations(Reference<TransactionState> trState,
                                                               KeyRange const& keys,
                                                               int limit,
                                                               Reverse reverse,
                                                               F StorageServerInterface::*member,
                                                               UseTenant useTenant,
                                                               Version version) {
	auto f = getKeyRangeLocations(trState->cx,
	                              useTenant ? trState->tenant() : Optional<TenantName>(),
	                              keys,
	                              limit,
	                              reverse,
	                              member,
	                              trState->spanID,
	                              trState->debugID,
	                              trState->useProvisionalProxies,
	                              version);

	if (trState->tenant().present() && useTenant) {
		return map(f, [trState](const std::vector<KeyRangeLocationInfo>& locationInfo) {
			ASSERT(!locationInfo.empty());
			trState->tenantId = locationInfo[0].tenantEntry.id;
			return locationInfo;
		});
	} else {
		return f;
	}
}

															#line 11902 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via warmRange_impl()
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WarmRange_implActor>
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WarmRange_implActorState {
															#line 11909 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WarmRange_implActorState(Reference<TransactionState> const& trState,KeyRange const& keys,Future<Version> const& fVersion) 
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   fVersion(fVersion),
															#line 3203 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   totalRanges(0),
															#line 3204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   totalRequests(0)
															#line 11924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("warmRange_impl", reinterpret_cast<unsigned long>(this));

	}
	~WarmRange_implActorState() 
	{
		fdb_probe_actor_destroy("warmRange_impl", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3206 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Version> __when_expr_0 = fVersion;
															#line 3206 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WarmRange_implActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WarmRange_implActor*>(this)->actor_wait_state = 1;
															#line 3206 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WarmRange_implActor, 0, Version >*>(static_cast<WarmRange_implActor*>(this)));
															#line 11946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WarmRange_implActorState();
		static_cast<WarmRange_implActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 3208 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 11969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version const& __version,int loopDepth) 
	{
															#line 3206 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = __version;
															#line 11978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && __version,int loopDepth) 
	{
		version = std::move(__version);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WarmRange_implActor*>(this)->actor_wait_state > 0) static_cast<WarmRange_implActor*>(this)->actor_wait_state = 0;
		static_cast<WarmRange_implActor*>(this)->ActorCallback< WarmRange_implActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WarmRange_implActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 3243 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WarmRange_implActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WarmRange_implActorState(); static_cast<WarmRange_implActor*>(this)->destroy(); return 0; }
															#line 12045 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WarmRange_implActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~WarmRange_implActorState();
		static_cast<WarmRange_implActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 3209 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_1 = getKeyRangeLocations_internal(trState->cx, trState->tenant(), keys, CLIENT_KNOBS->WARM_RANGE_SHARD_LIMIT, Reverse::False, trState->spanID, trState->debugID, trState->useProvisionalProxies, version);
															#line 3209 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WarmRange_implActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 12066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<WarmRange_implActor*>(this)->actor_wait_state = 2;
															#line 3209 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >*>(static_cast<WarmRange_implActor*>(this)));
															#line 12071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
															#line 3219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		totalRanges += CLIENT_KNOBS->WARM_RANGE_SHARD_LIMIT;
															#line 3220 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		totalRequests++;
															#line 3221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() == 0 || totalRanges >= trState->cx->locationCacheSize || locations[locations.size() - 1].range.end >= keys.end)
															#line 12097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 3225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		keys = KeyRangeRef(locations[locations.size() - 1].range.end, keys.end);
															#line 3227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (totalRequests % 20 == 0)
															#line 12105 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr = Transaction(trState->cx, trState->tenant());
															#line 3230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 12111 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont1loopBody1cont1loopHead1(loopDepth);
		}
		else
		{
			loopDepth = a_body1cont1loopBody1cont2(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
															#line 3219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		totalRanges += CLIENT_KNOBS->WARM_RANGE_SHARD_LIMIT;
															#line 3220 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		totalRequests++;
															#line 3221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() == 0 || totalRanges >= trState->cx->locationCacheSize || locations[locations.size() - 1].range.end >= keys.end)
															#line 12129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 3225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		keys = KeyRangeRef(locations[locations.size() - 1].range.end, keys.end);
															#line 3227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (totalRequests % 20 == 0)
															#line 12137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr = Transaction(trState->cx, trState->tenant());
															#line 3230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 12143 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont1loopBody1cont1loopHead1(loopDepth);
		}
		else
		{
			loopDepth = a_body1cont1loopBody1cont2(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(locations, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(std::move(locations), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WarmRange_implActor*>(this)->actor_wait_state > 0) static_cast<WarmRange_implActor*>(this)->actor_wait_state = 0;
		static_cast<WarmRange_implActor*>(this)->ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont4(int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1(int loopDepth) 
	{
		try {
															#line 3232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::CAUSAL_READ_RISKY);
															#line 3234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = success(tr.getReadVersion());
															#line 3234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WarmRange_implActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 12246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont1loopBody1when1(__when_expr_2.get(), loopDepth); };
			static_cast<WarmRange_implActor*>(this)->actor_wait_state = 3;
															#line 3234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WarmRange_implActor, 2, Void >*>(static_cast<WarmRange_implActor*>(this)));
															#line 12251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont1loopBody1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr.onError(e);
															#line 3237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WarmRange_implActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 12288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 2)); else return a_body1cont1loopBody1cont1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<WarmRange_implActor*>(this)->actor_wait_state = 4;
															#line 3237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WarmRange_implActor, 3, Void >*>(static_cast<WarmRange_implActor*>(this)));
															#line 12293 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1cont2(Void const& _,int loopDepth) 
	{
		return a_body1cont1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1cont2(Void && _,int loopDepth) 
	{
		return a_body1cont1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WarmRange_implActor*>(this)->actor_wait_state > 0) static_cast<WarmRange_implActor*>(this)->actor_wait_state = 0;
		static_cast<WarmRange_implActor*>(this)->ActorCallback< WarmRange_implActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WarmRange_implActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<WarmRange_implActor*>(this)->actor_wait_state > 0) static_cast<WarmRange_implActor*>(this)->actor_wait_state = 0;
		static_cast<WarmRange_implActor*>(this)->ActorCallback< WarmRange_implActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WarmRange_implActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WarmRange_implActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> fVersion;
															#line 3203 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int totalRanges;
															#line 3204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int totalRequests;
															#line 3206 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 3229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 12468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via warmRange_impl()
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WarmRange_implActor final : public Actor<Void>, public ActorCallback< WarmRange_implActor, 0, Version >, public ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >, public ActorCallback< WarmRange_implActor, 2, Void >, public ActorCallback< WarmRange_implActor, 3, Void >, public FastAllocated<WarmRange_implActor>, public WarmRange_implActorState<WarmRange_implActor> {
															#line 12473 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WarmRange_implActor>::operator new;
	using FastAllocated<WarmRange_implActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WarmRange_implActor, 0, Version >;
friend struct ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< WarmRange_implActor, 2, Void >;
friend struct ActorCallback< WarmRange_implActor, 3, Void >;
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WarmRange_implActor(Reference<TransactionState> const& trState,KeyRange const& keys,Future<Version> const& fVersion) 
															#line 12487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   WarmRange_implActorState<WarmRange_implActor>(trState, keys, fVersion)
	{
		fdb_probe_actor_enter("warmRange_impl", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("warmRange_impl");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("warmRange_impl", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WarmRange_implActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WarmRange_implActor, 1, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WarmRange_implActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< WarmRange_implActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> warmRange_impl( Reference<TransactionState> const& trState, KeyRange const& keys, Future<Version> const& fVersion ) {
															#line 3202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new WarmRange_implActor(trState, keys, fVersion));
															#line 12518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3245 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

SpanID generateSpanID(bool transactionTracingSample, SpanID parentContext = SpanID()) {
	uint64_t txnId = deterministicRandom()->randomUInt64();
	if (parentContext.isValid()) {
		if (parentContext.first() > 0) {
			txnId = parentContext.first();
		}
		uint64_t tokenId = parentContext.second() > 0 ? deterministicRandom()->randomUInt64() : 0;
		return SpanID(txnId, tokenId);
	} else if (transactionTracingSample) {
		uint64_t tokenId = deterministicRandom()->random01() <= FLOW_KNOBS->TRACING_SAMPLE_RATE
		                       ? deterministicRandom()->randomUInt64()
		                       : 0;
		return SpanID(txnId, tokenId);
	} else {
		return SpanID(txnId, 0);
	}
}

TransactionState::TransactionState(Database cx,
                                   Optional<TenantName> tenant,
                                   TaskPriority taskID,
                                   SpanID spanID,
                                   Reference<TransactionLogInfo> trLogInfo)
  : cx(cx), trLogInfo(trLogInfo), options(cx), taskID(taskID), spanID(spanID), readVersionObtainedFromGrvProxy(true),
    tenant_(tenant), tenantSet(tenant.present()) {}

Reference<TransactionState> TransactionState::cloneAndReset(Reference<TransactionLogInfo> newTrLogInfo,
                                                            bool generateNewSpan) const {

	SpanID newSpanID = generateNewSpan ? generateSpanID(cx->transactionTracingSample) : spanID;
	Reference<TransactionState> newState =
	    makeReference<TransactionState>(cx, tenant_, cx->taskID, newSpanID, newTrLogInfo);

	if (!cx->apiVersionAtLeast(16)) {
		newState->options = options;
	}

	newState->numErrors = numErrors;
	newState->startTime = startTime;
	newState->committedVersion = committedVersion;
	newState->conflictingKeys = conflictingKeys;
	newState->tenantSet = tenantSet;

	return newState;
}

TenantInfo TransactionState::getTenantInfo() {
	Optional<TenantName> const& t = tenant();

	if (options.rawAccess) {
		return TenantInfo();
	} else if (!cx->internal && cx->clientInfo->get().tenantMode == TenantMode::REQUIRED && !t.present()) {
		throw tenant_name_required();
	} else if (!t.present()) {
		return TenantInfo();
	} else if (cx->clientInfo->get().tenantMode == TenantMode::DISABLED && t.present()) {
		throw tenants_disabled();
	}

	ASSERT(tenantId != TenantInfo::INVALID_TENANT);
	return TenantInfo(t.get(), tenantId);
}

Optional<TenantName> const& TransactionState::tenant() {
	if (tenantSet) {
		return tenant_;
	} else {
		if (!tenant_.present() && !options.rawAccess) {
			tenant_ = cx->defaultTenant;
		}
		tenantSet = true;
		return tenant_;
	}
}

bool TransactionState::hasTenant() const {
	return tenantSet && tenant_.present();
}

Future<Void> Transaction::warmRange(KeyRange keys) {
	return warmRange_impl(trState, keys, getReadVersion());
}

															#line 12606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getValue()
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetValueActor>
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetValueActorState {
															#line 12613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetValueActorState(Reference<TransactionState> const& trState,Key const& key,Future<Version> const& version,UseTenant const& useTenant,TransactionRecordLogInfo const& recordLogInfo) 
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   key(key),
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useTenant(useTenant),
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   recordLogInfo(recordLogInfo)
															#line 12628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getValue", reinterpret_cast<unsigned long>(this));

	}
	~GetValueActorState() 
	{
		fdb_probe_actor_destroy("getValue", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Version> __when_expr_0 = version;
															#line 3334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetValueActor*>(this)->actor_wait_state = 1;
															#line 3334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetValueActor, 0, Version >*>(static_cast<GetValueActor*>(this)));
															#line 12650 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetValueActorState();
		static_cast<GetValueActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 3335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		span = Span("NAPI:getValue"_loc, trState->spanID);
															#line 3336 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (useTenant && trState->tenant().present())
															#line 12675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			span.addTag("tenant"_sr, trState->tenant().get());
															#line 12679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3340 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		span.addTag("key"_sr, key);
															#line 3341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->validateVersion(ver);
															#line 3343 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 12687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version const& __ver,int loopDepth) 
	{
															#line 3334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ver = __ver;
															#line 12696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && __ver,int loopDepth) 
	{
		ver = std::move(__ver);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetValueActor*>(this)->actor_wait_state > 0) static_cast<GetValueActor*>(this)->actor_wait_state = 0;
		static_cast<GetValueActor*>(this)->ActorCallback< GetValueActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< GetValueActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetValueActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetValueActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 3344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<KeyRangeLocationInfo> __when_expr_1 = getKeyLocation(trState, key, &StorageServerInterface::getValue, Reverse::False, useTenant, ver);
															#line 3344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 12772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetValueActor*>(this)->actor_wait_state = 2;
															#line 3344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >*>(static_cast<GetValueActor*>(this)));
															#line 12777 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
															#line 3347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		getValueID = Optional<UID>();
															#line 3348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		startTime = uint64_t();
															#line 3349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		startTimeD = double();
															#line 3350 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ssLatestCommitVersions = VersionVector();
															#line 3351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->getLatestCommitVersions(locationInfo.locations, ver, trState, ssLatestCommitVersions);
															#line 12794 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 3353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->debugID.present())
															#line 12798 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				getValueID = nondeterministicRandom()->randomUniqueID();
															#line 3356 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addAttach("GetValueAttachID", trState->debugID.get().first(), getValueID.get().first());
															#line 3357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("GetValueDebug", getValueID.get().first(), "NativeAPI.getValue.Before");
															#line 12806 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3366 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->getValueSubmitted;
															#line 3367 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			startTime = timer_int();
															#line 3368 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			startTimeD = now();
															#line 3369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReads;
															#line 3371 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			reply = GetValueReply();
															#line 12818 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			try {
															#line 3373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (CLIENT_BUGGIFY_WITH_PROB(.01))
															#line 12822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 3374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1cont1loopBody1cont1Catch2(deterministicRandom()->randomChoice( std::vector<Error>{ transaction_too_old(), future_version() }), loopDepth);
															#line 12826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 3378 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_2 = trState->cx->connectionFileChanged();
															#line 3377 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetValueActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1cont1Catch2(actor_cancelled(), loopDepth);
															#line 12832 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1cont1Catch2(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont1when1(__when_expr_2.get(), loopDepth); };
															#line 3381 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<GetValueReply> __when_expr_3 = loadBalance( trState->cx.getPtr(), locationInfo.locations, &StorageServerInterface::getValue, GetValueRequest(span.context, useTenant ? trState->getTenantInfo() : TenantInfo(), key, ver, trState->cx->sampleReadTags() ? trState->options.readTags : Optional<TagSet>(), getValueID, ssLatestCommitVersions), TaskPriority::DefaultPromiseEndpoint, AtMostOnce::False, trState->cx->enableLocalityLoadBalance ? &trState->cx->queueModel : nullptr);
															#line 12836 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1cont1Catch2(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont1when2(__when_expr_3.get(), loopDepth); };
				static_cast<GetValueActor*>(this)->actor_wait_state = 3;
															#line 3378 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetValueActor, 2, Void >*>(static_cast<GetValueActor*>(this)));
															#line 3381 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetValueActor, 3, GetValueReply >*>(static_cast<GetValueActor*>(this)));
															#line 12843 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1cont1loopBody1cont1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1cont1loopBody1cont1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(KeyRangeLocationInfo const& __locationInfo,int loopDepth) 
	{
															#line 3344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locationInfo = __locationInfo;
															#line 12864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(KeyRangeLocationInfo && __locationInfo,int loopDepth) 
	{
		locationInfo = std::move(__locationInfo);
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetValueActor*>(this)->actor_wait_state > 0) static_cast<GetValueActor*>(this)->actor_wait_state = 0;
		static_cast<GetValueActor*>(this)->ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->getValueCompleted->latency = timer_int() - startTime;
															#line 3430 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->getValueCompleted->log();
															#line 3431 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (getValueID.present())
															#line 12942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3432 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("GetValueDebug", getValueID.get().first(), "NativeAPI.getValue.Error");
															#line 12946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3440 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed || (e.code() == error_code_transaction_too_old && ver == latestVersion))
															#line 12950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3442 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->invalidateCache(locationInfo.tenantEntry.prefix, key);
															#line 3443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_4 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, trState->taskID);
															#line 3443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 12958 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont1Catch1when1(__when_expr_4.get(), loopDepth); };
				static_cast<GetValueActor*>(this)->actor_wait_state = 4;
															#line 3443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetValueActor, 4, Void >*>(static_cast<GetValueActor*>(this)));
															#line 12963 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 3444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 12970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 3445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(useTenant && trState->tenant().present());
															#line 3446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->cx->invalidateCachedTenant(trState->tenant().get());
															#line 3447 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_5 = delay(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, trState->taskID);
															#line 3447 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<GetValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 12980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont1Catch1when2(__when_expr_5.get(), loopDepth); };
					static_cast<GetValueActor*>(this)->actor_wait_state = 5;
															#line 3447 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< GetValueActor, 5, Void >*>(static_cast<GetValueActor*>(this)));
															#line 12985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 3449 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (trState->trLogInfo && recordLogInfo)
															#line 12992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 3450 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						trState->trLogInfo->addLog(FdbClientLogEvents::EventGetError(startTimeD, trState->cx->clientLocality.dcId(), static_cast<int>(e.code()), key, trState->tenant()));
															#line 12996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 3455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 13000 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(int loopDepth) 
	{
															#line 3405 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double latency = now() - startTimeD;
															#line 3406 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->readLatencies.addSample(latency);
															#line 3407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->trLogInfo && recordLogInfo)
															#line 13020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			int valueSize = reply.value.present() ? reply.value.get().size() : 0;
															#line 3409 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->trLogInfo->addLog(FdbClientLogEvents::EventGet( startTimeD, trState->cx->clientLocality.dcId(), latency, valueSize, key, trState->tenant()));
															#line 13026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->getValueCompleted->latency = timer_int() - startTime;
															#line 3413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->getValueCompleted->log();
															#line 3415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (getValueID.present())
															#line 13034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent("GetValueDebug", getValueID.get().first(), "NativeAPI.getValue.After");
															#line 13038 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3425 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->transactionBytesRead += reply.value.present() ? reply.value.get().size() : 0;
															#line 3426 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionKeysRead;
															#line 3427 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetValueActor*>(this)->SAV<Optional<Value>>::futures) { (void)(reply.value); this->~GetValueActorState(); static_cast<GetValueActor*>(this)->destroy(); return 0; }
															#line 13046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetValueActor*>(this)->SAV< Optional<Value> >::value()) Optional<Value>(reply.value);
		this->~GetValueActorState();
		static_cast<GetValueActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch2(const Error& __current_error,int loopDepth=0) 
	{
		try {
															#line 3401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReadsCompleted;
															#line 3402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1cont1loopBody1cont1Catch1(__current_error, loopDepth);
															#line 13061 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont5(int loopDepth) 
	{
															#line 3399 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionPhysicalReadsCompleted;
															#line 13075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont8(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
															#line 3379 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1cont1loopBody1cont1Catch2(transaction_too_old(), loopDepth);
															#line 13084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when1(Void && _,int loopDepth) 
	{
															#line 3379 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1cont1loopBody1cont1Catch2(transaction_too_old(), loopDepth);
															#line 13092 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when2(GetValueReply const& _reply,int loopDepth) 
	{
															#line 3396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		reply = _reply;
															#line 13100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when2(GetValueReply && _reply,int loopDepth) 
	{
															#line 3396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		reply = _reply;
															#line 13109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetValueActor*>(this)->actor_wait_state > 0) static_cast<GetValueActor*>(this)->actor_wait_state = 0;
		static_cast<GetValueActor*>(this)->ActorCallback< GetValueActor, 2, Void >::remove();
		static_cast<GetValueActor*>(this)->ActorCallback< GetValueActor, 3, GetValueReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetValueActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetValueActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetValueActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetValueActor, 3, GetValueReply >*,GetValueReply const& value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetValueActor, 3, GetValueReply >*,GetValueReply && value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetValueActor, 3, GetValueReply >*,Error err) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1cont8(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1loopBody1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetValueActor*>(this)->actor_wait_state > 0) static_cast<GetValueActor*>(this)->actor_wait_state = 0;
		static_cast<GetValueActor*>(this)->ActorCallback< GetValueActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetValueActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetValueActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetValueActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont1loopBody1cont1Catch1cont4(int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetValueActor*>(this)->actor_wait_state > 0) static_cast<GetValueActor*>(this)->actor_wait_state = 0;
		static_cast<GetValueActor*>(this)->ActorCallback< GetValueActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetValueActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont1Catch1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< GetValueActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont1Catch1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< GetValueActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), 5);

	}
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key key;
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> version;
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseTenant useTenant;
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionRecordLogInfo recordLogInfo;
															#line 3334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version ver;
															#line 3335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 3344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeLocationInfo locationInfo;
															#line 3347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> getValueID;
															#line 3348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	uint64_t startTime;
															#line 3349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double startTimeD;
															#line 3350 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	VersionVector ssLatestCommitVersions;
															#line 3371 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetValueReply reply;
															#line 13412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getValue()
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetValueActor final : public Actor<Optional<Value>>, public ActorCallback< GetValueActor, 0, Version >, public ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >, public ActorCallback< GetValueActor, 2, Void >, public ActorCallback< GetValueActor, 3, GetValueReply >, public ActorCallback< GetValueActor, 4, Void >, public ActorCallback< GetValueActor, 5, Void >, public FastAllocated<GetValueActor>, public GetValueActorState<GetValueActor> {
															#line 13417 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetValueActor>::operator new;
	using FastAllocated<GetValueActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Optional<Value>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetValueActor, 0, Version >;
friend struct ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >;
friend struct ActorCallback< GetValueActor, 2, Void >;
friend struct ActorCallback< GetValueActor, 3, GetValueReply >;
friend struct ActorCallback< GetValueActor, 4, Void >;
friend struct ActorCallback< GetValueActor, 5, Void >;
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetValueActor(Reference<TransactionState> const& trState,Key const& key,Future<Version> const& version,UseTenant const& useTenant,TransactionRecordLogInfo const& recordLogInfo) 
															#line 13433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Optional<Value>>(),
		   GetValueActorState<GetValueActor>(trState, key, version, useTenant, recordLogInfo)
	{
		fdb_probe_actor_enter("getValue", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getValue");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getValue", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetValueActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetValueActor, 1, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetValueActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetValueActor, 4, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetValueActor, 5, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Optional<Value>> getValue( Reference<TransactionState> const& trState, Key const& key, Future<Version> const& version, UseTenant const& useTenant, TransactionRecordLogInfo const& recordLogInfo ) {
															#line 3329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Optional<Value>>(new GetValueActor(trState, key, version, useTenant, recordLogInfo));
															#line 13465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 13470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getKey()
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyActor>
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyActorState {
															#line 13477 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyActorState(Reference<TransactionState> const& trState,KeySelector const& k,Future<Version> const& version,UseTenant const& useTenant = UseTenant::True) 
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   k(k),
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useTenant(useTenant)
															#line 13490 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getKey", reinterpret_cast<unsigned long>(this));

	}
	~GetKeyActorState() 
	{
		fdb_probe_actor_destroy("getKey", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = success(version);
															#line 3465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetKeyActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetKeyActor*>(this)->actor_wait_state = 1;
															#line 3465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetKeyActor, 0, Void >*>(static_cast<GetKeyActor*>(this)));
															#line 13512 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetKeyActorState();
		static_cast<GetKeyActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 3467 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		getKeyID = Optional<UID>();
															#line 3468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		span = Span("NAPI:getKey"_loc, trState->spanID);
															#line 3469 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->debugID.present())
															#line 13539 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			getKeyID = nondeterministicRandom()->randomUniqueID();
															#line 3472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addAttach("GetKeyAttachID", trState->debugID.get().first(), getKeyID.get().first());
															#line 3473 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "GetKeyDebug", getKeyID.get().first(), "NativeAPI.getKey.AfterVersion");
															#line 13547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3480 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 13551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 3467 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		getKeyID = Optional<UID>();
															#line 3468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		span = Span("NAPI:getKey"_loc, trState->spanID);
															#line 3469 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->debugID.present())
															#line 13564 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			getKeyID = nondeterministicRandom()->randomUniqueID();
															#line 3472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addAttach("GetKeyAttachID", trState->debugID.get().first(), getKeyID.get().first());
															#line 3473 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "GetKeyDebug", getKeyID.get().first(), "NativeAPI.getKey.AfterVersion");
															#line 13572 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3480 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 13576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetKeyActor*>(this)->actor_wait_state > 0) static_cast<GetKeyActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyActor*>(this)->ActorCallback< GetKeyActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetKeyActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 3481 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (k.getKey() == allKeys.end)
															#line 13655 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3482 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (k.offset > 0)
															#line 13659 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3483 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<GetKeyActor*>(this)->SAV<Key>::futures) { (void)(allKeys.end); this->~GetKeyActorState(); static_cast<GetKeyActor*>(this)->destroy(); return 0; }
															#line 13663 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<GetKeyActor*>(this)->SAV< Key >::value()) Key(allKeys.end);
				this->~GetKeyActorState();
				static_cast<GetKeyActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 3485 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			k.orEqual = false;
															#line 13671 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 3486 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (k.getKey() == allKeys.begin && k.offset <= 0)
															#line 13677 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<GetKeyActor*>(this)->SAV<Key>::futures) { (void)(Key()); this->~GetKeyActorState(); static_cast<GetKeyActor*>(this)->destroy(); return 0; }
															#line 13681 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<GetKeyActor*>(this)->SAV< Key >::value()) Key(Key());
				this->~GetKeyActorState();
				static_cast<GetKeyActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
		}
															#line 3490 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Key locationKey(k.getKey(), k.arena());
															#line 3491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<KeyRangeLocationInfo> __when_expr_1 = getKeyLocation(trState, locationKey, &StorageServerInterface::getKey, Reverse{ k.isBackward() }, useTenant, version.get());
															#line 3491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetKeyActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 13694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetKeyActor*>(this)->actor_wait_state = 2;
															#line 3491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >*>(static_cast<GetKeyActor*>(this)));
															#line 13699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
															#line 3498 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ssLatestCommitVersions = VersionVector();
															#line 3499 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->getLatestCommitVersions(locationInfo.locations, version.get(), trState, ssLatestCommitVersions);
															#line 13710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 3502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (getKeyID.present())
															#line 13714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3503 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent( "GetKeyDebug", getKeyID.get().first(), "NativeAPI.getKey.Before");
															#line 13718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReads;
															#line 3510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			GetKeyRequest req(span.context, useTenant ? trState->getTenantInfo() : TenantInfo(), k, version.get(), trState->cx->sampleReadTags() ? trState->options.readTags : Optional<TagSet>(), getKeyID, ssLatestCommitVersions);
															#line 3517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.arena.dependsOn(k.arena());
															#line 3519 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			reply = GetKeyReply();
															#line 13728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			try {
															#line 3522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_2 = trState->cx->connectionFileChanged();
															#line 3521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetKeyActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1cont1Catch2(actor_cancelled(), loopDepth);
															#line 13734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1cont1Catch2(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont1when1(__when_expr_2.get(), loopDepth); };
															#line 3525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<GetKeyReply> __when_expr_3 = loadBalance( trState->cx.getPtr(), locationInfo.locations, &StorageServerInterface::getKey, req, TaskPriority::DefaultPromiseEndpoint, AtMostOnce::False, trState->cx->enableLocalityLoadBalance ? &trState->cx->queueModel : nullptr);
															#line 13738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1cont1Catch2(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont1when2(__when_expr_3.get(), loopDepth); };
				static_cast<GetKeyActor*>(this)->actor_wait_state = 3;
															#line 3522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetKeyActor, 2, Void >*>(static_cast<GetKeyActor*>(this)));
															#line 3525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetKeyActor, 3, GetKeyReply >*>(static_cast<GetKeyActor*>(this)));
															#line 13745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1cont1loopBody1cont1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1cont1loopBody1cont1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(KeyRangeLocationInfo const& __locationInfo,int loopDepth) 
	{
															#line 3491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locationInfo = __locationInfo;
															#line 13766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(KeyRangeLocationInfo && __locationInfo,int loopDepth) 
	{
		locationInfo = std::move(__locationInfo);
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetKeyActor*>(this)->actor_wait_state > 0) static_cast<GetKeyActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyActor*>(this)->ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont6(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (getKeyID.present())
															#line 13840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3552 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("GetKeyDebug", getKeyID.get().first(), "NativeAPI.getKey.Error");
															#line 13844 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed)
															#line 13848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->invalidateCache(locationInfo.tenantEntry.prefix, k.getKey(), Reverse{ k.isBackward() });
															#line 3556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_4 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, trState->taskID);
															#line 3556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetKeyActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 13856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont1Catch1when1(__when_expr_4.get(), loopDepth); };
				static_cast<GetKeyActor*>(this)->actor_wait_state = 4;
															#line 3556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetKeyActor, 4, Void >*>(static_cast<GetKeyActor*>(this)));
															#line 13861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 3557 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 13868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 3558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(useTenant && trState->tenant().present());
															#line 3559 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->cx->invalidateCachedTenant(trState->tenant().get());
															#line 3560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_5 = delay(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, trState->taskID);
															#line 3560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<GetKeyActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 13878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1cont1Catch1when2(__when_expr_5.get(), loopDepth); };
					static_cast<GetKeyActor*>(this)->actor_wait_state = 5;
															#line 3560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< GetKeyActor, 5, Void >*>(static_cast<GetKeyActor*>(this)));
															#line 13883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 3562 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TraceEvent(SevInfo, "GetKeyError").error(e).detail("AtKey", k.getKey()).detail("Offset", k.offset);
															#line 3563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 13892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont7(int loopDepth) 
	{
															#line 3541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (getKeyID.present())
															#line 13908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3542 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent("GetKeyDebug", getKeyID.get().first(), "NativeAPI.getKey.After");
															#line 13912 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		k = reply.sel;
															#line 3547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!k.offset && k.orEqual)
															#line 13918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3548 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetKeyActor*>(this)->SAV<Key>::futures) { (void)(k.getKey()); this->~GetKeyActorState(); static_cast<GetKeyActor*>(this)->destroy(); return 0; }
															#line 13922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetKeyActor*>(this)->SAV< Key >::value()) Key(k.getKey());
			this->~GetKeyActorState();
			static_cast<GetKeyActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		loopDepth = a_body1cont1loopBody1cont15(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch2(const Error& __current_error,int loopDepth=0) 
	{
		try {
															#line 3538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReadsCompleted;
															#line 3539 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1cont1loopBody1cont1Catch1(__current_error, loopDepth);
															#line 13939 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont9(int loopDepth) 
	{
															#line 3536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionPhysicalReadsCompleted;
															#line 13953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont11(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
															#line 3523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1cont1loopBody1cont1Catch2(transaction_too_old(), loopDepth);
															#line 13962 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when1(Void && _,int loopDepth) 
	{
															#line 3523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1cont1loopBody1cont1Catch2(transaction_too_old(), loopDepth);
															#line 13970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when2(GetKeyReply const& _reply,int loopDepth) 
	{
															#line 3533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		reply = _reply;
															#line 13978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1when2(GetKeyReply && _reply,int loopDepth) 
	{
															#line 3533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		reply = _reply;
															#line 13987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetKeyActor*>(this)->actor_wait_state > 0) static_cast<GetKeyActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyActor*>(this)->ActorCallback< GetKeyActor, 2, Void >::remove();
		static_cast<GetKeyActor*>(this)->ActorCallback< GetKeyActor, 3, GetKeyReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetKeyActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 3, GetKeyReply >*,GetKeyReply const& value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 3, GetKeyReply >*,GetKeyReply && value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetKeyActor, 3, GetKeyReply >*,Error err) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont1loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1cont11(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1loopBody1cont7(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont15(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1loopBody1cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetKeyActor*>(this)->actor_wait_state > 0) static_cast<GetKeyActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyActor*>(this)->ActorCallback< GetKeyActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetKeyActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont1loopBody1cont1Catch1cont4(int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1Catch1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1Catch1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetKeyActor*>(this)->actor_wait_state > 0) static_cast<GetKeyActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyActor*>(this)->ActorCallback< GetKeyActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont1Catch1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< GetKeyActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont1Catch1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< GetKeyActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), 5);

	}
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector k;
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> version;
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseTenant useTenant;
															#line 3467 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> getKeyID;
															#line 3468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 3491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeLocationInfo locationInfo;
															#line 3498 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	VersionVector ssLatestCommitVersions;
															#line 3519 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyReply reply;
															#line 14295 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getKey()
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyActor final : public Actor<Key>, public ActorCallback< GetKeyActor, 0, Void >, public ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >, public ActorCallback< GetKeyActor, 2, Void >, public ActorCallback< GetKeyActor, 3, GetKeyReply >, public ActorCallback< GetKeyActor, 4, Void >, public ActorCallback< GetKeyActor, 5, Void >, public FastAllocated<GetKeyActor>, public GetKeyActorState<GetKeyActor> {
															#line 14300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetKeyActor>::operator new;
	using FastAllocated<GetKeyActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetKeyActor, 0, Void >;
friend struct ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >;
friend struct ActorCallback< GetKeyActor, 2, Void >;
friend struct ActorCallback< GetKeyActor, 3, GetKeyReply >;
friend struct ActorCallback< GetKeyActor, 4, Void >;
friend struct ActorCallback< GetKeyActor, 5, Void >;
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyActor(Reference<TransactionState> const& trState,KeySelector const& k,Future<Version> const& version,UseTenant const& useTenant = UseTenant::True) 
															#line 14316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Key>(),
		   GetKeyActorState<GetKeyActor>(trState, k, version, useTenant)
	{
		fdb_probe_actor_enter("getKey", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getKey");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getKey", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetKeyActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetKeyActor, 1, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetKeyActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetKeyActor, 4, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetKeyActor, 5, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Key> getKey( Reference<TransactionState> const& trState, KeySelector const& k, Future<Version> const& version, UseTenant const& useTenant = UseTenant::True ) {
															#line 3461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Key>(new GetKeyActor(trState, k, version, useTenant));
															#line 14348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 14353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via waitForCommittedVersion()
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WaitForCommittedVersionActor>
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitForCommittedVersionActorState {
															#line 14360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitForCommittedVersionActorState(Database const& cx,Version const& version,SpanID const& spanContext) 
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   spanContext(spanContext),
															#line 3570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:waitForCommittedVersion"_loc, { spanContext })
															#line 14373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("waitForCommittedVersion", reinterpret_cast<unsigned long>(this));

	}
	~WaitForCommittedVersionActorState() 
	{
		fdb_probe_actor_destroy("waitForCommittedVersion", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3571 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 14388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitForCommittedVersionActorState();
		static_cast<WaitForCommittedVersionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 3574 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = cx->onProxiesChanged();
															#line 3573 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 14421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 3575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<GetReadVersionReply> __when_expr_1 = basicLoadBalance( cx->getGrvProxies(UseProvisionalProxies::False), &GrvProxyInterface::getConsistentReadVersion, GetReadVersionRequest( span.context, 0, TransactionPriority::IMMEDIATE, cx->ssVersionVectorCache.getMaxVersion()), cx->taskID);
															#line 14425 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
			static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state = 1;
															#line 3574 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitForCommittedVersionActor, 0, Void >*>(static_cast<WaitForCommittedVersionActor*>(this)));
															#line 3575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitForCommittedVersionActor, 1, GetReadVersionReply >*>(static_cast<WaitForCommittedVersionActor*>(this)));
															#line 14432 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3599 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_batch_transaction_throttled || e.code() == error_code_proxy_memory_limit_exceeded)
															#line 14454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3602 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_3 = delayJittered(CLIENT_KNOBS->GRV_ERROR_RETRY_DELAY);
															#line 3602 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 14460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
				static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state = 3;
															#line 3602 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitForCommittedVersionActor, 3, Void >*>(static_cast<WaitForCommittedVersionActor*>(this)));
															#line 14465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 3604 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "WaitForCommittedVersionError").error(e);
															#line 3605 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 14474 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(GetReadVersionReply const& v,int loopDepth) 
	{
															#line 3581 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->minAcceptableReadVersion = std::min(cx->minAcceptableReadVersion, v.version);
															#line 3582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v.midShardSize > 0)
															#line 14509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->smoothMidShardSize.setTotal(v.midShardSize);
															#line 14513 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3584 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (cx->versionVectorCacheActive(v.ssVersionVectorDelta))
															#line 14517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (cx->isCurrentGrvProxy(v.proxyId))
															#line 14521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3586 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->ssVersionVectorCache.applyDelta(v.ssVersionVectorDelta);
															#line 14525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 3588 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->ssVersionVectorCache.clear();
															#line 14531 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 3591 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v.version >= version)
															#line 14536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3592 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitForCommittedVersionActor*>(this)->SAV<Version>::futures) { (void)(v.version); this->~WaitForCommittedVersionActorState(); static_cast<WaitForCommittedVersionActor*>(this)->destroy(); return 0; }
															#line 14540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitForCommittedVersionActor*>(this)->SAV< Version >::value()) Version(v.version);
			this->~WaitForCommittedVersionActorState();
			static_cast<WaitForCommittedVersionActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->FUTURE_VERSION_RETRY_DELAY, cx->taskID);
															#line 3595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 14550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1when2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state = 2;
															#line 3595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitForCommittedVersionActor, 2, Void >*>(static_cast<WaitForCommittedVersionActor*>(this)));
															#line 14555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when2(GetReadVersionReply && v,int loopDepth) 
	{
															#line 3581 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->minAcceptableReadVersion = std::min(cx->minAcceptableReadVersion, v.version);
															#line 3582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v.midShardSize > 0)
															#line 14566 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->smoothMidShardSize.setTotal(v.midShardSize);
															#line 14570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3584 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (cx->versionVectorCacheActive(v.ssVersionVectorDelta))
															#line 14574 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (cx->isCurrentGrvProxy(v.proxyId))
															#line 14578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3586 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->ssVersionVectorCache.applyDelta(v.ssVersionVectorDelta);
															#line 14582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 3588 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->ssVersionVectorCache.clear();
															#line 14588 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 3591 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v.version >= version)
															#line 14593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3592 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitForCommittedVersionActor*>(this)->SAV<Version>::futures) { (void)(v.version); this->~WaitForCommittedVersionActorState(); static_cast<WaitForCommittedVersionActor*>(this)->destroy(); return 0; }
															#line 14597 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitForCommittedVersionActor*>(this)->SAV< Version >::value()) Version(v.version);
			this->~WaitForCommittedVersionActorState();
			static_cast<WaitForCommittedVersionActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->FUTURE_VERSION_RETRY_DELAY, cx->taskID);
															#line 3595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 14607 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1when2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state = 2;
															#line 3595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitForCommittedVersionActor, 2, Void >*>(static_cast<WaitForCommittedVersionActor*>(this)));
															#line 14612 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitForCommittedVersionActor*>(this)->ActorCallback< WaitForCommittedVersionActor, 0, Void >::remove();
		static_cast<WaitForCommittedVersionActor*>(this)->ActorCallback< WaitForCommittedVersionActor, 1, GetReadVersionReply >::remove();

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitForCommittedVersionActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1when2cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1when2cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1when2cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitForCommittedVersionActor*>(this)->ActorCallback< WaitForCommittedVersionActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1when2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1when2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WaitForCommittedVersionActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 1, GetReadVersionReply >*,GetReadVersionReply const& value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 1, GetReadVersionReply >*,GetReadVersionReply && value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitForCommittedVersionActor, 1, GetReadVersionReply >*,Error err) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitForCommittedVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitForCommittedVersionActor*>(this)->ActorCallback< WaitForCommittedVersionActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WaitForCommittedVersionActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WaitForCommittedVersionActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID spanContext;
															#line 3570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 14891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via waitForCommittedVersion()
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitForCommittedVersionActor final : public Actor<Version>, public ActorCallback< WaitForCommittedVersionActor, 0, Void >, public ActorCallback< WaitForCommittedVersionActor, 1, GetReadVersionReply >, public ActorCallback< WaitForCommittedVersionActor, 2, Void >, public ActorCallback< WaitForCommittedVersionActor, 3, Void >, public FastAllocated<WaitForCommittedVersionActor>, public WaitForCommittedVersionActorState<WaitForCommittedVersionActor> {
															#line 14896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WaitForCommittedVersionActor>::operator new;
	using FastAllocated<WaitForCommittedVersionActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Version>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitForCommittedVersionActor, 0, Void >;
friend struct ActorCallback< WaitForCommittedVersionActor, 1, GetReadVersionReply >;
friend struct ActorCallback< WaitForCommittedVersionActor, 2, Void >;
friend struct ActorCallback< WaitForCommittedVersionActor, 3, Void >;
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitForCommittedVersionActor(Database const& cx,Version const& version,SpanID const& spanContext) 
															#line 14910 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Version>(),
		   WaitForCommittedVersionActorState<WaitForCommittedVersionActor>(cx, version, spanContext)
	{
		fdb_probe_actor_enter("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitForCommittedVersion");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitForCommittedVersion", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitForCommittedVersionActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WaitForCommittedVersionActor, 2, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WaitForCommittedVersionActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Version> waitForCommittedVersion( Database const& cx, Version const& version, SpanID const& spanContext ) {
															#line 3569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Version>(new WaitForCommittedVersionActor(cx, version, spanContext));
															#line 14940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 14945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getRawVersion()
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetRawVersionActor>
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRawVersionActorState {
															#line 14952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRawVersionActorState(Reference<TransactionState> const& trState) 
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 3612 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:getRawVersion"_loc, { trState->spanID })
															#line 14961 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getRawVersion", reinterpret_cast<unsigned long>(this));

	}
	~GetRawVersionActorState() 
	{
		fdb_probe_actor_destroy("getRawVersion", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 14976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetRawVersionActorState();
		static_cast<GetRawVersionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 3615 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = trState->cx->onProxiesChanged();
															#line 3614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRawVersionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 15008 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 3616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<GetReadVersionReply> __when_expr_1 = basicLoadBalance(trState->cx->getGrvProxies(UseProvisionalProxies::False), &GrvProxyInterface::getConsistentReadVersion, GetReadVersionRequest(trState->spanID, 0, TransactionPriority::IMMEDIATE, trState->cx->ssVersionVectorCache.getMaxVersion()), trState->cx->taskID);
															#line 15012 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
		static_cast<GetRawVersionActor*>(this)->actor_wait_state = 1;
															#line 3615 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetRawVersionActor, 0, Void >*>(static_cast<GetRawVersionActor*>(this)));
															#line 3616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetRawVersionActor, 1, GetReadVersionReply >*>(static_cast<GetRawVersionActor*>(this)));
															#line 15019 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(GetReadVersionReply const& v,int loopDepth) 
	{
															#line 3624 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->cx->versionVectorCacheActive(v.ssVersionVectorDelta))
															#line 15046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->cx->isCurrentGrvProxy(v.proxyId))
															#line 15050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.applyDelta(v.ssVersionVectorDelta);
															#line 15054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 3628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.clear();
															#line 15060 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 3631 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRawVersionActor*>(this)->SAV<Version>::futures) { (void)(v.version); this->~GetRawVersionActorState(); static_cast<GetRawVersionActor*>(this)->destroy(); return 0; }
															#line 15065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRawVersionActor*>(this)->SAV< Version >::value()) Version(v.version);
		this->~GetRawVersionActorState();
		static_cast<GetRawVersionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when2(GetReadVersionReply && v,int loopDepth) 
	{
															#line 3624 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->cx->versionVectorCacheActive(v.ssVersionVectorDelta))
															#line 15077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->cx->isCurrentGrvProxy(v.proxyId))
															#line 15081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.applyDelta(v.ssVersionVectorDelta);
															#line 15085 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 3628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.clear();
															#line 15091 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 3631 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRawVersionActor*>(this)->SAV<Version>::futures) { (void)(v.version); this->~GetRawVersionActorState(); static_cast<GetRawVersionActor*>(this)->destroy(); return 0; }
															#line 15096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRawVersionActor*>(this)->SAV< Version >::value()) Version(v.version);
		this->~GetRawVersionActorState();
		static_cast<GetRawVersionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetRawVersionActor*>(this)->actor_wait_state > 0) static_cast<GetRawVersionActor*>(this)->actor_wait_state = 0;
		static_cast<GetRawVersionActor*>(this)->ActorCallback< GetRawVersionActor, 0, Void >::remove();
		static_cast<GetRawVersionActor*>(this)->ActorCallback< GetRawVersionActor, 1, GetReadVersionReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetRawVersionActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRawVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRawVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetRawVersionActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRawVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRawVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetRawVersionActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRawVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRawVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetRawVersionActor, 1, GetReadVersionReply >*,GetReadVersionReply const& value) 
	{
		fdb_probe_actor_enter("getRawVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRawVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetRawVersionActor, 1, GetReadVersionReply >*,GetReadVersionReply && value) 
	{
		fdb_probe_actor_enter("getRawVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRawVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetRawVersionActor, 1, GetReadVersionReply >*,Error err) 
	{
		fdb_probe_actor_enter("getRawVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRawVersion", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 3612 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 15205 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getRawVersion()
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRawVersionActor final : public Actor<Version>, public ActorCallback< GetRawVersionActor, 0, Void >, public ActorCallback< GetRawVersionActor, 1, GetReadVersionReply >, public FastAllocated<GetRawVersionActor>, public GetRawVersionActorState<GetRawVersionActor> {
															#line 15210 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetRawVersionActor>::operator new;
	using FastAllocated<GetRawVersionActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Version>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetRawVersionActor, 0, Void >;
friend struct ActorCallback< GetRawVersionActor, 1, GetReadVersionReply >;
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRawVersionActor(Reference<TransactionState> const& trState) 
															#line 15222 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Version>(),
		   GetRawVersionActorState<GetRawVersionActor>(trState)
	{
		fdb_probe_actor_enter("getRawVersion", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getRawVersion");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getRawVersion", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetRawVersionActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Version> getRawVersion( Reference<TransactionState> const& trState ) {
															#line 3611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Version>(new GetRawVersionActor(trState));
															#line 15250 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3636 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 15255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
[[nodiscard]] Future<Void> readVersionBatcher( DatabaseContext* const& cx, FutureStream<std::pair<Promise<GetReadVersionReply>, Optional<UID>>> const& versionStream, uint32_t const& flags );

#line 3641 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 15260 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via watchValue()
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WatchValueActor>
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchValueActorState {
															#line 15267 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchValueActorState(Database const& cx,Reference<const WatchParameters> const& parameters) 
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   parameters(parameters),
															#line 3643 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:watchValue"_loc, parameters->spanID),
															#line 3644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ver(parameters->version)
															#line 15280 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("watchValue", reinterpret_cast<unsigned long>(this));

	}
	~WatchValueActorState() 
	{
		fdb_probe_actor_destroy("watchValue", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->validateVersion(parameters->version);
															#line 3646 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(parameters->version != latestVersion);
															#line 3648 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 15299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WatchValueActorState();
		static_cast<WatchValueActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 3649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<KeyRangeLocationInfo> __when_expr_0 = getKeyLocation(cx, parameters->tenant.name, parameters->key, &StorageServerInterface::watchValue, parameters->spanID, parameters->debugID, parameters->useProvisionalProxies, Reverse::False, parameters->version);
															#line 3649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 15331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<WatchValueActor*>(this)->actor_wait_state = 1;
															#line 3649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >*>(static_cast<WatchValueActor*>(this)));
															#line 15336 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		try {
															#line 3660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			watchValueID = Optional<UID>();
															#line 3661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (parameters->debugID.present())
															#line 15348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3662 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				watchValueID = nondeterministicRandom()->randomUniqueID();
															#line 3664 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addAttach( "WatchValueAttachID", parameters->debugID.get().first(), watchValueID.get().first());
															#line 3666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("WatchValueDebug", watchValueID.get().first(), "NativeAPI.watchValue.Before");
															#line 15356 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3670 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			resp = WatchValueReply();
															#line 3672 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<WatchValueReply> __when_expr_1 = loadBalance(cx.getPtr(), locationInfo.locations, &StorageServerInterface::watchValue, WatchValueRequest(span.context, parameters->tenant, parameters->key, parameters->value, ver, cx->sampleReadTags() ? parameters->tags : Optional<TagSet>(), watchValueID), TaskPriority::DefaultPromiseEndpoint);
															#line 3671 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 15364 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
															#line 3686 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = cx->connectionRecord ? cx->connectionRecord->onChange() : Never();
															#line 15368 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont1when2(__when_expr_2.get(), loopDepth); };
			static_cast<WatchValueActor*>(this)->actor_wait_state = 2;
															#line 3672 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 1, WatchValueReply >*>(static_cast<WatchValueActor*>(this)));
															#line 3686 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 2, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15375 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(KeyRangeLocationInfo const& __locationInfo,int loopDepth) 
	{
															#line 3649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locationInfo = __locationInfo;
															#line 15390 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(KeyRangeLocationInfo && __locationInfo,int loopDepth) 
	{
		locationInfo = std::move(__locationInfo);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed)
															#line 15464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->invalidateCache(locationInfo.tenantEntry.prefix, parameters->key);
															#line 3708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_5 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, parameters->taskID);
															#line 3708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 15472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_5.get(), loopDepth); };
				static_cast<WatchValueActor*>(this)->actor_wait_state = 5;
															#line 3708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 5, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15477 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 3709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 15484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 3710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(parameters->tenant.name.present());
															#line 3711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					cx->invalidateCachedTenant(parameters->tenant.name.get());
															#line 3712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_6 = delay(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, parameters->taskID);
															#line 3712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 15494 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when2(__when_expr_6.get(), loopDepth); };
					static_cast<WatchValueActor*>(this)->actor_wait_state = 6;
															#line 3712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 6, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15499 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 3713 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (e.code() == error_code_watch_cancelled || e.code() == error_code_process_behind)
															#line 15506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 3715 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						TEST(e.code() == error_code_watch_cancelled);
															#line 3716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						TEST(e.code() == error_code_process_behind);
															#line 3718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						StrictFuture<Void> __when_expr_7 = delay(CLIENT_KNOBS->WATCH_POLLING_TIME, parameters->taskID);
															#line 3718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 15516 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
						if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when3(__when_expr_7.get(), loopDepth); };
						static_cast<WatchValueActor*>(this)->actor_wait_state = 7;
															#line 3718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 7, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
						loopDepth = 0;
					}
					else
					{
															#line 3719 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						if (e.code() == error_code_timed_out)
															#line 15528 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
						{
															#line 3721 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							TEST(true);
															#line 3722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							StrictFuture<Void> __when_expr_8 = delay(CLIENT_KNOBS->FUTURE_VERSION_RETRY_DELAY, parameters->taskID);
															#line 3722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 15536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
							if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1Catch1(__when_expr_8.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when4(__when_expr_8.get(), loopDepth); };
							static_cast<WatchValueActor*>(this)->actor_wait_state = 8;
															#line 3722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 8, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
							loopDepth = 0;
						}
						else
						{
															#line 3724 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							err = e;
															#line 3725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							StrictFuture<Void> __when_expr_9 = delay(CLIENT_KNOBS->FUTURE_VERSION_RETRY_DELAY, parameters->taskID);
															#line 3725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 15552 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
							if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1Catch1(__when_expr_9.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when5(__when_expr_9.get(), loopDepth); };
							static_cast<WatchValueActor*>(this)->actor_wait_state = 9;
															#line 3725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 9, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15557 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
							loopDepth = 0;
						}
					}
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
															#line 3690 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (watchValueID.present())
															#line 15576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3691 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent("WatchValueDebug", watchValueID.get().first(), "NativeAPI.watchValue.After");
															#line 15580 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Version> __when_expr_4 = waitForCommittedVersion(cx, resp.version, span.context);
															#line 3697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 15586 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1cont1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_4.get(), loopDepth); };
		static_cast<WatchValueActor*>(this)->actor_wait_state = 4;
															#line 3697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 4, Version >*>(static_cast<WatchValueActor*>(this)));
															#line 15591 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(WatchValueReply const& r,int loopDepth) 
	{
															#line 3684 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resp = r;
															#line 15600 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(WatchValueReply && r,int loopDepth) 
	{
															#line 3684 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resp = r;
															#line 15609 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void const& _,int loopDepth) 
	{
															#line 3687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = Never();
															#line 3687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 15620 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1cont1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont1when2when1(__when_expr_3.get(), loopDepth); };
		static_cast<WatchValueActor*>(this)->actor_wait_state = 3;
															#line 3687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 3, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void && _,int loopDepth) 
	{
															#line 3687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = Never();
															#line 3687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchValueActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 15636 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1cont1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont1when2when1(__when_expr_3.get(), loopDepth); };
		static_cast<WatchValueActor*>(this)->actor_wait_state = 3;
															#line 3687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WatchValueActor, 3, Void >*>(static_cast<WatchValueActor*>(this)));
															#line 15641 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 1, WatchValueReply >::remove();
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 1, WatchValueReply >*,WatchValueReply const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 1, WatchValueReply >*,WatchValueReply && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 1, WatchValueReply >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont1when2cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1when2cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1when2cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1when2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1when2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont5(Version const& v,int loopDepth) 
	{
															#line 3701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v - resp.version < 50000000)
															#line 15822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WatchValueActor*>(this)->SAV<Version>::futures) { (void)(resp.version); this->~WatchValueActorState(); static_cast<WatchValueActor*>(this)->destroy(); return 0; }
															#line 15826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WatchValueActor*>(this)->SAV< Version >::value()) Version(resp.version);
			this->~WatchValueActorState();
			static_cast<WatchValueActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ver = v;
															#line 15834 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont5(Version && v,int loopDepth) 
	{
															#line 3701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v - resp.version < 50000000)
															#line 15843 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WatchValueActor*>(this)->SAV<Version>::futures) { (void)(resp.version); this->~WatchValueActorState(); static_cast<WatchValueActor*>(this)->destroy(); return 0; }
															#line 15847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WatchValueActor*>(this)->SAV< Version >::value()) Version(resp.version);
			this->~WatchValueActorState();
			static_cast<WatchValueActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ver = v;
															#line 15855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Version const& v,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(v, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Version && v,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 4, Version >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 4, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 4, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 4, Version >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1loopBody1cont9(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1loopBody1cont1Catch1cont3(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1loopBody1cont1Catch1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1loopBody1cont1Catch1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1loopBody1cont1Catch1cont5(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont6(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont6(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1loopBody1cont1Catch1when3(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1loopBody1cont1Catch1when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1loopBody1cont1Catch1cont7(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont8(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont8(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 8, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 8, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose8();
		try {
			a_body1loopBody1cont1Catch1when4(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 8, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose8();
		try {
			a_body1loopBody1cont1Catch1when4(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 8, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 8);

	}
	int a_body1loopBody1cont1Catch1cont9(Void const& _,int loopDepth) 
	{
															#line 3726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 1));
															#line 16264 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont9(Void && _,int loopDepth) 
	{
															#line 3726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 1));
															#line 16272 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<WatchValueActor*>(this)->actor_wait_state > 0) static_cast<WatchValueActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueActor*>(this)->ActorCallback< WatchValueActor, 9, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 9, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose9();
		try {
			a_body1loopBody1cont1Catch1when5(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_fire(ActorCallback< WatchValueActor, 9, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose9();
		try {
			a_body1loopBody1cont1Catch1when5(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_error(ActorCallback< WatchValueActor, 9, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose9();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), 9);

	}
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<const WatchParameters> parameters;
															#line 3643 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 3644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version ver;
															#line 3649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeLocationInfo locationInfo;
															#line 3660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> watchValueID;
															#line 3670 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchValueReply resp;
															#line 3724 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Error err;
															#line 16355 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via watchValue()
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchValueActor final : public Actor<Version>, public ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >, public ActorCallback< WatchValueActor, 1, WatchValueReply >, public ActorCallback< WatchValueActor, 2, Void >, public ActorCallback< WatchValueActor, 3, Void >, public ActorCallback< WatchValueActor, 4, Version >, public ActorCallback< WatchValueActor, 5, Void >, public ActorCallback< WatchValueActor, 6, Void >, public ActorCallback< WatchValueActor, 7, Void >, public ActorCallback< WatchValueActor, 8, Void >, public ActorCallback< WatchValueActor, 9, Void >, public FastAllocated<WatchValueActor>, public WatchValueActorState<WatchValueActor> {
															#line 16360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WatchValueActor>::operator new;
	using FastAllocated<WatchValueActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Version>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >;
friend struct ActorCallback< WatchValueActor, 1, WatchValueReply >;
friend struct ActorCallback< WatchValueActor, 2, Void >;
friend struct ActorCallback< WatchValueActor, 3, Void >;
friend struct ActorCallback< WatchValueActor, 4, Version >;
friend struct ActorCallback< WatchValueActor, 5, Void >;
friend struct ActorCallback< WatchValueActor, 6, Void >;
friend struct ActorCallback< WatchValueActor, 7, Void >;
friend struct ActorCallback< WatchValueActor, 8, Void >;
friend struct ActorCallback< WatchValueActor, 9, Void >;
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchValueActor(Database const& cx,Reference<const WatchParameters> const& parameters) 
															#line 16380 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Version>(),
		   WatchValueActorState<WatchValueActor>(cx, parameters)
	{
		fdb_probe_actor_enter("watchValue", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("watchValue");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("watchValue", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WatchValueActor, 0, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WatchValueActor, 1, WatchValueReply >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WatchValueActor, 3, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< WatchValueActor, 4, Version >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< WatchValueActor, 5, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< WatchValueActor, 6, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< WatchValueActor, 7, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< WatchValueActor, 8, Void >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< WatchValueActor, 9, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Version> watchValue( Database const& cx, Reference<const WatchParameters> const& parameters ) {
															#line 3642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Version>(new WatchValueActor(cx, parameters));
															#line 16416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 16421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via watchStorageServerResp()
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WatchStorageServerRespActor>
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchStorageServerRespActorState {
															#line 16428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchStorageServerRespActorState(int64_t const& tenantId,Key const& key,Database const& cx) 
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : tenantId(tenantId),
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   key(key),
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(cx)
															#line 16439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("watchStorageServerResp", reinterpret_cast<unsigned long>(this));

	}
	~WatchStorageServerRespActorState() 
	{
		fdb_probe_actor_destroy("watchStorageServerResp", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 16454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WatchStorageServerRespActorState();
		static_cast<WatchStorageServerRespActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 3735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			metadata = cx->getWatchMetadata(tenantId, key);
															#line 3736 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!metadata.isValid())
															#line 16487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<WatchStorageServerRespActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchStorageServerRespActorState(); static_cast<WatchStorageServerRespActor*>(this)->destroy(); return 0; }
															#line 16491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<WatchStorageServerRespActor*>(this)->SAV< Void >::value()) Void(Void());
				this->~WatchStorageServerRespActorState();
				static_cast<WatchStorageServerRespActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 3739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Version> __when_expr_0 = watchValue(cx, metadata->parameters);
															#line 3739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WatchStorageServerRespActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16501 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WatchStorageServerRespActor*>(this)->actor_wait_state = 1;
															#line 3739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WatchStorageServerRespActor, 0, Version >*>(static_cast<WatchStorageServerRespActor*>(this)));
															#line 16506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_operation_cancelled)
															#line 16528 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 16532 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3765 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Reference<WatchMetadata> metadata = cx->getWatchMetadata(tenantId, key);
															#line 3766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!metadata.isValid())
															#line 16538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<WatchStorageServerRespActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchStorageServerRespActorState(); static_cast<WatchStorageServerRespActor*>(this)->destroy(); return 0; }
															#line 16542 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<WatchStorageServerRespActor*>(this)->SAV< Void >::value()) Void(Void());
				this->~WatchStorageServerRespActorState();
				static_cast<WatchStorageServerRespActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
			else
			{
															#line 3768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (metadata->watchPromise.getFutureReferenceCount() == 1)
															#line 16552 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 3769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					cx->deleteWatchMetadata(tenantId, key);
															#line 3770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!static_cast<WatchStorageServerRespActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchStorageServerRespActorState(); static_cast<WatchStorageServerRespActor*>(this)->destroy(); return 0; }
															#line 16558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					new (&static_cast<WatchStorageServerRespActor*>(this)->SAV< Void >::value()) Void(Void());
					this->~WatchStorageServerRespActorState();
					static_cast<WatchStorageServerRespActor*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
				else
				{
															#line 3771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (e.code() == error_code_future_version)
															#line 16568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
						return a_body1loopHead1(loopDepth); // continue
					}
				}
			}
															#line 3774 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->deleteWatchMetadata(tenantId, key);
															#line 3775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			metadata->watchPromise.sendError(e);
															#line 3776 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 16580 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Version const& watchVersion,int loopDepth) 
	{
															#line 3741 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		metadata = cx->getWatchMetadata(tenantId, key);
															#line 3742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!metadata.isValid())
															#line 16596 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3743 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WatchStorageServerRespActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchStorageServerRespActorState(); static_cast<WatchStorageServerRespActor*>(this)->destroy(); return 0; }
															#line 16600 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WatchStorageServerRespActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~WatchStorageServerRespActorState();
			static_cast<WatchStorageServerRespActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (watchVersion >= metadata->parameters->version)
															#line 16608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->deleteWatchMetadata(tenantId, key);
															#line 3748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (metadata->watchPromise.canBeSet())
															#line 16614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				metadata->watchPromise.send(watchVersion);
															#line 16618 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		else
		{
															#line 3753 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 3756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (metadata->watchPromise.getFutureReferenceCount() == 1)
															#line 16627 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->deleteWatchMetadata(tenantId, key);
															#line 16631 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2(Version && watchVersion,int loopDepth) 
	{
															#line 3741 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		metadata = cx->getWatchMetadata(tenantId, key);
															#line 3742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!metadata.isValid())
															#line 16644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3743 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WatchStorageServerRespActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchStorageServerRespActorState(); static_cast<WatchStorageServerRespActor*>(this)->destroy(); return 0; }
															#line 16648 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WatchStorageServerRespActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~WatchStorageServerRespActorState();
			static_cast<WatchStorageServerRespActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (watchVersion >= metadata->parameters->version)
															#line 16656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->deleteWatchMetadata(tenantId, key);
															#line 3748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (metadata->watchPromise.canBeSet())
															#line 16662 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				metadata->watchPromise.send(watchVersion);
															#line 16666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		else
		{
															#line 3753 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 3756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (metadata->watchPromise.getFutureReferenceCount() == 1)
															#line 16675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->deleteWatchMetadata(tenantId, key);
															#line 16679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Version const& watchVersion,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(watchVersion, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Version && watchVersion,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(watchVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WatchStorageServerRespActor*>(this)->actor_wait_state > 0) static_cast<WatchStorageServerRespActor*>(this)->actor_wait_state = 0;
		static_cast<WatchStorageServerRespActor*>(this)->ActorCallback< WatchStorageServerRespActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< WatchStorageServerRespActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("watchStorageServerResp", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchStorageServerResp", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WatchStorageServerRespActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("watchStorageServerResp", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchStorageServerResp", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WatchStorageServerRespActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("watchStorageServerResp", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchStorageServerResp", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont10(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int64_t tenantId;
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key key;
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 3735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<WatchMetadata> metadata;
															#line 16770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via watchStorageServerResp()
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchStorageServerRespActor final : public Actor<Void>, public ActorCallback< WatchStorageServerRespActor, 0, Version >, public FastAllocated<WatchStorageServerRespActor>, public WatchStorageServerRespActorState<WatchStorageServerRespActor> {
															#line 16775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WatchStorageServerRespActor>::operator new;
	using FastAllocated<WatchStorageServerRespActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WatchStorageServerRespActor, 0, Version >;
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchStorageServerRespActor(int64_t const& tenantId,Key const& key,Database const& cx) 
															#line 16786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   WatchStorageServerRespActorState<WatchStorageServerRespActor>(tenantId, key, cx)
	{
		fdb_probe_actor_enter("watchStorageServerResp", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("watchStorageServerResp");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("watchStorageServerResp", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WatchStorageServerRespActor, 0, Version >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> watchStorageServerResp( int64_t const& tenantId, Key const& key, Database const& cx ) {
															#line 3732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new WatchStorageServerRespActor(tenantId, key, cx));
															#line 16814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3780 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 16819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via sameVersionDiffValue()
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SameVersionDiffValueActor>
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SameVersionDiffValueActorState {
															#line 16826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SameVersionDiffValueActorState(Database const& cx,Reference<WatchParameters> const& parameters) 
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   parameters(parameters),
															#line 3782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(cx, parameters->tenant.name)
															#line 16837 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("sameVersionDiffValue", reinterpret_cast<unsigned long>(this));

	}
	~SameVersionDiffValueActorState() 
	{
		fdb_probe_actor_destroy("sameVersionDiffValue", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 16852 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SameVersionDiffValueActorState();
		static_cast<SameVersionDiffValueActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 3785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!parameters->tenant.name.present())
															#line 16883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr.setOption(FDBTransactionOptions::READ_SYSTEM_KEYS);
															#line 16887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = tr.get(parameters->key);
															#line 3789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state = 1;
															#line 3789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >*>(static_cast<SameVersionDiffValueActor*>(this)));
															#line 16898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr.onError(e);
															#line 3817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 16922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state = 3;
															#line 3817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< SameVersionDiffValueActor, 2, Void >*>(static_cast<SameVersionDiffValueActor*>(this)));
															#line 16927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
															#line 3790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Reference<WatchMetadata> metadata = cx->getWatchMetadata(parameters->tenant.tenantId, parameters->key);
															#line 3793 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (metadata.isValid() && valSS != metadata->parameters->value)
															#line 16944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3794 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->deleteWatchMetadata(parameters->tenant.tenantId, parameters->key);
															#line 3796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			metadata->watchPromise.send(parameters->version);
															#line 3797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			metadata->watchFutureSS.cancel();
															#line 16952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3801 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (valSS == parameters->value && tr.getTransactionState()->tenantId == parameters->tenant.tenantId)
															#line 16956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			metadata = makeReference<WatchMetadata>(parameters);
															#line 3803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->setWatchMetadata(metadata);
															#line 3805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			metadata->watchFutureSS = watchStorageServerResp(parameters->tenant.tenantId, parameters->key, cx);
															#line 16964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 3809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (valSS != parameters->value)
															#line 16968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 3810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<SameVersionDiffValueActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SameVersionDiffValueActorState(); static_cast<SameVersionDiffValueActor*>(this)->destroy(); return 0; }
															#line 16972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<SameVersionDiffValueActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~SameVersionDiffValueActorState();
			static_cast<SameVersionDiffValueActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = success(metadata->watchPromise.getFuture());
															#line 3813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16982 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state = 2;
															#line 3813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SameVersionDiffValueActor, 1, Void >*>(static_cast<SameVersionDiffValueActor*>(this)));
															#line 16987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> const& __valSS,int loopDepth) 
	{
															#line 3789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		valSS = __valSS;
															#line 16996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> && __valSS,int loopDepth) 
	{
		valSS = std::move(__valSS);
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state > 0) static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state = 0;
		static_cast<SameVersionDiffValueActor*>(this)->ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont4(Void const& _,int loopDepth) 
	{
															#line 3815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SameVersionDiffValueActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SameVersionDiffValueActorState(); static_cast<SameVersionDiffValueActor*>(this)->destroy(); return 0; }
															#line 17063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SameVersionDiffValueActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SameVersionDiffValueActorState();
		static_cast<SameVersionDiffValueActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void && _,int loopDepth) 
	{
															#line 3815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SameVersionDiffValueActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SameVersionDiffValueActorState(); static_cast<SameVersionDiffValueActor*>(this)->destroy(); return 0; }
															#line 17075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SameVersionDiffValueActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SameVersionDiffValueActorState();
		static_cast<SameVersionDiffValueActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state > 0) static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state = 0;
		static_cast<SameVersionDiffValueActor*>(this)->ActorCallback< SameVersionDiffValueActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SameVersionDiffValueActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SameVersionDiffValueActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SameVersionDiffValueActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state > 0) static_cast<SameVersionDiffValueActor*>(this)->actor_wait_state = 0;
		static_cast<SameVersionDiffValueActor*>(this)->ActorCallback< SameVersionDiffValueActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SameVersionDiffValueActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< SameVersionDiffValueActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< SameVersionDiffValueActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<WatchParameters> parameters;
															#line 3782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadYourWritesTransaction tr;
															#line 3789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<Value> valSS;
															#line 17229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via sameVersionDiffValue()
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SameVersionDiffValueActor final : public Actor<Void>, public ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >, public ActorCallback< SameVersionDiffValueActor, 1, Void >, public ActorCallback< SameVersionDiffValueActor, 2, Void >, public FastAllocated<SameVersionDiffValueActor>, public SameVersionDiffValueActorState<SameVersionDiffValueActor> {
															#line 17234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SameVersionDiffValueActor>::operator new;
	using FastAllocated<SameVersionDiffValueActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >;
friend struct ActorCallback< SameVersionDiffValueActor, 1, Void >;
friend struct ActorCallback< SameVersionDiffValueActor, 2, Void >;
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SameVersionDiffValueActor(Database const& cx,Reference<WatchParameters> const& parameters) 
															#line 17247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   SameVersionDiffValueActorState<SameVersionDiffValueActor>(cx, parameters)
	{
		fdb_probe_actor_enter("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("sameVersionDiffValue");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("sameVersionDiffValue", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SameVersionDiffValueActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SameVersionDiffValueActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< SameVersionDiffValueActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> sameVersionDiffValue( Database const& cx, Reference<WatchParameters> const& parameters ) {
															#line 3781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new SameVersionDiffValueActor(cx, parameters));
															#line 17277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3821 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> getWatchFuture(Database cx, Reference<WatchParameters> parameters) {
	Reference<WatchMetadata> metadata = cx->getWatchMetadata(parameters->tenant.tenantId, parameters->key);

	// case 1: key not in map
	if (!metadata.isValid()) {
		metadata = makeReference<WatchMetadata>(parameters);
		cx->setWatchMetadata(metadata);

		metadata->watchFutureSS = watchStorageServerResp(parameters->tenant.tenantId, parameters->key, cx);
		return success(metadata->watchPromise.getFuture());
	}
	// case 2: val_1 == val_2 (received watch with same value as key already in the map so just update)
	else if (metadata->parameters->value == parameters->value) {
		if (parameters->version > metadata->parameters->version) {
			metadata->parameters = parameters;
		}

		return success(metadata->watchPromise.getFuture());
	}
	// case 3: val_1 != val_2 && version_2 > version_1 (received watch with different value and a higher version so
	// recreate in SS)
	else if (parameters->version > metadata->parameters->version) {
		TEST(true); // Setting a watch that has a different value than the one in the map but a higher version (newer)
		cx->deleteWatchMetadata(parameters->tenant.tenantId, parameters->key);

		metadata->watchPromise.send(parameters->version);
		metadata->watchFutureSS.cancel();

		metadata = makeReference<WatchMetadata>(parameters);
		cx->setWatchMetadata(metadata);

		metadata->watchFutureSS = watchStorageServerResp(parameters->tenant.tenantId, parameters->key, cx);

		return success(metadata->watchPromise.getFuture());
	}
	// case 5: val_1 != val_2 && version_1 == version_2 (received watch with different value but same version)
	else if (metadata->parameters->version == parameters->version) {
		TEST(true); // Setting a watch which has a different value than the one in the map but the same version
		return sameVersionDiffValue(cx, parameters);
	}
	TEST(true); // Setting a watch which has a different value than the one in the map but a lower version (older)

	// case 4: val_1 != val_2 && version_2 < version_1
	return Void();
}

															#line 17328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via watchValueMap()
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WatchValueMapActor>
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchValueMapActorState {
															#line 17335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchValueMapActorState(Future<Version> const& version,TenantInfo const& tenant,Key const& key,Optional<Value> const& value,Database const& cx,TagSet const& tags,SpanID const& spanID,TaskPriority const& taskID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies) 
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : version(version),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tenant(tenant),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   key(key),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   value(value),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(cx),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tags(tags),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   spanID(spanID),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   taskID(taskID),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugID(debugID),
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useProvisionalProxies(useProvisionalProxies)
															#line 17360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("watchValueMap", reinterpret_cast<unsigned long>(this));

	}
	~WatchValueMapActorState() 
	{
		fdb_probe_actor_destroy("watchValueMap", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Version> __when_expr_0 = version;
															#line 3878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WatchValueMapActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17377 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WatchValueMapActor*>(this)->actor_wait_state = 1;
															#line 3878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WatchValueMapActor, 0, Version >*>(static_cast<WatchValueMapActor*>(this)));
															#line 17382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WatchValueMapActorState();
		static_cast<WatchValueMapActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 3880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = getWatchFuture( cx, makeReference<WatchParameters>(tenant, key, value, ver, tags, spanID, taskID, debugID, useProvisionalProxies));
															#line 3880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchValueMapActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<WatchValueMapActor*>(this)->actor_wait_state = 2;
															#line 3880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WatchValueMapActor, 1, Void >*>(static_cast<WatchValueMapActor*>(this)));
															#line 17412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Version const& __ver,int loopDepth) 
	{
															#line 3878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ver = __ver;
															#line 17421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && __ver,int loopDepth) 
	{
		ver = std::move(__ver);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WatchValueMapActor*>(this)->actor_wait_state > 0) static_cast<WatchValueMapActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueMapActor*>(this)->ActorCallback< WatchValueMapActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueMapActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("watchValueMap", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValueMap", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WatchValueMapActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("watchValueMap", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValueMap", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WatchValueMapActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("watchValueMap", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValueMap", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 3884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WatchValueMapActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchValueMapActorState(); static_cast<WatchValueMapActor*>(this)->destroy(); return 0; }
															#line 17488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WatchValueMapActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~WatchValueMapActorState();
		static_cast<WatchValueMapActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 3884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WatchValueMapActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchValueMapActorState(); static_cast<WatchValueMapActor*>(this)->destroy(); return 0; }
															#line 17500 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WatchValueMapActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~WatchValueMapActorState();
		static_cast<WatchValueMapActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WatchValueMapActor*>(this)->actor_wait_state > 0) static_cast<WatchValueMapActor*>(this)->actor_wait_state = 0;
		static_cast<WatchValueMapActor*>(this)->ActorCallback< WatchValueMapActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchValueMapActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watchValueMap", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValueMap", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WatchValueMapActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watchValueMap", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValueMap", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WatchValueMapActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watchValueMap", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watchValueMap", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> version;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TenantInfo tenant;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key key;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<Value> value;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TagSet tags;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID spanID;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TaskPriority taskID;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> debugID;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseProvisionalProxies useProvisionalProxies;
															#line 3878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version ver;
															#line 17593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via watchValueMap()
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchValueMapActor final : public Actor<Void>, public ActorCallback< WatchValueMapActor, 0, Version >, public ActorCallback< WatchValueMapActor, 1, Void >, public FastAllocated<WatchValueMapActor>, public WatchValueMapActorState<WatchValueMapActor> {
															#line 17598 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WatchValueMapActor>::operator new;
	using FastAllocated<WatchValueMapActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WatchValueMapActor, 0, Version >;
friend struct ActorCallback< WatchValueMapActor, 1, Void >;
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchValueMapActor(Future<Version> const& version,TenantInfo const& tenant,Key const& key,Optional<Value> const& value,Database const& cx,TagSet const& tags,SpanID const& spanID,TaskPriority const& taskID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies) 
															#line 17610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   WatchValueMapActorState<WatchValueMapActor>(version, tenant, key, value, cx, tags, spanID, taskID, debugID, useProvisionalProxies)
	{
		fdb_probe_actor_enter("watchValueMap", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("watchValueMap");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("watchValueMap", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WatchValueMapActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WatchValueMapActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> watchValueMap( Future<Version> const& version, TenantInfo const& tenant, Key const& key, Optional<Value> const& value, Database const& cx, TagSet const& tags, SpanID const& spanID, TaskPriority const& taskID, Optional<UID> const& debugID, UseProvisionalProxies const& useProvisionalProxies ) {
															#line 3868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new WatchValueMapActor(version, tenant, key, value, cx, tags, spanID, taskID, debugID, useProvisionalProxies));
															#line 17639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 3886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

template <class GetKeyValuesFamilyRequest>
void transformRangeLimits(GetRangeLimits limits, Reverse reverse, GetKeyValuesFamilyRequest& req) {
	if (limits.bytes != 0) {
		if (!limits.hasRowLimit())
			req.limit = CLIENT_KNOBS->REPLY_BYTE_LIMIT; // Can't get more than this many rows anyway
		else
			req.limit = std::min(CLIENT_KNOBS->REPLY_BYTE_LIMIT, limits.rows);

		if (reverse)
			req.limit *= -1;

		if (!limits.hasByteLimit())
			req.limitBytes = CLIENT_KNOBS->REPLY_BYTE_LIMIT;
		else
			req.limitBytes = std::min(CLIENT_KNOBS->REPLY_BYTE_LIMIT, limits.bytes);
	} else {
		req.limitBytes = CLIENT_KNOBS->REPLY_BYTE_LIMIT;
		req.limit = reverse ? -limits.minRows : limits.minRows;
	}
}

template <class GetKeyValuesFamilyRequest>
RequestStream<GetKeyValuesFamilyRequest> StorageServerInterface::*getRangeRequestStream() {
	if constexpr (std::is_same<GetKeyValuesFamilyRequest, GetKeyValuesRequest>::value) {
		return &StorageServerInterface::getKeyValues;
	} else if (std::is_same<GetKeyValuesFamilyRequest, GetMappedKeyValuesRequest>::value) {
		return &StorageServerInterface::getMappedKeyValues;
	} else {
		UNREACHABLE();
	}
}

															#line 17676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getExactRange()
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily, class GetExactRangeActor>
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetExactRangeActorState {
															#line 17683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetExactRangeActorState(Reference<TransactionState> const& trState,Version const& version,KeyRange const& keys,Key const& mapper,GetRangeLimits const& limits,Reverse const& reverse,UseTenant const& useTenant) 
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   mapper(mapper),
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limits(limits),
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   reverse(reverse),
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useTenant(useTenant),
															#line 3927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   output(),
															#line 3928 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:getExactRange"_loc, trState->spanID)
															#line 17706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getExactRange", reinterpret_cast<unsigned long>(this));

	}
	~GetExactRangeActorState() 
	{
		fdb_probe_actor_destroy("getExactRange", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (useTenant && trState->tenant().present())
															#line 17721 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				span.addTag("tenant"_sr, trState->tenant().get());
															#line 17725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 17729 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetExactRangeActorState();
		static_cast<GetExactRangeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 3936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(trState, keys, CLIENT_KNOBS->GET_RANGE_SHARD_LIMIT, reverse, getRangeRequestStream<GetKeyValuesFamilyRequest>(), useTenant, version);
															#line 3936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetExactRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<GetExactRangeActor*>(this)->actor_wait_state = 1;
															#line 3936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetExactRangeActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetExactRangeActor*>(this)));
															#line 17766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 3944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(locations.size());
															#line 3945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shard = 0;
															#line 3946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 17779 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 3936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 17788 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetExactRangeActor*>(this)->actor_wait_state > 0) static_cast<GetExactRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetExactRangeActor*>(this)->ActorCallback< GetExactRangeActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetExactRangeActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1(int loopDepth) 
	{
															#line 3947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		const KeyRangeRef& range = locations[shard].range;
															#line 3949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		GetKeyValuesFamilyRequest req;
															#line 3950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.mapper = mapper;
															#line 3951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.arena.dependsOn(mapper.arena());
															#line 3953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.tenantInfo = useTenant ? trState->getTenantInfo() : TenantInfo();
															#line 3954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.version = version;
															#line 3955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.begin = firstGreaterOrEqual(range.begin);
															#line 3956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.end = firstGreaterOrEqual(range.end);
															#line 3957 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.spanContext = span.context;
															#line 3958 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->getLatestCommitVersions( locations[shard].locations, req.version, trState, req.ssLatestCommitVersions);
															#line 3962 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.arena.dependsOn(locations[shard].range.arena());
															#line 3964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		transformRangeLimits(limits, reverse, req);
															#line 3965 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(req.limitBytes > 0 && req.limit != 0 && req.limit < 0 == reverse);
															#line 3968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.tags = trState->cx->sampleReadTags() ? trState->options.readTags : Optional<TagSet>();
															#line 3969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.debugID = trState->debugID;
															#line 17896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 3972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->debugID.present())
															#line 17900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 3973 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent( "TransactionDebug", trState->debugID.get().first(), "NativeAPI.getExactRange.Before");
															#line 17904 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 3984 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReads;
															#line 3985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			rep = GetKeyValuesFamilyReply();
															#line 17910 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			try {
															#line 3988 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_1 = trState->cx->connectionFileChanged();
															#line 3987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetExactRangeActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1Catch2(actor_cancelled(), loopDepth);
															#line 17916 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1loopBody1Catch2(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
															#line 3991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<GetKeyValuesFamilyReply> __when_expr_2 = loadBalance( trState->cx.getPtr(), locations[shard].locations, getRangeRequestStream<GetKeyValuesFamilyRequest>(), req, TaskPriority::DefaultPromiseEndpoint, AtMostOnce::False, trState->cx->enableLocalityLoadBalance ? &trState->cx->queueModel : nullptr);
															#line 17920 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont1loopBody1Catch2(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1when2(__when_expr_2.get(), loopDepth); };
				static_cast<GetExactRangeActor*>(this)->actor_wait_state = 2;
															#line 3988 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetExactRangeActor, 1, Void >*>(static_cast<GetExactRangeActor*>(this)));
															#line 3991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetExactRangeActor, 2, GetKeyValuesFamilyReply >*>(static_cast<GetExactRangeActor*>(this)));
															#line 17927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont1loopBody1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont1loopBody1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 4083 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed)
															#line 17968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				const KeyRangeRef& range = locations[shard].range;
															#line 4086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (reverse)
															#line 17974 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					keys = KeyRangeRef(keys.begin, range.end);
															#line 17978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 4089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					keys = KeyRangeRef(range.begin, keys.end);
															#line 17984 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 4091 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->invalidateCache(locations[0].tenantEntry.prefix, keys);
															#line 4093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_3 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, trState->taskID);
															#line 4093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetExactRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 17992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1cont1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
				static_cast<GetExactRangeActor*>(this)->actor_wait_state = 3;
															#line 4093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetExactRangeActor, 3, Void >*>(static_cast<GetExactRangeActor*>(this)));
															#line 17997 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 4095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 18004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(useTenant && trState->tenant().present());
															#line 4097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->cx->invalidateCachedTenant(trState->tenant().get());
															#line 4098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_4 = delay(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, trState->taskID);
															#line 4098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<GetExactRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 18014 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1cont1loopBody1Catch1when2(__when_expr_4.get(), loopDepth); };
					static_cast<GetExactRangeActor*>(this)->actor_wait_state = 4;
															#line 4098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetExactRangeActor, 4, Void >*>(static_cast<GetExactRangeActor*>(this)));
															#line 18019 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 4101 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TraceEvent(SevInfo, "GetExactRangeError") .error(e) .detail("Tenant", trState->tenant()) .detail("ShardBegin", locations[shard].range.begin) .detail("ShardEnd", locations[shard].range.end);
															#line 4106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch1(e, std::max(0, loopDepth - 2));
															#line 18028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2(int loopDepth) 
	{
															#line 4007 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->debugID.present())
															#line 18044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4008 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", trState->debugID.get().first(), "NativeAPI.getExactRange.After");
															#line 18048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4010 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		output.arena().dependsOn(rep.arena);
															#line 4011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		output.append(output.arena(), rep.data.begin(), rep.data.size());
															#line 4013 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (limits.hasRowLimit() && rep.data.size() > limits.rows)
															#line 18056 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4014 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "GetExactRangeTooManyRows") .detail("RowLimit", limits.rows) .detail("DeliveredRows", output.size());
															#line 4017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(false);
															#line 18062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4019 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		limits.decrement(rep.data);
															#line 4021 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (limits.isReached())
															#line 18068 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.more = true;
															#line 4023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetExactRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(output); this->~GetExactRangeActorState(); static_cast<GetExactRangeActor*>(this)->destroy(); return 0; }
															#line 18074 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetExactRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(std::move(output)); // state_var_RVO
			this->~GetExactRangeActorState();
			static_cast<GetExactRangeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 4026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool more = rep.more;
															#line 4028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (reverse && more && rep.data.size() > 0 && output[output.size() - 1].key == locations[shard].range.begin)
															#line 18084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4030 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			more = false;
															#line 18088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4032 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (more)
															#line 18092 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!rep.data.size())
															#line 18096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "GetExactRangeError") .detail("Reason", "More data indicated but no rows present") .detail("LimitBytes", limits.bytes) .detail("LimitRows", limits.rows) .detail("OutputSize", output.size()) .detail("OutputBytes", output.expectedSize()) .detail("BlockSize", rep.data.size()) .detail("BlockBytes", rep.data.expectedSize());
															#line 4042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ASSERT(false);
															#line 18102 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 4046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (reverse)
															#line 18108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				locations[shard].range = KeyRangeRef(locations[shard].range.begin, output[output.size() - 1].key);
															#line 18112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 4050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				locations[shard].range = KeyRangeRef(keyAfter(output[output.size() - 1].key), locations[shard].range.end);
															#line 18118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 4054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!more || locations[shard].range.empty())
															#line 18123 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4055 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 4056 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (shard == locations.size() - 1)
															#line 18129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				const KeyRangeRef& range = locations[shard].range;
															#line 4058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRef begin = reverse ? keys.begin : range.end;
															#line 4059 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRef end = reverse ? range.begin : keys.end;
															#line 4061 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (begin >= end)
															#line 18139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					output.more = false;
															#line 4063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!static_cast<GetExactRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(output); this->~GetExactRangeActorState(); static_cast<GetExactRangeActor*>(this)->destroy(); return 0; }
															#line 18145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					new (&static_cast<GetExactRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(std::move(output)); // state_var_RVO
					this->~GetExactRangeActorState();
					static_cast<GetExactRangeActor*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
															#line 4065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TEST(true);
															#line 4067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				keys = KeyRangeRef(begin, end);
															#line 18155 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break
			}
															#line 4071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++shard;
															#line 18160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (limits.hasSatisfiedMinRows() && output.size() > 0)
															#line 18164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4078 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.more = true;
															#line 4079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetExactRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(output); this->~GetExactRangeActorState(); static_cast<GetExactRangeActor*>(this)->destroy(); return 0; }
															#line 18170 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetExactRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(std::move(output)); // state_var_RVO
			this->~GetExactRangeActorState();
			static_cast<GetExactRangeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		loopDepth = a_body1loopBody1cont1loopBody1cont20(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch2(const Error& __current_error,int loopDepth=0) 
	{
		try {
															#line 4004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReadsCompleted;
															#line 4005 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1cont1loopBody1Catch1(__current_error, loopDepth);
															#line 18187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont4(int loopDepth) 
	{
															#line 4002 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionPhysicalReadsCompleted;
															#line 18201 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
															#line 3989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1loopBody1cont1loopBody1Catch2(transaction_too_old(), loopDepth);
															#line 18210 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(Void && _,int loopDepth) 
	{
															#line 3989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1loopBody1cont1loopBody1Catch2(transaction_too_old(), loopDepth);
															#line 18218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when2(GetKeyValuesFamilyReply const& _rep,int loopDepth) 
	{
															#line 3999 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 18226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when2(GetKeyValuesFamilyReply && _rep,int loopDepth) 
	{
															#line 3999 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 18235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetExactRangeActor*>(this)->actor_wait_state > 0) static_cast<GetExactRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetExactRangeActor*>(this)->ActorCallback< GetExactRangeActor, 1, Void >::remove();
		static_cast<GetExactRangeActor*>(this)->ActorCallback< GetExactRangeActor, 2, GetKeyValuesFamilyReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch2(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch2(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetExactRangeActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch2(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 2, GetKeyValuesFamilyReply >*,GetKeyValuesFamilyReply const& value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch2(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 2, GetKeyValuesFamilyReply >*,GetKeyValuesFamilyReply && value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch2(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetExactRangeActor, 2, GetKeyValuesFamilyReply >*,Error err) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch2(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont1loopBody1cont6(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont20(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1cont2(Void const& _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1cont2(Void && _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetExactRangeActor*>(this)->actor_wait_state > 0) static_cast<GetExactRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetExactRangeActor*>(this)->ActorCallback< GetExactRangeActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetExactRangeActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont1loopBody1Catch1cont7(Void const& _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1cont7(Void && _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetExactRangeActor*>(this)->actor_wait_state > 0) static_cast<GetExactRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetExactRangeActor*>(this)->ActorCallback< GetExactRangeActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1loopBody1Catch1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetExactRangeActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1loopBody1Catch1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetExactRangeActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key mapper;
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeLimits limits;
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reverse reverse;
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseTenant useTenant;
															#line 3927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RangeResultFamily output;
															#line 3928 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 3936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 3945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int shard;
															#line 3985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyValuesFamilyReply rep;
															#line 18537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getExactRange()
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily>
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetExactRangeActor final : public Actor<RangeResultFamily>, public ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, Void >, public ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, GetKeyValuesFamilyReply >, public ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, Void >, public ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 4, Void >, public FastAllocated<GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>, public GetExactRangeActorState<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily, GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>> {
															#line 18544 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>::operator new;
	using FastAllocated<GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<RangeResultFamily>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, Void >;
friend struct ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, GetKeyValuesFamilyReply >;
friend struct ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, Void >;
friend struct ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 4, Void >;
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetExactRangeActor(Reference<TransactionState> const& trState,Version const& version,KeyRange const& keys,Key const& mapper,GetRangeLimits const& limits,Reverse const& reverse,UseTenant const& useTenant) 
															#line 18559 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<RangeResultFamily>(),
		   GetExactRangeActorState<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily, GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>(trState, version, keys, mapper, limits, reverse, useTenant)
	{
		fdb_probe_actor_enter("getExactRange", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getExactRange");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getExactRange", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily>
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<RangeResultFamily> getExactRange( Reference<TransactionState> const& trState, Version const& version, KeyRange const& keys, Key const& mapper, GetRangeLimits const& limits, Reverse const& reverse, UseTenant const& useTenant ) {
															#line 3919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<RangeResultFamily>(new GetExactRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>(trState, version, keys, mapper, limits, reverse, useTenant));
															#line 18592 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 4112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Key> resolveKey(Reference<TransactionState> trState,
                       KeySelector const& key,
                       Version const& version,
                       UseTenant useTenant) {
	if (key.isFirstGreaterOrEqual())
		return Future<Key>(key.getKey());

	if (key.isFirstGreaterThan())
		return Future<Key>(keyAfter(key.getKey()));

	return getKey(trState, key, version, useTenant);
}

															#line 18610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getRangeFallback()
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily, class GetRangeFallbackActor>
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeFallbackActorState {
															#line 18617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeFallbackActorState(Reference<TransactionState> const& trState,Version const& version,KeySelector const& begin,KeySelector const& end,Key const& mapper,GetRangeLimits const& limits,Reverse const& reverse,UseTenant const& useTenant) 
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   mapper(mapper),
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limits(limits),
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   reverse(reverse),
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useTenant(useTenant)
															#line 18638 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getRangeFallback", reinterpret_cast<unsigned long>(this));

	}
	~GetRangeFallbackActorState() 
	{
		fdb_probe_actor_destroy("getRangeFallback", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 4135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (version == latestVersion)
															#line 18653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4136 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				transaction = Transaction(trState->cx);
															#line 4137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				transaction.setOption(FDBTransactionOptions::CAUSAL_READ_RISKY);
															#line 4138 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				transaction.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 4139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				transaction.setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE);
															#line 4140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Version> __when_expr_0 = transaction.getReadVersion();
															#line 4140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18667 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 1;
															#line 4140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetRangeFallbackActor, 0, Version >*>(static_cast<GetRangeFallbackActor*>(this)));
															#line 18672 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont1(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetRangeFallbackActorState();
		static_cast<GetRangeFallbackActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 4144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Future<Key> fb = resolveKey(trState, begin, version, useTenant);
															#line 4145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		fe = resolveKey(trState, end, version, useTenant);
															#line 4147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Key> __when_expr_1 = fb;
															#line 4147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 2;
															#line 4147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetRangeFallbackActor, 1, Key >*>(static_cast<GetRangeFallbackActor*>(this)));
															#line 18711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2(Version const& ver,int loopDepth) 
	{
															#line 4141 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = ver;
															#line 18720 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Version && ver,int loopDepth) 
	{
															#line 4141 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = ver;
															#line 18729 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version const& ver,int loopDepth) 
	{
		loopDepth = a_body1cont2(ver, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && ver,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(ver), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state > 0) static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeFallbackActor*>(this)->ActorCallback< GetRangeFallbackActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetRangeFallbackActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
															#line 4148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Key> __when_expr_2 = fe;
															#line 4148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont4when1(__when_expr_2.get(), loopDepth); };
		static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 3;
															#line 4148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetRangeFallbackActor, 2, Key >*>(static_cast<GetRangeFallbackActor*>(this)));
															#line 18808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(Key const& __b,int loopDepth) 
	{
															#line 4147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		b = __b;
															#line 18817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Key && __b,int loopDepth) 
	{
		b = std::move(__b);
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state > 0) static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeFallbackActor*>(this)->ActorCallback< GetRangeFallbackActor, 1, Key >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 1, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 1, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetRangeFallbackActor, 1, Key >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont5(int loopDepth) 
	{
															#line 4149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (b >= e)
															#line 18884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetRangeFallbackActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(RangeResultFamily()); this->~GetRangeFallbackActorState(); static_cast<GetRangeFallbackActor*>(this)->destroy(); return 0; }
															#line 18888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetRangeFallbackActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(RangeResultFamily());
			this->~GetRangeFallbackActorState();
			static_cast<GetRangeFallbackActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 4157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResultFamily> __when_expr_3 = getExactRange<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>( trState, version, KeyRangeRef(b, e), mapper, limits, reverse, useTenant);
															#line 4157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont5when1(__when_expr_3.get(), loopDepth); };
		static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 4;
															#line 4157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetRangeFallbackActor, 3, RangeResultFamily >*>(static_cast<GetRangeFallbackActor*>(this)));
															#line 18903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4when1(Key const& __e,int loopDepth) 
	{
															#line 4148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		e = __e;
															#line 18912 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont4when1(Key && __e,int loopDepth) 
	{
		e = std::move(__e);
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state > 0) static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeFallbackActor*>(this)->ActorCallback< GetRangeFallbackActor, 2, Key >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 2, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 2, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetRangeFallbackActor, 2, Key >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont6(RangeResultFamily const& _r,int loopDepth) 
	{
															#line 4159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		RangeResultFamily r = _r;
															#line 4161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (b == allKeys.begin && ((reverse && !r.more) || !reverse))
															#line 18981 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			r.readToBegin = true;
															#line 18985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4169 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (e == allKeys.end && ((!reverse && !r.more) || reverse))
															#line 18989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4170 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			r.readThroughEnd = true;
															#line 18993 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!limits.hasRowLimit() || r.size() <= limits.rows);
															#line 4175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (limits.hasByteLimit() && r.expectedSize() > size_t(limits.bytes + CLIENT_KNOBS->SYSTEM_KEY_SIZE_LIMIT + CLIENT_KNOBS->VALUE_SIZE_LIMIT + 1) && limits.minRows == 0)
															#line 18999 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarnAlways, "GetRangeFallbackTooMuchData") .detail("LimitBytes", limits.bytes) .detail("DeliveredBytes", r.expectedSize()) .detail("LimitRows", limits.rows) .detail("DeliveredRows", r.size());
															#line 19003 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4186 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeFallbackActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(r); this->~GetRangeFallbackActorState(); static_cast<GetRangeFallbackActor*>(this)->destroy(); return 0; }
															#line 19007 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeFallbackActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(r);
		this->~GetRangeFallbackActorState();
		static_cast<GetRangeFallbackActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6(RangeResultFamily && _r,int loopDepth) 
	{
															#line 4159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		RangeResultFamily r = _r;
															#line 4161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (b == allKeys.begin && ((reverse && !r.more) || !reverse))
															#line 19021 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			r.readToBegin = true;
															#line 19025 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4169 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (e == allKeys.end && ((!reverse && !r.more) || reverse))
															#line 19029 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4170 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			r.readThroughEnd = true;
															#line 19033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!limits.hasRowLimit() || r.size() <= limits.rows);
															#line 4175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (limits.hasByteLimit() && r.expectedSize() > size_t(limits.bytes + CLIENT_KNOBS->SYSTEM_KEY_SIZE_LIMIT + CLIENT_KNOBS->VALUE_SIZE_LIMIT + 1) && limits.minRows == 0)
															#line 19039 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarnAlways, "GetRangeFallbackTooMuchData") .detail("LimitBytes", limits.bytes) .detail("DeliveredBytes", r.expectedSize()) .detail("LimitRows", limits.rows) .detail("DeliveredRows", r.size());
															#line 19043 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4186 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeFallbackActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(r); this->~GetRangeFallbackActorState(); static_cast<GetRangeFallbackActor*>(this)->destroy(); return 0; }
															#line 19047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeFallbackActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(r);
		this->~GetRangeFallbackActorState();
		static_cast<GetRangeFallbackActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont5when1(RangeResultFamily const& _r,int loopDepth) 
	{
		loopDepth = a_body1cont6(_r, loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(RangeResultFamily && _r,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_r), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetRangeFallbackActor*>(this)->actor_wait_state > 0) static_cast<GetRangeFallbackActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeFallbackActor*>(this)->ActorCallback< GetRangeFallbackActor, 3, RangeResultFamily >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 3, RangeResultFamily >*,RangeResultFamily const& value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetRangeFallbackActor, 3, RangeResultFamily >*,RangeResultFamily && value) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetRangeFallbackActor, 3, RangeResultFamily >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector begin;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector end;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key mapper;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeLimits limits;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reverse reverse;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseTenant useTenant;
															#line 4136 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction transaction;
															#line 4145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Key> fe;
															#line 4147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key b;
															#line 4148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key e;
															#line 19142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getRangeFallback()
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily>
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeFallbackActor final : public Actor<RangeResultFamily>, public ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, Version >, public ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, Key >, public ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, Key >, public ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, RangeResultFamily >, public FastAllocated<GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>, public GetRangeFallbackActorState<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily, GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>> {
															#line 19149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>::operator new;
	using FastAllocated<GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<RangeResultFamily>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, Version >;
friend struct ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, Key >;
friend struct ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, Key >;
friend struct ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, RangeResultFamily >;
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeFallbackActor(Reference<TransactionState> const& trState,Version const& version,KeySelector const& begin,KeySelector const& end,Key const& mapper,GetRangeLimits const& limits,Reverse const& reverse,UseTenant const& useTenant) 
															#line 19163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<RangeResultFamily>(),
		   GetRangeFallbackActorState<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily, GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>(trState, version, begin, end, mapper, limits, reverse, useTenant)
	{
		fdb_probe_actor_enter("getRangeFallback", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getRangeFallback");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getRangeFallback", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, Key >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, Key >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, RangeResultFamily >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily>
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<RangeResultFamily> getRangeFallback( Reference<TransactionState> const& trState, Version const& version, KeySelector const& begin, KeySelector const& end, Key const& mapper, GetRangeLimits const& limits, Reverse const& reverse, UseTenant const& useTenant ) {
															#line 4126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<RangeResultFamily>(new GetRangeFallbackActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>(trState, version, begin, end, mapper, limits, reverse, useTenant));
															#line 19196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 4188 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

int64_t inline getRangeResultFamilyBytes(RangeResultRef result) {
	return result.expectedSize();
}

int64_t inline getRangeResultFamilyBytes(MappedRangeResultRef result) {
	int64_t bytes = 0;
	for (const MappedKeyValueRef& mappedKeyValue : result) {
		bytes += mappedKeyValue.key.size() + mappedKeyValue.value.size();

		auto& reqAndResult = mappedKeyValue.reqAndResult;
		if (std::holds_alternative<GetValueReqAndResultRef>(reqAndResult)) {
			auto getValue = std::get<GetValueReqAndResultRef>(reqAndResult);
			bytes += getValue.expectedSize();
		} else if (std::holds_alternative<GetRangeReqAndResultRef>(reqAndResult)) {
			auto getRange = std::get<GetRangeReqAndResultRef>(reqAndResult);
			bytes += getRange.result.expectedSize();
		} else {
			throw internal_error();
		}
	}
	return bytes;
}

// TODO: Client should add mapped keys to conflict ranges.
template <class RangeResultFamily> // RangeResult or MappedRangeResult
void getRangeFinished(Reference<TransactionState> trState,
                      double startTime,
                      KeySelector begin,
                      KeySelector end,
                      Snapshot snapshot,
                      Promise<std::pair<Key, Key>> conflictRange,
                      Reverse reverse,
                      RangeResultFamily result) {
	int64_t bytes = getRangeResultFamilyBytes(result);

	trState->cx->transactionBytesRead += bytes;
	trState->cx->transactionKeysRead += result.size();

	if (trState->trLogInfo) {
		trState->trLogInfo->addLog(FdbClientLogEvents::EventGetRange(startTime,
		                                                             trState->cx->clientLocality.dcId(),
		                                                             now() - startTime,
		                                                             bytes,
		                                                             begin.getKey(),
		                                                             end.getKey(),
		                                                             trState->tenant()));
	}

	if (!snapshot) {
		Key rangeBegin;
		Key rangeEnd;

		if (result.readToBegin) {
			rangeBegin = allKeys.begin;
		} else if (((!reverse || !result.more || begin.offset > 1) && begin.offset > 0) || result.size() == 0) {
			rangeBegin = Key(begin.getKey(), begin.arena());
		} else {
			rangeBegin = reverse ? result.end()[-1].key : result[0].key;
		}

		if (end.offset > begin.offset && end.getKey() < rangeBegin) {
			rangeBegin = Key(end.getKey(), end.arena());
		}

		if (result.readThroughEnd) {
			rangeEnd = allKeys.end;
		} else if (((reverse || !result.more || end.offset <= 0) && end.offset <= 1) || result.size() == 0) {
			rangeEnd = Key(end.getKey(), end.arena());
		} else {
			rangeEnd = keyAfter(reverse ? result[0].key : result.end()[-1].key);
		}

		if (begin.offset < end.offset && begin.getKey() > rangeEnd) {
			rangeEnd = Key(begin.getKey(), begin.arena());
		}

		conflictRange.send(std::make_pair(rangeBegin, rangeEnd));
	}
}

															#line 19281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getRange()
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily, class GetRangeActor>
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeActorState {
															#line 19288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeActorState(Reference<TransactionState> const& trState,Future<Version> const& fVersion,KeySelector const& begin,KeySelector const& end,Key const& mapper,GetRangeLimits const& limits,Promise<std::pair<Key, Key>> const& conflictRange,Snapshot const& snapshot,Reverse const& reverse,UseTenant const& useTenant = UseTenant::True) 
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   fVersion(fVersion),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   mapper(mapper),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limits(limits),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   conflictRange(conflictRange),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   snapshot(snapshot),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   reverse(reverse),
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useTenant(useTenant),
															#line 4286 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   originalLimits(limits),
															#line 4287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   originalBegin(begin),
															#line 4288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   originalEnd(end),
															#line 4289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   output(),
															#line 4290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:getRange"_loc, trState->spanID)
															#line 19323 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getRange", reinterpret_cast<unsigned long>(this));

	}
	~GetRangeActorState() 
	{
		fdb_probe_actor_destroy("getRange", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 4291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (useTenant && trState->tenant().present())
															#line 19338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				span.addTag("tenant"_sr, trState->tenant().get());
															#line 19342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			try {
															#line 4296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Version> __when_expr_0 = fVersion;
															#line 4296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 19349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<GetRangeActor*>(this)->actor_wait_state = 1;
															#line 4296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetRangeActor, 0, Version >*>(static_cast<GetRangeActor*>(this)));
															#line 19354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetRangeActorState();
		static_cast<GetRangeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 4583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (conflictRange.canBeSet())
															#line 19384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4584 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				conflictRange.send(std::make_pair(Key(), Key()));
															#line 19388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 19392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3(int loopDepth) 
	{
															#line 4297 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->validateVersion(version);
															#line 4299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		startTime = now();
															#line 4300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		readVersion = version;
															#line 4305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (begin.getKey() == allKeys.begin && begin.offset < 1)
															#line 19412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.readToBegin = true;
															#line 4307 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			begin = KeySelector(firstGreaterOrEqual(begin.getKey()), begin.arena());
															#line 19418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!limits.isReached());
															#line 4311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT((!limits.hasRowLimit() || limits.rows >= limits.minRows) && limits.minRows >= 0);
															#line 4313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 19426 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version const& __version,int loopDepth) 
	{
															#line 4296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = __version;
															#line 19435 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && __version,int loopDepth) 
	{
		version = std::move(__version);
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetRangeActor*>(this)->actor_wait_state > 0) static_cast<GetRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeActor*>(this)->ActorCallback< GetRangeActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetRangeActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont3loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1(int loopDepth) 
	{
															#line 4314 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (end.getKey() == allKeys.begin && (end.offset < 1 || end.isFirstGreaterOrEqual()))
															#line 19509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4315 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, output);
															#line 4317 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(output); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 19515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(std::move(output)); // state_var_RVO
			this->~GetRangeActorState();
			static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 4320 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Key locationKey = reverse ? Key(end.getKey(), end.arena()) : Key(begin.getKey(), begin.arena());
															#line 4321 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Reverse locationBackward{ reverse ? (end - 1).isBackward() : begin.isBackward() };
															#line 4322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<KeyRangeLocationInfo> __when_expr_1 = getKeyLocation(trState, locationKey, getRangeRequestStream<GetKeyValuesFamilyRequest>(), locationBackward, useTenant, version);
															#line 4322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 19529 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetRangeActor*>(this)->actor_wait_state = 2;
															#line 4322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetRangeActor, 1, KeyRangeLocationInfo >*>(static_cast<GetRangeActor*>(this)));
															#line 19534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1(int loopDepth) 
	{
															#line 4329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shard = beginServer.range;
															#line 4330 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		modifiedSelectors = false;
															#line 4331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req = GetKeyValuesFamilyRequest();
															#line 4332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.mapper = mapper;
															#line 4333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.arena.dependsOn(mapper.arena());
															#line 4335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.tenantInfo = useTenant ? trState->getTenantInfo() : TenantInfo();
															#line 4336 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.isFetchKeys = (trState->taskID == TaskPriority::FetchKeys);
															#line 4337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.version = readVersion;
															#line 4339 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->getLatestCommitVersions( beginServer.locations, req.version, trState, req.ssLatestCommitVersions);
															#line 4344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool dependOnShard = false;
															#line 4345 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (reverse && (begin - 1).isDefinitelyLess(shard.begin) && (!begin.isFirstGreaterOrEqual() || begin.getKey() != shard.begin))
															#line 19563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4350 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.begin = firstGreaterOrEqual(shard.begin);
															#line 4351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			modifiedSelectors = true;
															#line 4352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.arena.dependsOn(shard.arena());
															#line 4353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			dependOnShard = true;
															#line 19573 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 4355 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.begin = begin;
															#line 4356 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.arena.dependsOn(begin.arena());
															#line 19581 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4359 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!reverse && end.isDefinitelyGreater(shard.end))
															#line 19585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.end = firstGreaterOrEqual(shard.end);
															#line 4361 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			modifiedSelectors = true;
															#line 4362 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!dependOnShard)
															#line 19593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4363 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.arena.dependsOn(shard.arena());
															#line 19597 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		else
		{
															#line 4366 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.end = end;
															#line 4367 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.arena.dependsOn(end.arena());
															#line 19606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4370 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		transformRangeLimits(limits, reverse, req);
															#line 4371 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(req.limitBytes > 0 && req.limit != 0 && req.limit < 0 == reverse);
															#line 4373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.tags = trState->cx->sampleReadTags() ? trState->options.readTags : Optional<TagSet>();
															#line 4374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.debugID = trState->debugID;
															#line 4375 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.spanContext = span.context;
															#line 19618 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 4377 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->debugID.present())
															#line 19622 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4378 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent( "TransactionDebug", trState->debugID.get().first(), "NativeAPI.getRange.Before");
															#line 19626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReads;
															#line 4397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			rep = GetKeyValuesFamilyReply();
															#line 19632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			try {
															#line 4399 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (CLIENT_BUGGIFY_WITH_PROB(.01))
															#line 19636 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1cont3loopBody1cont1Catch2(deterministicRandom()->randomChoice( std::vector<Error>{ transaction_too_old(), future_version() }), loopDepth);
															#line 19640 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 4404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<GetKeyValuesFamilyReply> __when_expr_2 = loadBalance(trState->cx.getPtr(), beginServer.locations, getRangeRequestStream<GetKeyValuesFamilyRequest>(), req, TaskPriority::DefaultPromiseEndpoint, AtMostOnce::False, trState->cx->enableLocalityLoadBalance ? &trState->cx->queueModel : nullptr);
															#line 4404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetRangeActor*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1cont1Catch2(actor_cancelled(), loopDepth);
															#line 19646 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont3loopBody1cont1Catch2(__when_expr_2.getError(), loopDepth); else return a_body1cont3loopBody1cont1when1(__when_expr_2.get(), loopDepth); };
				static_cast<GetRangeActor*>(this)->actor_wait_state = 3;
															#line 4404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetRangeActor, 2, GetKeyValuesFamilyReply >*>(static_cast<GetRangeActor*>(this)));
															#line 19651 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1cont3loopBody1cont1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1cont3loopBody1cont1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1cont3loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont3loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1when1(KeyRangeLocationInfo const& __beginServer,int loopDepth) 
	{
															#line 4322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		beginServer = __beginServer;
															#line 19672 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1when1(KeyRangeLocationInfo && __beginServer,int loopDepth) 
	{
		beginServer = std::move(__beginServer);
		loopDepth = a_body1cont3loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetRangeActor*>(this)->actor_wait_state > 0) static_cast<GetRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeActor*>(this)->ActorCallback< GetRangeActor, 1, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont3loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont3loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetRangeActor, 1, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3loopBody1cont3(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 4536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->debugID.present())
															#line 19746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent( "TransactionDebug", trState->debugID.get().first(), "NativeAPI.getRange.Error");
															#line 4539 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent("TransactionDebugError", trState->debugID.get()).error(e);
															#line 19752 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed || (e.code() == error_code_transaction_too_old && readVersion == latestVersion))
															#line 19756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->invalidateCache(beginServer.tenantEntry.prefix, reverse ? end.getKey() : begin.getKey(), Reverse{ reverse ? (end - 1).isBackward() : begin.isBackward() });
															#line 4547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_wrong_shard_server)
															#line 19762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4548 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<RangeResultFamily> __when_expr_4 = getRangeFallback<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>( trState, version, originalBegin, originalEnd, mapper, originalLimits, reverse, useTenant);
															#line 4548 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<GetRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 19768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch2(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont1Catch1when1(__when_expr_4.get(), loopDepth); };
					static_cast<GetRangeActor*>(this)->actor_wait_state = 5;
															#line 4548 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetRangeActor, 4, RangeResultFamily >*>(static_cast<GetRangeActor*>(this)));
															#line 19773 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
					loopDepth = a_body1cont3loopBody1cont1Catch1cont3(loopDepth);
				}
			}
			else
			{
															#line 4564 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 19785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4565 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(useTenant && trState->tenant().present());
															#line 4566 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->cx->invalidateCachedTenant(trState->tenant().get());
															#line 4567 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_6 = delay(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, trState->taskID);
															#line 4567 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<GetRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 19795 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch2(__when_expr_6.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont1Catch1when2(__when_expr_6.get(), loopDepth); };
					static_cast<GetRangeActor*>(this)->actor_wait_state = 7;
															#line 4567 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< GetRangeActor, 6, Void >*>(static_cast<GetRangeActor*>(this)));
															#line 19800 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 4569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (trState->trLogInfo)
															#line 19807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 4570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						trState->trLogInfo->addLog( FdbClientLogEvents::EventGetRangeError(startTime, trState->cx->clientLocality.dcId(), static_cast<int>(e.code()), begin.getKey(), end.getKey(), trState->tenant()));
															#line 19811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 4578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch2(e, std::max(0, loopDepth - 1));
															#line 19815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont9(int loopDepth) 
	{
															#line 4419 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->debugID.present())
															#line 19831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent("TransactionDebug", trState->debugID.get().first(), "NativeAPI.getRange.After");
															#line 19835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4431 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!rep.more || rep.data.size());
															#line 4432 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!limits.hasRowLimit() || rep.data.size() <= limits.rows);
															#line 4434 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		limits.decrement(rep.data);
															#line 4436 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (reverse && begin.isLastLessOrEqual() && rep.data.size() && rep.data.end()[-1].key == begin.getKey())
															#line 19845 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			modifiedSelectors = false;
															#line 19849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool finished = limits.isReached() || (!modifiedSelectors && !rep.more) || limits.hasSatisfiedMinRows();
															#line 4442 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool readThrough = modifiedSelectors && !rep.more;
															#line 4445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (finished && !output.size())
															#line 19857 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bool readToBegin = output.readToBegin;
															#line 4447 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bool readThroughEnd = output.readThroughEnd;
															#line 4449 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			using RangeResultRefFamily = typename RangeResultFamily::RefType;
															#line 4450 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output = RangeResultFamily( RangeResultRefFamily(rep.data, modifiedSelectors || limits.isReached() || rep.more), rep.arena);
															#line 4452 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.readToBegin = readToBegin;
															#line 4453 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.readThroughEnd = readThroughEnd;
															#line 4455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BUGGIFY && limits.hasByteLimit() && output.size() > std::max(1, originalLimits.minRows) && (!std::is_same<GetKeyValuesFamilyRequest, GetMappedKeyValuesRequest>::value))
															#line 19873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				RangeResultFamily copy;
															#line 4461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				int newSize = deterministicRandom()->randomInt(std::max(1, originalLimits.minRows), output.size());
															#line 4463 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for(int i = 0;i < newSize;i++) {
															#line 4464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					copy.push_back_deep(copy.arena(), output[i]);
															#line 19883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 4466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				output = copy;
															#line 4467 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				output.more = true;
															#line 4469 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, output);
															#line 4471 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(output); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 19893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(std::move(output)); // state_var_RVO
				this->~GetRangeActorState();
				static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 4474 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (readThrough)
															#line 19901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4475 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				output.arena().dependsOn(shard.arena());
															#line 4476 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				output.readThrough = reverse ? shard.begin : shard.end;
															#line 19907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4479 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, output);
															#line 4481 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(output); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 19913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(std::move(output)); // state_var_RVO
			this->~GetRangeActorState();
			static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 4484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		output.arena().dependsOn(rep.arena);
															#line 4485 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		output.append(output.arena(), rep.data.begin(), rep.data.size());
															#line 4487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (finished)
															#line 19925 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (readThrough)
															#line 19929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4489 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				output.arena().dependsOn(shard.arena());
															#line 4490 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				output.readThrough = reverse ? shard.begin : shard.end;
															#line 19935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4492 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.more = modifiedSelectors || limits.isReached() || rep.more;
															#line 4494 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, output);
															#line 4496 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(output); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 19943 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(std::move(output)); // state_var_RVO
			this->~GetRangeActorState();
			static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 4499 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (readVersion == latestVersion)
															#line 19951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4500 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			readVersion = rep.version;
															#line 19955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4503 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!rep.more)
															#line 19959 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4504 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(modifiedSelectors);
															#line 4505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 4507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!rep.data.size())
															#line 19967 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<RangeResultFamily> __when_expr_3 = getRangeFallback<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>( trState, readVersion, originalBegin, originalEnd, mapper, originalLimits, reverse, useTenant);
															#line 4508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetRangeActor*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 19973 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont3loopBody1cont1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont3loopBody1cont9when1(__when_expr_3.get(), loopDepth); };
				static_cast<GetRangeActor*>(this)->actor_wait_state = 4;
															#line 4508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetRangeActor, 3, RangeResultFamily >*>(static_cast<GetRangeActor*>(this)));
															#line 19978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont3loopBody1cont23(loopDepth);
			}
		}
		else
		{
															#line 4528 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 4529 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (reverse)
															#line 19992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4530 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				end = firstGreaterOrEqual(output[output.size() - 1].key);
															#line 19996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 4532 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				begin = firstGreaterThan(output[output.size() - 1].key);
															#line 20002 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			loopDepth = a_body1cont3loopBody1cont13(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch2(const Error& __current_error,int loopDepth=0) 
	{
		try {
															#line 4415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReadsCompleted;
															#line 4416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1cont3loopBody1cont1Catch1(__current_error, loopDepth);
															#line 20016 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1cont3loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont3loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont11(GetKeyValuesFamilyReply const& _rep,int loopDepth) 
	{
															#line 4412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 4413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionPhysicalReadsCompleted;
															#line 20032 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopBody1cont11cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont11(GetKeyValuesFamilyReply && _rep,int loopDepth) 
	{
															#line 4412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 4413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionPhysicalReadsCompleted;
															#line 20043 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopBody1cont11cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1when1(GetKeyValuesFamilyReply const& _rep,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont11(_rep, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1when1(GetKeyValuesFamilyReply && _rep,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont11(std::move(_rep), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetRangeActor*>(this)->actor_wait_state > 0) static_cast<GetRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeActor*>(this)->ActorCallback< GetRangeActor, 2, GetKeyValuesFamilyReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 2, GetKeyValuesFamilyReply >*,GetKeyValuesFamilyReply const& value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont3loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 2, GetKeyValuesFamilyReply >*,GetKeyValuesFamilyReply && value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont3loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetRangeActor, 2, GetKeyValuesFamilyReply >*,Error err) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3loopBody1cont1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1cont1Catch2(error, 0);
		} catch (...) {
			a_body1cont3loopBody1cont1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont3loopBody1cont11cont2(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont3loopBody1cont9(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont3loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont3loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont13(int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont13cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont23(int loopDepth) 
	{
															#line 4523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (reverse)
															#line 20134 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4524 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			end = firstGreaterOrEqual(shard.begin);
															#line 20138 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 4526 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			begin = firstGreaterOrEqual(shard.end);
															#line 20144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1cont3loopBody1cont13(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont24(RangeResultFamily const& result,int loopDepth) 
	{
															#line 4518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, result);
															#line 4520 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(result); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 20156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(result);
		this->~GetRangeActorState();
		static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont24(RangeResultFamily && result,int loopDepth) 
	{
															#line 4518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, result);
															#line 4520 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(result); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 20170 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(result);
		this->~GetRangeActorState();
		static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont9when1(RangeResultFamily const& result,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont24(result, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont9when1(RangeResultFamily && result,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont24(std::move(result), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetRangeActor*>(this)->actor_wait_state > 0) static_cast<GetRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeActor*>(this)->ActorCallback< GetRangeActor, 3, RangeResultFamily >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 3, RangeResultFamily >*,RangeResultFamily const& value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3loopBody1cont9when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 3, RangeResultFamily >*,RangeResultFamily && value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3loopBody1cont9when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetRangeActor, 3, RangeResultFamily >*,Error err) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont3loopBody1cont13cont1(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont3loopBody1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont3(int loopDepth) 
	{
															#line 4563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_5 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, trState->taskID);
															#line 4563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 20266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch2(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont1Catch1cont3when1(__when_expr_5.get(), loopDepth); };
		static_cast<GetRangeActor*>(this)->actor_wait_state = 6;
															#line 4563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< GetRangeActor, 5, Void >*>(static_cast<GetRangeActor*>(this)));
															#line 20271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont4(RangeResultFamily const& result,int loopDepth) 
	{
															#line 4558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, result);
															#line 4560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(result); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 20282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(result);
		this->~GetRangeActorState();
		static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont4(RangeResultFamily && result,int loopDepth) 
	{
															#line 4558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		getRangeFinished( trState, startTime, originalBegin, originalEnd, snapshot, conflictRange, reverse, result);
															#line 4560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeActor*>(this)->SAV<RangeResultFamily>::futures) { (void)(result); this->~GetRangeActorState(); static_cast<GetRangeActor*>(this)->destroy(); return 0; }
															#line 20296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeActor*>(this)->SAV< RangeResultFamily >::value()) RangeResultFamily(result);
		this->~GetRangeActorState();
		static_cast<GetRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1when1(RangeResultFamily const& result,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont4(result, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1when1(RangeResultFamily && result,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont4(std::move(result), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetRangeActor*>(this)->actor_wait_state > 0) static_cast<GetRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeActor*>(this)->ActorCallback< GetRangeActor, 4, RangeResultFamily >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 4, RangeResultFamily >*,RangeResultFamily const& value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 4, RangeResultFamily >*,RangeResultFamily && value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetRangeActor, 4, RangeResultFamily >*,Error err) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont3loopBody1cont1Catch1cont6(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont6(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<GetRangeActor*>(this)->actor_wait_state > 0) static_cast<GetRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeActor*>(this)->ActorCallback< GetRangeActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3loopBody1cont1Catch1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3loopBody1cont1Catch1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< GetRangeActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont3loopBody1cont1Catch1cont7(int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont8(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1cont8(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1Catch1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1Catch1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<GetRangeActor*>(this)->actor_wait_state > 0) static_cast<GetRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeActor*>(this)->ActorCallback< GetRangeActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont3loopBody1cont1Catch1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< GetRangeActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont3loopBody1cont1Catch1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< GetRangeActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), 6);

	}
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> fVersion;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector begin;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector end;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key mapper;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeLimits limits;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<std::pair<Key, Key>> conflictRange;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Snapshot snapshot;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reverse reverse;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseTenant useTenant;
															#line 4286 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeLimits originalLimits;
															#line 4287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector originalBegin;
															#line 4288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector originalEnd;
															#line 4289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RangeResultFamily output;
															#line 4290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 4296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 4299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double startTime;
															#line 4300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version readVersion;
															#line 4322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeLocationInfo beginServer;
															#line 4329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange shard;
															#line 4330 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool modifiedSelectors;
															#line 4331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyValuesFamilyRequest req;
															#line 4397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyValuesFamilyReply rep;
															#line 20569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getRange()
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily>
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeActor final : public Actor<RangeResultFamily>, public ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, Version >, public ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, KeyRangeLocationInfo >, public ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, GetKeyValuesFamilyReply >, public ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, RangeResultFamily >, public ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 4, RangeResultFamily >, public ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 5, Void >, public ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 6, Void >, public FastAllocated<GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>, public GetRangeActorState<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily, GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>> {
															#line 20576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>::operator new;
	using FastAllocated<GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<RangeResultFamily>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, Version >;
friend struct ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, KeyRangeLocationInfo >;
friend struct ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, GetKeyValuesFamilyReply >;
friend struct ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, RangeResultFamily >;
friend struct ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 4, RangeResultFamily >;
friend struct ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 5, Void >;
friend struct ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 6, Void >;
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeActor(Reference<TransactionState> const& trState,Future<Version> const& fVersion,KeySelector const& begin,KeySelector const& end,Key const& mapper,GetRangeLimits const& limits,Promise<std::pair<Key, Key>> const& conflictRange,Snapshot const& snapshot,Reverse const& reverse,UseTenant const& useTenant = UseTenant::True) 
															#line 20593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<RangeResultFamily>(),
		   GetRangeActorState<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily, GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>>(trState, fVersion, begin, end, mapper, limits, conflictRange, snapshot, reverse, useTenant)
	{
		fdb_probe_actor_enter("getRange", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getRange");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getRange", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 1, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 2, GetKeyValuesFamilyReply >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 3, RangeResultFamily >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 4, RangeResultFamily >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 5, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>, 6, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily>
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<RangeResultFamily> getRange( Reference<TransactionState> const& trState, Future<Version> const& fVersion, KeySelector const& begin, KeySelector const& end, Key const& mapper, GetRangeLimits const& limits, Promise<std::pair<Key, Key>> const& conflictRange, Snapshot const& snapshot, Reverse const& reverse, UseTenant const& useTenant = UseTenant::True ) {
															#line 4269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<RangeResultFamily>(new GetRangeActor<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>(trState, fVersion, begin, end, mapper, limits, conflictRange, snapshot, reverse, useTenant));
															#line 20629 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 4590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

template <class StreamReply>
struct TSSDuplicateStreamData {
	PromiseStream<StreamReply> stream;
	Promise<Void> tssComparisonDone;

	// empty constructor for optional?
	TSSDuplicateStreamData() {}

	TSSDuplicateStreamData(PromiseStream<StreamReply> stream) : stream(stream) {}

	bool done() { return tssComparisonDone.getFuture().isReady(); }

	void setDone() {
		if (tssComparisonDone.canBeSet()) {
			tssComparisonDone.send(Void());
		}
	}

	~TSSDuplicateStreamData() {}
};

// Error tracking here is weird, and latency doesn't really mean the same thing here as it does with normal tss
// comparisons, so this is pretty much just counting mismatches
															#line 20657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via tssStreamComparison()
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class Request, class TssStreamComparisonActor>
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TssStreamComparisonActorState {
															#line 20664 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TssStreamComparisonActorState(Request const& request,TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)> const& streamData,ReplyPromiseStream<REPLYSTREAM_TYPE(Request)> const& tssReplyStream,TSSEndpointData const& tssData) 
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : request(request),
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   streamData(streamData),
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tssReplyStream(tssReplyStream),
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tssData(tssData),
															#line 4619 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ssEndOfStream(false),
															#line 4620 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tssEndOfStream(false),
															#line 4621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ssReply(Optional<REPLYSTREAM_TYPE(Request)>()),
															#line 4622 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tssReply(Optional<REPLYSTREAM_TYPE(Request)>())
															#line 20685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("tssStreamComparison", reinterpret_cast<unsigned long>(this));

	}
	~TssStreamComparisonActorState() 
	{
		fdb_probe_actor_destroy("tssStreamComparison", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 4624 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 20700 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TssStreamComparisonActorState();
		static_cast<TssStreamComparisonActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 4626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ssReply = Optional<REPLYSTREAM_TYPE(Request)>();
															#line 4627 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tssReply = Optional<REPLYSTREAM_TYPE(Request)>();
															#line 4629 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		startTime = now();
															#line 20734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 4632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			FutureStream<REPLYSTREAM_TYPE(Request)> __when_expr_0 = streamData.stream.getFuture();
															#line 4632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<TssStreamComparisonActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20740 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
			static_cast<TssStreamComparisonActor*>(this)->actor_wait_state = 1;
															#line 4632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< TssStreamComparisonActor, 0, REPLYSTREAM_TYPE(Request) >*>(static_cast<TssStreamComparisonActor*>(this)));
															#line 20745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 4649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		sleepTime = std::max(startTime + FLOW_KNOBS->LOAD_BALANCE_TSS_TIMEOUT - now(), 0.0);
															#line 20760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 4653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			FutureStream<REPLYSTREAM_TYPE(Request)> __when_expr_1 = tssReplyStream.getFuture();
															#line 4652 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<TssStreamComparisonActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 20766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.pop(), loopDepth); };
															#line 4656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = delay(sleepTime);
															#line 20770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont1when2(__when_expr_2.get(), loopDepth); };
			static_cast<TssStreamComparisonActor*>(this)->actor_wait_state = 2;
															#line 4653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorSingleCallback< TssStreamComparisonActor, 1, REPLYSTREAM_TYPE(Request) >*>(static_cast<TssStreamComparisonActor*>(this)));
															#line 4656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< TssStreamComparisonActor, 2, Void >*>(static_cast<TssStreamComparisonActor*>(this)));
															#line 20777 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 4635 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_actor_cancelled)
															#line 20793 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4636 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				streamData.setDone();
															#line 4637 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 20799 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_end_of_stream)
															#line 20803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ssEndOfStream = true;
															#line 20807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 4644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tssData.metrics->ssError(e.code());
															#line 20813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4646 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(e.code() != error_code_end_of_stream);
															#line 20817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(REPLYSTREAM_TYPE(Request) const& _ssReply,int loopDepth) 
	{
															#line 4633 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ssReply = _ssReply;
															#line 20832 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2(REPLYSTREAM_TYPE(Request) && _ssReply,int loopDepth) 
	{
															#line 4633 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ssReply = _ssReply;
															#line 20841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(REPLYSTREAM_TYPE(Request) const& _ssReply,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_ssReply, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(REPLYSTREAM_TYPE(Request) && _ssReply,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_ssReply), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TssStreamComparisonActor*>(this)->actor_wait_state > 0) static_cast<TssStreamComparisonActor*>(this)->actor_wait_state = 0;
		static_cast<TssStreamComparisonActor*>(this)->ActorSingleCallback< TssStreamComparisonActor, 0, REPLYSTREAM_TYPE(Request) >::remove();

	}
	void a_callback_fire(ActorSingleCallback< TssStreamComparisonActor, 0, REPLYSTREAM_TYPE(Request) >*,REPLYSTREAM_TYPE(Request) const& value) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< TssStreamComparisonActor, 0, REPLYSTREAM_TYPE(Request) >*,REPLYSTREAM_TYPE(Request) && value) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< TssStreamComparisonActor, 0, REPLYSTREAM_TYPE(Request) >*,Error err) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
															#line 4676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!ssEndOfStream || !tssEndOfStream)
															#line 20926 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4677 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++tssData.metrics->streamComparisons;
															#line 20930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4681 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (ssReply.present() && tssReply.present())
															#line 20934 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4686 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(ssEndOfStream != tssEndOfStream);
															#line 4689 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if ((!ssEndOfStream || !tssEndOfStream) && !TSS_doCompare(ssReply.get(), tssReply.get()))
															#line 20940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4690 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TEST(true);
															#line 4691 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent mismatchEvent( (g_network->isSimulated() && g_simulator.tssMode == ISimulator::TSSMode::EnabledDropMutations) ? SevWarnAlways : SevError, TSS_mismatchTraceName(request));
															#line 4696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				mismatchEvent.setMaxEventLength(FLOW_KNOBS->TSS_LARGE_TRACE_SIZE);
															#line 4697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				mismatchEvent.detail("TSSID", tssData.tssId);
															#line 4699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (tssData.metrics->shouldRecordDetailedMismatch())
															#line 20952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4700 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TSS_traceMismatch(mismatchEvent, request, ssReply.get(), tssReply.get());
															#line 4702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(FLOW_KNOBS ->LOAD_BALANCE_TSS_MISMATCH_TRACE_FULL);
															#line 4704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(!FLOW_KNOBS->LOAD_BALANCE_TSS_MISMATCH_TRACE_FULL);
															#line 4707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!FLOW_KNOBS->LOAD_BALANCE_TSS_MISMATCH_TRACE_FULL)
															#line 20962 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 4708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						mismatchEvent.disable();
															#line 4709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						UID mismatchUID = deterministicRandom()->randomUniqueID();
															#line 4710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						tssData.metrics->recordDetailedMismatchData(mismatchUID, mismatchEvent.getFields().toString());
															#line 4713 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						TraceEvent summaryEvent((g_network->isSimulated() && g_simulator.tssMode == ISimulator::TSSMode::EnabledDropMutations) ? SevWarnAlways : SevError, TSS_mismatchTraceName(request));
															#line 4718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						summaryEvent.detail("TSSID", tssData.tssId).detail("MismatchId", mismatchUID);
															#line 20974 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
				else
				{
															#line 4722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					mismatchEvent.disable();
															#line 20981 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 4724 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				streamData.setDone();
															#line 4725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<TssStreamComparisonActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TssStreamComparisonActorState(); static_cast<TssStreamComparisonActor*>(this)->destroy(); return 0; }
															#line 20987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<TssStreamComparisonActor*>(this)->SAV< Void >::value()) Void(Void());
				this->~TssStreamComparisonActorState();
				static_cast<TssStreamComparisonActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
		}
															#line 4728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!ssReply.present() || !tssReply.present() || ssEndOfStream || tssEndOfStream)
															#line 20996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4730 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			streamData.setDone();
															#line 4731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<TssStreamComparisonActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TssStreamComparisonActorState(); static_cast<TssStreamComparisonActor*>(this)->destroy(); return 0; }
															#line 21002 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<TssStreamComparisonActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~TssStreamComparisonActorState();
			static_cast<TssStreamComparisonActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 4662 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_actor_cancelled)
															#line 21017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4663 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				streamData.setDone();
															#line 4664 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 21023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_end_of_stream)
															#line 21027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4669 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tssEndOfStream = true;
															#line 21031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 4671 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tssData.metrics->tssError(e.code());
															#line 21037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4673 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(e.code() != error_code_end_of_stream);
															#line 21041 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont5(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(REPLYSTREAM_TYPE(Request) const& _tssReply,int loopDepth) 
	{
															#line 4654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tssReply = _tssReply;
															#line 21062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(REPLYSTREAM_TYPE(Request) && _tssReply,int loopDepth) 
	{
															#line 4654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tssReply = _tssReply;
															#line 21071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void const& _,int loopDepth) 
	{
															#line 4657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++tssData.metrics->tssTimeouts;
															#line 4658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TEST(true);
															#line 21082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void && _,int loopDepth) 
	{
															#line 4657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++tssData.metrics->tssTimeouts;
															#line 4658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TEST(true);
															#line 21093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<TssStreamComparisonActor*>(this)->actor_wait_state > 0) static_cast<TssStreamComparisonActor*>(this)->actor_wait_state = 0;
		static_cast<TssStreamComparisonActor*>(this)->ActorSingleCallback< TssStreamComparisonActor, 1, REPLYSTREAM_TYPE(Request) >::remove();
		static_cast<TssStreamComparisonActor*>(this)->ActorCallback< TssStreamComparisonActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorSingleCallback< TssStreamComparisonActor, 1, REPLYSTREAM_TYPE(Request) >*,REPLYSTREAM_TYPE(Request) const& value) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorSingleCallback< TssStreamComparisonActor, 1, REPLYSTREAM_TYPE(Request) >*,REPLYSTREAM_TYPE(Request) && value) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorSingleCallback< TssStreamComparisonActor, 1, REPLYSTREAM_TYPE(Request) >*,Error err) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TssStreamComparisonActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< TssStreamComparisonActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< TssStreamComparisonActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont7(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont5(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Request request;
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)> streamData;
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReplyPromiseStream<REPLYSTREAM_TYPE(Request)> tssReplyStream;
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TSSEndpointData tssData;
															#line 4619 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool ssEndOfStream;
															#line 4620 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool tssEndOfStream;
															#line 4621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<REPLYSTREAM_TYPE(Request)> ssReply;
															#line 4622 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<REPLYSTREAM_TYPE(Request)> tssReply;
															#line 4629 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double startTime;
															#line 4649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double sleepTime;
															#line 21228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via tssStreamComparison()
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class Request>
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TssStreamComparisonActor final : public Actor<Void>, public ActorSingleCallback< TssStreamComparisonActor<Request>, 0, REPLYSTREAM_TYPE(Request) >, public ActorSingleCallback< TssStreamComparisonActor<Request>, 1, REPLYSTREAM_TYPE(Request) >, public ActorCallback< TssStreamComparisonActor<Request>, 2, Void >, public FastAllocated<TssStreamComparisonActor<Request>>, public TssStreamComparisonActorState<Request, TssStreamComparisonActor<Request>> {
															#line 21235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<TssStreamComparisonActor<Request>>::operator new;
	using FastAllocated<TssStreamComparisonActor<Request>>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< TssStreamComparisonActor<Request>, 0, REPLYSTREAM_TYPE(Request) >;
friend struct ActorSingleCallback< TssStreamComparisonActor<Request>, 1, REPLYSTREAM_TYPE(Request) >;
friend struct ActorCallback< TssStreamComparisonActor<Request>, 2, Void >;
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TssStreamComparisonActor(Request const& request,TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)> const& streamData,ReplyPromiseStream<REPLYSTREAM_TYPE(Request)> const& tssReplyStream,TSSEndpointData const& tssData) 
															#line 21248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   TssStreamComparisonActorState<Request, TssStreamComparisonActor<Request>>(request, streamData, tssReplyStream, tssData)
	{
		fdb_probe_actor_enter("tssStreamComparison", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tssStreamComparison");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tssStreamComparison", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< TssStreamComparisonActor<Request>, 0, REPLYSTREAM_TYPE(Request) >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorSingleCallback< TssStreamComparisonActor<Request>, 1, REPLYSTREAM_TYPE(Request) >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class Request>
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> tssStreamComparison( Request const& request, TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)> const& streamData, ReplyPromiseStream<REPLYSTREAM_TYPE(Request)> const& tssReplyStream, TSSEndpointData const& tssData ) {
															#line 4614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new TssStreamComparisonActor<Request>(request, streamData, tssReplyStream, tssData));
															#line 21279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 4735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Currently only used for GetKeyValuesStream but could easily be plugged for other stream types
// User of the stream has to forward the SS's responses to the returned promise stream, if it is set
template <class Request>
Optional<TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)>>
maybeDuplicateTSSStreamFragment(Request& req, QueueModel* model, RequestStream<Request> const* ssStream) {
	if (model) {
		Optional<TSSEndpointData> tssData = model->getTssData(ssStream->getEndpoint().token.first());

		if (tssData.present()) {
			TEST(true); // duplicating stream to TSS
			resetReply(req);
			// FIXME: optimize to avoid creating new netNotifiedQueueWithAcknowledgements for each stream duplication
			RequestStream<Request> tssRequestStream(tssData.get().endpoint);
			ReplyPromiseStream<REPLYSTREAM_TYPE(Request)> tssReplyStream = tssRequestStream.getReplyStream(req);
			PromiseStream<REPLYSTREAM_TYPE(Request)> ssDuplicateReplyStream;
			TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)> streamData(ssDuplicateReplyStream);
			model->addActor.send(tssStreamComparison(req, streamData, tssReplyStream, tssData.get()));
			return Optional<TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)>>(streamData);
		}
	}
	return Optional<TSSDuplicateStreamData<REPLYSTREAM_TYPE(Request)>>();
}

// Streams all of the KV pairs in a target key range into a ParallelStream fragment
															#line 21308 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getRangeStreamFragment()
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetRangeStreamFragmentActor>
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeStreamFragmentActorState {
															#line 21315 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeStreamFragmentActorState(Reference<TransactionState> const& trState,ParallelStream<RangeResult>::Fragment* const& results,Version const& version,KeyRange const& keys,GetRangeLimits const& limits,Snapshot const& snapshot,Reverse const& reverse,SpanID const& spanContext) 
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(results),
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limits(limits),
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   snapshot(snapshot),
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   reverse(reverse),
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   spanContext(spanContext)
															#line 21336 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getRangeStreamFragment", reinterpret_cast<unsigned long>(this));

	}
	~GetRangeStreamFragmentActorState() 
	{
		fdb_probe_actor_destroy("getRangeStreamFragment", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 4768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 21351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetRangeStreamFragmentActorState();
		static_cast<GetRangeStreamFragmentActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 4769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(trState, keys, CLIENT_KNOBS->GET_RANGE_SHARD_LIMIT, reverse, &StorageServerInterface::getKeyValuesStream, UseTenant::True, version);
															#line 4769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 21383 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 1;
															#line 4769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 21388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 4777 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(locations.size());
															#line 4778 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shard = 0;
															#line 4779 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 21401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 4769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 21410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1(int loopDepth) 
	{
															#line 4780 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		const KeyRange& range = locations[shard].range;
															#line 4782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tssDuplicateStream = Optional<TSSDuplicateStreamData<GetKeyValuesStreamReply>>();
															#line 4783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req = GetKeyValuesStreamRequest();
															#line 4784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.tenantInfo = trState->getTenantInfo();
															#line 4785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.version = version;
															#line 4786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.begin = firstGreaterOrEqual(range.begin);
															#line 4787 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.end = firstGreaterOrEqual(range.end);
															#line 4788 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.spanContext = spanContext;
															#line 4789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.limit = reverse ? -CLIENT_KNOBS->REPLY_BYTE_LIMIT : CLIENT_KNOBS->REPLY_BYTE_LIMIT;
															#line 4790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.limitBytes = std::numeric_limits<int>::max();
															#line 4791 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->getLatestCommitVersions( locations[shard].locations, req.version, trState, req.ssLatestCommitVersions);
															#line 4795 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.arena.dependsOn(range.arena());
															#line 4797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(req.limitBytes > 0 && req.limit != 0 && req.limit < 0 == reverse);
															#line 4800 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.tags = trState->cx->sampleReadTags() ? trState->options.readTags : Optional<TagSet>();
															#line 4801 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.debugID = trState->debugID;
															#line 21518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 4804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->debugID.present())
															#line 21522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent( "TransactionDebug", trState->debugID.get().first(), "NativeAPI.RangeStream.Before");
															#line 21526 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReads;
															#line 4809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			rep = GetKeyValuesStreamReply();
															#line 4811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (locations[shard].locations->size() == 0)
															#line 21534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_1 = trState->cx->connectionFileChanged();
															#line 4812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 21540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
				static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 2;
															#line 4812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 1, Void >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 21545 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1loopBody1cont1loopBody1cont2(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 5005 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (tssDuplicateStream.present() && !tssDuplicateStream.get().done())
															#line 21585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5006 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tssDuplicateStream.get().stream.sendError(e);
															#line 21589 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 5008 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_actor_cancelled)
															#line 21593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5009 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 2));
															#line 21597 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 5011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed || e.code() == error_code_connection_failed)
															#line 21601 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5013 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				const KeyRangeRef& range = locations[shard].range;
															#line 5015 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (reverse)
															#line 21607 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 5016 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					keys = KeyRangeRef(keys.begin, range.end);
															#line 21611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 5018 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					keys = KeyRangeRef(range.begin, keys.end);
															#line 21617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 5020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->invalidateCache(locations[0].tenantEntry.prefix, keys);
															#line 5022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_6 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, trState->taskID);
															#line 5022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 21625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1cont1loopBody1Catch1when1(__when_expr_6.get(), loopDepth); };
				static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 6;
															#line 5022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 6, Void >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 21630 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 5024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 21637 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 5025 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(trState->tenant().present());
															#line 5026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->cx->invalidateCachedTenant(trState->tenant().get());
															#line 5027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_7 = delay(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, trState->taskID);
															#line 5027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 21647 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1cont1loopBody1Catch1when2(__when_expr_7.get(), loopDepth); };
					static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 7;
															#line 5027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 7, Void >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 21652 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 5030 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					results->sendError(e);
															#line 5031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!static_cast<GetRangeStreamFragmentActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamFragmentActorState(); static_cast<GetRangeStreamFragmentActor*>(this)->destroy(); return 0; }
															#line 21661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					new (&static_cast<GetRangeStreamFragmentActor*>(this)->SAV< Void >::value()) Void(Void());
					this->~GetRangeStreamFragmentActorState();
					static_cast<GetRangeStreamFragmentActor*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2(int loopDepth) 
	{
															#line 4817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		useIdx = -1;
															#line 4819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 21683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont4(Void const& _,int loopDepth) 
	{
															#line 4813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results->sendError(transaction_too_old());
															#line 4814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamFragmentActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamFragmentActorState(); static_cast<GetRangeStreamFragmentActor*>(this)->destroy(); return 0; }
															#line 21694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamFragmentActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamFragmentActorState();
		static_cast<GetRangeStreamFragmentActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont4(Void && _,int loopDepth) 
	{
															#line 4813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results->sendError(transaction_too_old());
															#line 4814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamFragmentActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamFragmentActorState(); static_cast<GetRangeStreamFragmentActor*>(this)->destroy(); return 0; }
															#line 21708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamFragmentActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamFragmentActorState();
		static_cast<GetRangeStreamFragmentActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorCallback< GetRangeStreamFragmentActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetRangeStreamFragmentActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont1loopBody1cont6(int loopDepth) 
	{
															#line 4858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		replyStream = locations[shard] .locations->get(useIdx, &StorageServerInterface::getKeyValuesStream) .getReplyStream(req);
															#line 4863 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tssDuplicateStream = maybeDuplicateTSSStreamFragment( req, trState->cx->enableLocalityLoadBalance ? &trState->cx->queueModel : nullptr, &locations[shard].locations->get(useIdx, &StorageServerInterface::getKeyValuesStream));
															#line 4868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		breakAgain = false;
															#line 4869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 21789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont6loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2loopBody1(int loopDepth) 
	{
															#line 4822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int count = 0;
															#line 4823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < locations[shard].locations->size();i++) {
															#line 4824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!IFailureMonitor::failureMonitor() .getState(locations[shard] .locations->get(i, &StorageServerInterface::getKeyValuesStream) .getEndpoint()) .failed)
															#line 21809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4829 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (deterministicRandom()->random01() <= 1.0 / ++count)
															#line 21813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					useIdx = i;
															#line 21817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 4835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (useIdx >= 0)
															#line 21823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1cont1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 4839 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<Future<Void>> ok(locations[shard].locations->size());
															#line 4840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < ok.size();i++) {
															#line 4841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ok[i] = IFailureMonitor::failureMonitor().onStateEqual( locations[shard] .locations->get(i, &StorageServerInterface::getKeyValuesStream) .getEndpoint(), FailureStatus(false));
															#line 21833 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (now() - g_network->networkInfo.newestAlternativesFailure > 1 || deterministicRandom()->random01() < 0.01)
															#line 21837 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4851 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("AllAlternativesFailed") .detail("Alternatives", locations[shard].locations->description());
															#line 21841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = allAlternativesFailedDelay(quorum(ok, 1));
															#line 4855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 21847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont1loopBody1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1loopBody1cont2loopBody1when1(__when_expr_2.get(), loopDepth); };
		static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 3;
															#line 4855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 2, Void >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 21852 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont1loopBody1cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2loopBody1cont1(Void const& _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont1loopBody1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2loopBody1cont1(Void && _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont1loopBody1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont2loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont2loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont2loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorCallback< GetRangeStreamFragmentActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetRangeStreamFragmentActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont1loopBody1cont7(int loopDepth) 
	{
															#line 5000 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (breakAgain)
															#line 21949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
		loopDepth = a_body1loopBody1cont1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1(int loopDepth) 
	{
															#line 4870 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = results->onEmpty();
															#line 4870 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 21970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1cont1loopBody1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1loopBody1cont6loopBody1when1(__when_expr_3.get(), loopDepth); };
		static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 4;
															#line 4870 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 3, Void >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 21975 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont1loopBody1cont7(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont1(Void const& _,int loopDepth) 
	{
		try {
															#line 4873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = trState->cx->connectionFileChanged();
															#line 4872 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 22000 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1cont6loopBody1cont1when1(__when_expr_4.get(), loopDepth); };
															#line 4881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			FutureStream<GetKeyValuesStreamReply> __when_expr_5 = replyStream.getFuture();
															#line 22004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1cont6loopBody1cont1when2(__when_expr_5.pop(), loopDepth); };
			static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 5;
															#line 4873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 4, Void >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 4881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 22011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont1(Void && _,int loopDepth) 
	{
		try {
															#line 4873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = trState->cx->connectionFileChanged();
															#line 4872 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 22029 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1cont6loopBody1cont1when1(__when_expr_4.get(), loopDepth); };
															#line 4881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			FutureStream<GetKeyValuesStreamReply> __when_expr_5 = replyStream.getFuture();
															#line 22033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1loopBody1cont1loopBody1cont6loopBody1cont1when2(__when_expr_5.pop(), loopDepth); };
			static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 5;
															#line 4873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamFragmentActor, 4, Void >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 4881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >*>(static_cast<GetRangeStreamFragmentActor*>(this)));
															#line 22040 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorCallback< GetRangeStreamFragmentActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetRangeStreamFragmentActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont2(int loopDepth) 
	{
															#line 4902 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->debugID.present())
															#line 22118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", trState->debugID.get().first(), "NativeAPI.getExactRange.After");
															#line 22122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4905 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		RangeResult output(RangeResultRef(rep.data, rep.more), rep.arena);
															#line 4907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tssDuplicateStream.present() && !tssDuplicateStream.get().done())
															#line 22128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4909 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			GetKeyValuesStreamReply replyCopy;
															#line 4910 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			replyCopy.version = rep.version;
															#line 4911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			replyCopy.more = rep.more;
															#line 4912 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			replyCopy.cached = rep.cached;
															#line 4913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			replyCopy.arena.dependsOn(rep.arena);
															#line 4914 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			replyCopy.data.append(replyCopy.arena, rep.data.begin(), rep.data.size());
															#line 4915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tssDuplicateStream.get().stream.send(replyCopy);
															#line 22144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int64_t bytes = 0;
															#line 4919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const KeyValueRef& kv : output ) {
															#line 4920 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bytes += kv.key.size() + kv.value.size();
															#line 22152 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4923 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->transactionBytesRead += bytes;
															#line 4924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->transactionKeysRead += output.size();
															#line 4927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (reverse && output.more && rep.data.size() > 0 && output[output.size() - 1].key == locations[shard].range.begin)
															#line 22160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.more = false;
															#line 22164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4932 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (output.more)
															#line 22168 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4933 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!rep.data.size())
															#line 22172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4934 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "GetRangeStreamError") .detail("Reason", "More data indicated but no rows present") .detail("LimitBytes", limits.bytes) .detail("LimitRows", limits.rows) .detail("OutputSize", output.size()) .detail("OutputBytes", output.expectedSize()) .detail("BlockSize", rep.data.size()) .detail("BlockBytes", rep.data.expectedSize());
															#line 4942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ASSERT(false);
															#line 22178 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 4946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (reverse)
															#line 22184 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				locations[shard].range = KeyRangeRef(locations[shard].range.begin, output[output.size() - 1].key);
															#line 22188 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 4950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				locations[shard].range = KeyRangeRef(keyAfter(output[output.size() - 1].key), locations[shard].range.end);
															#line 22194 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 4954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations[shard].range.empty())
															#line 22199 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.more = false;
															#line 22203 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4958 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!output.more)
															#line 22207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4959 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			const KeyRange& range = locations[shard].range;
															#line 4960 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (shard == locations.size() - 1)
															#line 22213 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4961 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRef begin = reverse ? keys.begin : range.end;
															#line 4962 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				KeyRef end = reverse ? range.begin : keys.end;
															#line 4964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (begin >= end)
															#line 22221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4965 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (range.begin == allKeys.begin)
															#line 22225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 4966 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						output.readToBegin = true;
															#line 22229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 4968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (range.end == allKeys.end)
															#line 22233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 4969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						output.readThroughEnd = true;
															#line 22237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 4971 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					output.arena().dependsOn(keys.arena());
															#line 4972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					output.readThrough = reverse ? keys.begin : keys.end;
															#line 4973 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					results->send(std::move(output));
															#line 4974 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					results->finish();
															#line 4975 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (tssDuplicateStream.present() && !tssDuplicateStream.get().done())
															#line 22249 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 4976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						tssDuplicateStream.get().stream.sendError(end_of_stream());
															#line 22253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 4978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!static_cast<GetRangeStreamFragmentActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamFragmentActorState(); static_cast<GetRangeStreamFragmentActor*>(this)->destroy(); return 0; }
															#line 22257 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					new (&static_cast<GetRangeStreamFragmentActor*>(this)->SAV< Void >::value()) Void(Void());
					this->~GetRangeStreamFragmentActorState();
					static_cast<GetRangeStreamFragmentActor*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
															#line 4980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				keys = KeyRangeRef(begin, end);
															#line 4981 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				breakAgain = true;
															#line 22267 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 4983 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				++shard;
															#line 22273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.arena().dependsOn(range.arena());
															#line 4986 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.readThrough = reverse ? range.begin : range.end;
															#line 4987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->send(std::move(output));
															#line 22281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return a_body1loopBody1cont1loopBody1cont6break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 4991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(output.size());
															#line 4992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (keys.begin == allKeys.begin && !reverse)
															#line 22288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4993 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.readToBegin = true;
															#line 22292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4995 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (keys.end == allKeys.end && reverse)
															#line 22296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			output.readThroughEnd = true;
															#line 22300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4998 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results->send(std::move(output));
															#line 22304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont1loopBody1cont6loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 4887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionPhysicalReadsCompleted;
															#line 4888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_broken_promise)
															#line 22316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (tssDuplicateStream.present() && !tssDuplicateStream.get().done())
															#line 22320 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4890 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					tssDuplicateStream.get().stream.sendError(connection_failed());
															#line 22324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 4892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1loopBody1cont1loopBody1Catch1(connection_failed(), std::max(0, loopDepth - 1));
															#line 22328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4894 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_end_of_stream)
															#line 22332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 4895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (tssDuplicateStream.present() && !tssDuplicateStream.get().done())
															#line 22336 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 4896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					tssDuplicateStream.get().stream.sendError(e);
															#line 22340 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 4898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1loopBody1cont1loopBody1Catch1(e, std::max(0, loopDepth - 1));
															#line 22344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 4900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			rep = GetKeyValuesStreamReply();
															#line 22348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont3(int loopDepth) 
	{
															#line 4885 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionPhysicalReadsCompleted;
															#line 22363 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont1when1(Void const& _,int loopDepth) 
	{
															#line 4874 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results->sendError(transaction_too_old());
															#line 4875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tssDuplicateStream.present() && !tssDuplicateStream.get().done())
															#line 22374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tssDuplicateStream.get().stream.sendError(transaction_too_old());
															#line 22378 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamFragmentActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamFragmentActorState(); static_cast<GetRangeStreamFragmentActor*>(this)->destroy(); return 0; }
															#line 22382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamFragmentActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamFragmentActorState();
		static_cast<GetRangeStreamFragmentActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont1when1(Void && _,int loopDepth) 
	{
															#line 4874 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results->sendError(transaction_too_old());
															#line 4875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tssDuplicateStream.present() && !tssDuplicateStream.get().done())
															#line 22396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 4876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tssDuplicateStream.get().stream.sendError(transaction_too_old());
															#line 22400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 4878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamFragmentActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamFragmentActorState(); static_cast<GetRangeStreamFragmentActor*>(this)->destroy(); return 0; }
															#line 22404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamFragmentActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamFragmentActorState();
		static_cast<GetRangeStreamFragmentActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont1when2(GetKeyValuesStreamReply const& _rep,int loopDepth) 
	{
															#line 4882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 22416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont1when2(GetKeyValuesStreamReply && _rep,int loopDepth) 
	{
															#line 4882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = _rep;
															#line 22425 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorCallback< GetRangeStreamFragmentActor, 4, Void >::remove();
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetRangeStreamFragmentActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >*,GetKeyValuesStreamReply const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >*,GetKeyValuesStreamReply && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1loopBody1cont6loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1loopBody1cont1loopBody1cont6loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1loopBody1cont6loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1cont1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont10(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1cont4(Void const& _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1cont4(Void && _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorCallback< GetRangeStreamFragmentActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1loopBody1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1loopBody1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< GetRangeStreamFragmentActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1loopBody1cont1loopBody1Catch1cont9(Void const& _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1cont9(Void && _,int loopDepth) 
	{
		return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1Catch1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1Catch1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamFragmentActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamFragmentActor*>(this)->ActorCallback< GetRangeStreamFragmentActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1loopBody1cont1loopBody1Catch1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamFragmentActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1loopBody1cont1loopBody1Catch1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< GetRangeStreamFragmentActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), 7);

	}
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ParallelStream<RangeResult>::Fragment* results;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeLimits limits;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Snapshot snapshot;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reverse reverse;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID spanContext;
															#line 4769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 4778 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int shard;
															#line 4782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<TSSDuplicateStreamData<GetKeyValuesStreamReply>> tssDuplicateStream;
															#line 4783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyValuesStreamRequest req;
															#line 4809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyValuesStreamReply rep;
															#line 4817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int useIdx;
															#line 4858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReplyPromiseStream<GetKeyValuesStreamReply> replyStream;
															#line 4868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool breakAgain;
															#line 22735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getRangeStreamFragment()
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeStreamFragmentActor final : public Actor<Void>, public ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetRangeStreamFragmentActor, 1, Void >, public ActorCallback< GetRangeStreamFragmentActor, 2, Void >, public ActorCallback< GetRangeStreamFragmentActor, 3, Void >, public ActorCallback< GetRangeStreamFragmentActor, 4, Void >, public ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >, public ActorCallback< GetRangeStreamFragmentActor, 6, Void >, public ActorCallback< GetRangeStreamFragmentActor, 7, Void >, public FastAllocated<GetRangeStreamFragmentActor>, public GetRangeStreamFragmentActorState<GetRangeStreamFragmentActor> {
															#line 22740 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetRangeStreamFragmentActor>::operator new;
	using FastAllocated<GetRangeStreamFragmentActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetRangeStreamFragmentActor, 1, Void >;
friend struct ActorCallback< GetRangeStreamFragmentActor, 2, Void >;
friend struct ActorCallback< GetRangeStreamFragmentActor, 3, Void >;
friend struct ActorCallback< GetRangeStreamFragmentActor, 4, Void >;
friend struct ActorSingleCallback< GetRangeStreamFragmentActor, 5, GetKeyValuesStreamReply >;
friend struct ActorCallback< GetRangeStreamFragmentActor, 6, Void >;
friend struct ActorCallback< GetRangeStreamFragmentActor, 7, Void >;
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeStreamFragmentActor(Reference<TransactionState> const& trState,ParallelStream<RangeResult>::Fragment* const& results,Version const& version,KeyRange const& keys,GetRangeLimits const& limits,Snapshot const& snapshot,Reverse const& reverse,SpanID const& spanContext) 
															#line 22758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   GetRangeStreamFragmentActorState<GetRangeStreamFragmentActor>(trState, results, version, keys, limits, snapshot, reverse, spanContext)
	{
		fdb_probe_actor_enter("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getRangeStreamFragment");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getRangeStreamFragment", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetRangeStreamFragmentActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetRangeStreamFragmentActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetRangeStreamFragmentActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetRangeStreamFragmentActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetRangeStreamFragmentActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< GetRangeStreamFragmentActor, 6, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< GetRangeStreamFragmentActor, 7, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> getRangeStreamFragment( Reference<TransactionState> const& trState, ParallelStream<RangeResult>::Fragment* const& results, Version const& version, KeyRange const& keys, GetRangeLimits const& limits, Snapshot const& snapshot, Reverse const& reverse, SpanID const& spanContext ) {
															#line 4760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new GetRangeStreamFragmentActor(trState, results, version, keys, limits, snapshot, reverse, spanContext));
															#line 22792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 5037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 22797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
[[nodiscard]] Future<Standalone<VectorRef<KeyRef>>> getRangeSplitPoints( Reference<TransactionState> const& trState, KeyRange const& keys, int64_t const& chunkSize, Version const& version );

#line 5042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

static KeyRange intersect(KeyRangeRef lhs, KeyRangeRef rhs) {
	return KeyRange(KeyRangeRef(std::max(lhs.begin, rhs.begin), std::min(lhs.end, rhs.end)));
}

// Divides the requested key range into 1MB fragments, create range streams for each fragment, and merges the results so
// the client get them in order
															#line 22808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getRangeStream()
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetRangeStreamActor>
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeStreamActorState {
															#line 22815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeStreamActorState(Reference<TransactionState> const& trState,PromiseStream<RangeResult> const& _results,Future<Version> const& fVersion,KeySelector const& begin,KeySelector const& end,GetRangeLimits const& limits,Promise<std::pair<Key, Key>> const& conflictRange,Snapshot const& snapshot,Reverse const& reverse) 
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   _results(_results),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   fVersion(fVersion),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limits(limits),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   conflictRange(conflictRange),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   snapshot(snapshot),
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   reverse(reverse),
															#line 5058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(_results, CLIENT_KNOBS->RANGESTREAM_BUFFERED_FRAGMENTS_LIMIT)
															#line 22840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getRangeStream", reinterpret_cast<unsigned long>(this));

	}
	~GetRangeStreamActorState() 
	{
		fdb_probe_actor_destroy("getRangeStream", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 5061 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(!limits.hasRowLimit());
															#line 5062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			span = Span("NAPI:getRangeStream"_loc, trState->spanID);
															#line 5064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Version> __when_expr_0 = fVersion;
															#line 5064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 1;
															#line 5064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 0, Version >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 22866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetRangeStreamActorState();
		static_cast<GetRangeStreamActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 5065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->validateVersion(version);
															#line 5067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Future<Key> fb = resolveKey(trState, begin, version, UseTenant::True);
															#line 5068 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		fe = resolveKey(trState, end, version, UseTenant::True);
															#line 5070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Key> __when_expr_1 = fb;
															#line 5070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 2;
															#line 5070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 1, Key >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 22902 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Version const& __version,int loopDepth) 
	{
															#line 5064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = __version;
															#line 22911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && __version,int loopDepth) 
	{
		version = std::move(__version);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 5071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Key> __when_expr_2 = fe;
															#line 5071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 3;
															#line 5071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 2, Key >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 22985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(Key const& __b,int loopDepth) 
	{
															#line 5070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		b = __b;
															#line 22994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Key && __b,int loopDepth) 
	{
		b = std::move(__b);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 1, Key >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 1, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 1, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 1, Key >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 5073 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!snapshot)
															#line 23061 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			conflictRange.send(std::make_pair(std::min(b, Key(begin.getKey(), begin.arena())), std::max(e, Key(end.getKey(), end.arena()))));
															#line 23065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 5079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (b >= e)
															#line 23069 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = results.finish();
															#line 5080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 23075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont3when1(__when_expr_3.get(), loopDepth); };
			static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 4;
															#line 5080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 3, Void >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 23080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2when1(Key const& __e,int loopDepth) 
	{
															#line 5071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		e = __e;
															#line 23094 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Key && __e,int loopDepth) 
	{
		e = std::move(__e);
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 2, Key >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 2, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 2, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 2, Key >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont4(int loopDepth) 
	{
															#line 5088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		outstandingRequests = std::vector<Future<Void>>();
															#line 5089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 23163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont4loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont6(Void const& _,int loopDepth) 
	{
															#line 5081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamActorState(); static_cast<GetRangeStreamActor*>(this)->destroy(); return 0; }
															#line 23172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamActorState();
		static_cast<GetRangeStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6(Void && _,int loopDepth) 
	{
															#line 5081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamActorState(); static_cast<GetRangeStreamActor*>(this)->destroy(); return 0; }
															#line 23184 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamActorState();
		static_cast<GetRangeStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont8(int loopDepth) 
	{
															#line 5125 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_7 = waitForAll(outstandingRequests) && results.finish();
															#line 5125 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 23261 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont8when1(__when_expr_7.get(), loopDepth); };
		static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 8;
															#line 5125 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 7, Void >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 23266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont4loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1(int loopDepth) 
	{
															#line 5089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(b < e))
															#line 23282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont4break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 5090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<KeyRangeLocationInfo> __when_expr_4 = getKeyLocation( trState, reverse ? e : b, &StorageServerInterface::getKeyValuesStream, reverse, UseTenant::True, version);
															#line 5090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 23290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont4loopBody1when1(__when_expr_4.get(), loopDepth); };
		static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 5;
															#line 5090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 23295 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4break1(int loopDepth) 
	{
		try {
			return a_body1cont8(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont4loopBody1cont1(int loopDepth) 
	{
															#line 5092 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		shardIntersection = intersect(locationInfo.range, KeyRangeRef(b, e));
															#line 5093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Standalone<VectorRef<KeyRef>>> __when_expr_5 = getRangeSplitPoints(trState, shardIntersection, CLIENT_KNOBS->RANGESTREAM_FRAGMENT_SIZE, version);
															#line 5093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 23321 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont4loopBody1cont1when1(__when_expr_5.get(), loopDepth); };
		static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 6;
															#line 5093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 23326 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4loopBody1when1(KeyRangeLocationInfo const& __locationInfo,int loopDepth) 
	{
															#line 5090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locationInfo = __locationInfo;
															#line 23335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont4loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1when1(KeyRangeLocationInfo && __locationInfo,int loopDepth) 
	{
		locationInfo = std::move(__locationInfo);
		loopDepth = a_body1cont4loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont4loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont4loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont4loopBody1cont3(int loopDepth) 
	{
															#line 5095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		toSend = std::vector<KeyRange>();
															#line 5098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!splitPoints.empty())
															#line 23404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			toSend.push_back(KeyRange(KeyRangeRef(shardIntersection.begin, splitPoints.front()), splitPoints.arena()));
															#line 5100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < splitPoints.size() - 1;++i) {
															#line 5101 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				toSend.push_back(KeyRange(KeyRangeRef(splitPoints[i], splitPoints[i + 1]), splitPoints.arena()));
															#line 23412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 5103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			toSend.push_back(KeyRange(KeyRangeRef(splitPoints.back(), shardIntersection.end), splitPoints.arena()));
															#line 23416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 5105 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			toSend.push_back(KeyRange(KeyRangeRef(shardIntersection.begin, shardIntersection.end)));
															#line 23422 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 5108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		idx = 0;
															#line 5109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		useIdx = 0;
															#line 5110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 23430 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont4loopBody1cont3loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont1when1(Standalone<VectorRef<KeyRef>> const& __splitPoints,int loopDepth) 
	{
															#line 5093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		splitPoints = __splitPoints;
															#line 23439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont4loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont1when1(Standalone<VectorRef<KeyRef>> && __splitPoints,int loopDepth) 
	{
		splitPoints = std::move(__splitPoints);
		loopDepth = a_body1cont4loopBody1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >*,Standalone<VectorRef<KeyRef>> const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont4loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >*,Standalone<VectorRef<KeyRef>> && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont4loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont4loopBody1cont4(int loopDepth) 
	{
															#line 5119 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (reverse)
															#line 23506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			e = shardIntersection.begin;
															#line 23510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 5122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			b = shardIntersection.end;
															#line 23516 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		if (loopDepth == 0) return a_body1cont4loopHead1(0);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont4loopBody1cont3loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3loopBody1(int loopDepth) 
	{
															#line 5110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(idx < toSend.size()))
															#line 23533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont4loopBody1cont3break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 5111 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		useIdx = reverse ? toSend.size() - idx - 1 : idx;
															#line 5112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (toSend[useIdx].empty())
															#line 23541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont4loopBody1cont3continue1(loopDepth); // continue
		}
															#line 5115 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<ParallelStream<RangeResult>::Fragment*> __when_expr_6 = results.createFragment();
															#line 5115 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 23549 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), std::max(0, loopDepth - 2)); else return a_body1cont4loopBody1cont3loopBody1when1(__when_expr_6.get(), loopDepth); };
		static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 7;
															#line 5115 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >*>(static_cast<GetRangeStreamActor*>(this)));
															#line 23554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3break1(int loopDepth) 
	{
		try {
			return a_body1cont4loopBody1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3continue1(int loopDepth) 
	{
															#line 5110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++idx;
															#line 23576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont4loopBody1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3loopBody1cont1(ParallelStream<RangeResult>::Fragment* const& fragment,int loopDepth) 
	{
															#line 5116 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		outstandingRequests.push_back(getRangeStreamFragment( trState, fragment, version, toSend[useIdx], limits, snapshot, reverse, span.context));
															#line 5110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++idx;
															#line 23587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont4loopBody1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3loopBody1cont1(ParallelStream<RangeResult>::Fragment* && fragment,int loopDepth) 
	{
															#line 5116 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		outstandingRequests.push_back(getRangeStreamFragment( trState, fragment, version, toSend[useIdx], limits, snapshot, reverse, span.context));
															#line 5110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++idx;
															#line 23598 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont4loopBody1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3loopBody1when1(ParallelStream<RangeResult>::Fragment* const& fragment,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1cont3loopBody1cont1(fragment, loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1cont3loopBody1when1(ParallelStream<RangeResult>::Fragment* && fragment,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1cont3loopBody1cont1(std::move(fragment), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >*,ParallelStream<RangeResult>::Fragment* const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont4loopBody1cont3loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >*,ParallelStream<RangeResult>::Fragment* && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont4loopBody1cont3loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont9(Void const& _,int loopDepth) 
	{
															#line 5126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamActorState(); static_cast<GetRangeStreamActor*>(this)->destroy(); return 0; }
															#line 23670 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamActorState();
		static_cast<GetRangeStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont9(Void && _,int loopDepth) 
	{
															#line 5126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetRangeStreamActorState(); static_cast<GetRangeStreamActor*>(this)->destroy(); return 0; }
															#line 23682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~GetRangeStreamActorState();
		static_cast<GetRangeStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont8when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont8when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<GetRangeStreamActor*>(this)->actor_wait_state > 0) static_cast<GetRangeStreamActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeStreamActor*>(this)->ActorCallback< GetRangeStreamActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont8when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< GetRangeStreamActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont8when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< GetRangeStreamActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), 7);

	}
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<RangeResult> _results;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> fVersion;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector begin;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector end;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeLimits limits;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<std::pair<Key, Key>> conflictRange;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Snapshot snapshot;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reverse reverse;
															#line 5058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ParallelStream<RangeResult> results;
															#line 5062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 5064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 5068 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Key> fe;
															#line 5070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key b;
															#line 5071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key e;
															#line 5088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<Void>> outstandingRequests;
															#line 5090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeLocationInfo locationInfo;
															#line 5092 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange shardIntersection;
															#line 5093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Standalone<VectorRef<KeyRef>> splitPoints;
															#line 5095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRange> toSend;
															#line 5108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int idx;
															#line 5109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int useIdx;
															#line 23797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getRangeStream()
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeStreamActor final : public Actor<Void>, public ActorCallback< GetRangeStreamActor, 0, Version >, public ActorCallback< GetRangeStreamActor, 1, Key >, public ActorCallback< GetRangeStreamActor, 2, Key >, public ActorCallback< GetRangeStreamActor, 3, Void >, public ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >, public ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >, public ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >, public ActorCallback< GetRangeStreamActor, 7, Void >, public FastAllocated<GetRangeStreamActor>, public GetRangeStreamActorState<GetRangeStreamActor> {
															#line 23802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetRangeStreamActor>::operator new;
	using FastAllocated<GetRangeStreamActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetRangeStreamActor, 0, Version >;
friend struct ActorCallback< GetRangeStreamActor, 1, Key >;
friend struct ActorCallback< GetRangeStreamActor, 2, Key >;
friend struct ActorCallback< GetRangeStreamActor, 3, Void >;
friend struct ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >;
friend struct ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >;
friend struct ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >;
friend struct ActorCallback< GetRangeStreamActor, 7, Void >;
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeStreamActor(Reference<TransactionState> const& trState,PromiseStream<RangeResult> const& _results,Future<Version> const& fVersion,KeySelector const& begin,KeySelector const& end,GetRangeLimits const& limits,Promise<std::pair<Key, Key>> const& conflictRange,Snapshot const& snapshot,Reverse const& reverse) 
															#line 23820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   GetRangeStreamActorState<GetRangeStreamActor>(trState, _results, fVersion, begin, end, limits, conflictRange, snapshot, reverse)
	{
		fdb_probe_actor_enter("getRangeStream", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getRangeStream");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getRangeStream", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetRangeStreamActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetRangeStreamActor, 1, Key >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetRangeStreamActor, 2, Key >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetRangeStreamActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetRangeStreamActor, 4, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< GetRangeStreamActor, 5, Standalone<VectorRef<KeyRef>> >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< GetRangeStreamActor, 6, ParallelStream<RangeResult>::Fragment* >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< GetRangeStreamActor, 7, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> getRangeStream( Reference<TransactionState> const& trState, PromiseStream<RangeResult> const& _results, Future<Version> const& fVersion, KeySelector const& begin, KeySelector const& end, GetRangeLimits const& limits, Promise<std::pair<Key, Key>> const& conflictRange, Snapshot const& snapshot, Reverse const& reverse ) {
															#line 5049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new GetRangeStreamActor(trState, _results, fVersion, begin, end, limits, conflictRange, snapshot, reverse));
															#line 23855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 5128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<RangeResult> getRange(Reference<TransactionState> const& trState,
                             Future<Version> const& fVersion,
                             KeySelector const& begin,
                             KeySelector const& end,
                             GetRangeLimits const& limits,
                             Reverse const& reverse,
                             UseTenant const& useTenant) {
	return getRange<GetKeyValuesRequest, GetKeyValuesReply, RangeResult>(trState,
	                                                                     fVersion,
	                                                                     begin,
	                                                                     end,
	                                                                     ""_sr,
	                                                                     limits,
	                                                                     Promise<std::pair<Key, Key>>(),
	                                                                     Snapshot::True,
	                                                                     reverse,
	                                                                     useTenant);
}

bool DatabaseContext::debugUseTags = false;
const std::vector<std::string> DatabaseContext::debugTransactionTagChoices = { "a", "b", "c", "d", "e", "f", "g",
	                                                                           "h", "i", "j", "k", "l", "m", "n",
	                                                                           "o", "p", "q", "r", "s", "t" };

void debugAddTags(Reference<TransactionState> trState) {
	int numTags = deterministicRandom()->randomInt(0, CLIENT_KNOBS->MAX_TAGS_PER_TRANSACTION + 1);
	for (int i = 0; i < numTags; ++i) {
		TransactionTag tag;
		if (deterministicRandom()->random01() < 0.7) {
			tag = TransactionTagRef(deterministicRandom()->randomChoice(DatabaseContext::debugTransactionTagChoices));
		} else {
			int length = deterministicRandom()->randomInt(1, CLIENT_KNOBS->MAX_TRANSACTION_TAG_LENGTH + 1);
			uint8_t* s = new (tag.arena()) uint8_t[length];
			for (int j = 0; j < length; ++j) {
				s[j] = (uint8_t)deterministicRandom()->randomInt(0, 256);
			}

			tag.contents() = TransactionTagRef(s, length);
		}

		if (deterministicRandom()->coinflip()) {
			trState->options.readTags.addTag(tag);
		}
		trState->options.tags.addTag(tag);
	}
}

Transaction::Transaction()
  : trState(makeReference<TransactionState>(TaskPriority::DefaultEndpoint, generateSpanID(false))) {}

Transaction::Transaction(Database const& cx, Optional<TenantName> const& tenant)
  : trState(makeReference<TransactionState>(cx,
                                            tenant,
                                            cx->taskID,
                                            generateSpanID(cx->transactionTracingSample),
                                            createTrLogInfoProbabilistically(cx))),
    span(trState->spanID, "Transaction"_loc), backoff(CLIENT_KNOBS->DEFAULT_BACKOFF), tr(trState->spanID) {
	if (DatabaseContext::debugUseTags) {
		debugAddTags(trState);
	}
}

Transaction::~Transaction() {
	flushTrLogsIfEnabled();
	cancelWatches();
}

void Transaction::operator=(Transaction&& r) noexcept {
	flushTrLogsIfEnabled();
	tr = std::move(r.tr);
	readVersion = std::move(r.readVersion);
	trState = std::move(r.trState);
	metadataVersion = std::move(r.metadataVersion);
	extraConflictRanges = std::move(r.extraConflictRanges);
	commitResult = std::move(r.commitResult);
	committing = std::move(r.committing);
	backoff = r.backoff;
	watches = r.watches;
}

void Transaction::flushTrLogsIfEnabled() {
	if (trState && trState->trLogInfo && trState->trLogInfo->logsAdded && trState->trLogInfo->trLogWriter.getData()) {
		ASSERT(trState->trLogInfo->flushed == false);
		trState->cx->clientStatusUpdater.inStatusQ.push_back(
		    { trState->trLogInfo->identifier, std::move(trState->trLogInfo->trLogWriter) });
		trState->trLogInfo->flushed = true;
	}
}

VersionVector Transaction::getVersionVector() const {
	return trState->cx->ssVersionVectorCache;
}

void Transaction::setVersion(Version v) {
	trState->startTime = now();
	if (readVersion.isValid())
		throw read_version_already_set();
	if (v <= 0)
		throw version_invalid();

	readVersion = v;
	trState->readVersionObtainedFromGrvProxy = false;
}

Future<Optional<Value>> Transaction::get(const Key& key, Snapshot snapshot) {
	++trState->cx->transactionLogicalReads;
	++trState->cx->transactionGetValueRequests;
	// ASSERT (key < allKeys.end);

	// There are no keys in the database with size greater than the max key size
	if (key.size() > getMaxReadKeySize(key)) {
		return Optional<Value>();
	}

	auto ver = getReadVersion();

	/*	if (!systemKeys.contains(key))
	        return Optional<Value>(Value()); */

	if (!snapshot)
		tr.transaction.read_conflict_ranges.push_back(tr.arena, singleKeyRange(key, tr.arena));

	UseTenant useTenant = UseTenant::True;
	if (key == metadataVersionKey) {
		// It is legal to read the metadata version key inside of a tenant.
		// This will return the global metadata version key.
		useTenant = UseTenant::False;
		++trState->cx->transactionMetadataVersionReads;
		if (!ver.isReady() || metadataVersion.isSet()) {
			return metadataVersion.getFuture();
		} else {
			if (ver.isError())
				return ver.getError();
			if (ver.get() == trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation].first) {
				return trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation].second;
			}

			Version v = ver.get();
			int hi = trState->cx->mvCacheInsertLocation;
			int lo = (trState->cx->mvCacheInsertLocation + 1) % trState->cx->metadataVersionCache.size();

			while (hi != lo) {
				int cu = hi > lo ? (hi + lo) / 2
				                 : ((hi + trState->cx->metadataVersionCache.size() + lo) / 2) %
				                       trState->cx->metadataVersionCache.size();
				if (v == trState->cx->metadataVersionCache[cu].first) {
					return trState->cx->metadataVersionCache[cu].second;
				}
				if (cu == lo) {
					break;
				}
				if (v < trState->cx->metadataVersionCache[cu].first) {
					hi = cu;
				} else {
					lo = (cu + 1) % trState->cx->metadataVersionCache.size();
				}
			}
		}
	}

	return getValue(trState, key, ver, useTenant);
}

void Watch::setWatch(Future<Void> watchFuture) {
	this->watchFuture = watchFuture;

	// Cause the watch loop to go around and start waiting on watchFuture
	onSetWatchTrigger.send(Void());
}

															#line 24030 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getTenantMetadata()
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetTenantMetadataActor>
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetTenantMetadataActorState {
															#line 24037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetTenantMetadataActorState(Reference<TransactionState> const& trState,Key const& key,Version const& version) 
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   key(key),
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version)
															#line 24048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getTenantMetadata", reinterpret_cast<unsigned long>(this));

	}
	~GetTenantMetadataActorState() 
	{
		fdb_probe_actor_destroy("getTenantMetadata", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 5300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<KeyRangeLocationInfo> __when_expr_0 = getKeyLocation(trState, key, &StorageServerInterface::getValue, Reverse::False, UseTenant::True, version);
															#line 5300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetTenantMetadataActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetTenantMetadataActor*>(this)->actor_wait_state = 1;
															#line 5300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >*>(static_cast<GetTenantMetadataActor*>(this)));
															#line 24070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetTenantMetadataActorState();
		static_cast<GetTenantMetadataActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(KeyRangeLocationInfo const& locationInfo,int loopDepth) 
	{
															#line 5302 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetTenantMetadataActor*>(this)->SAV<TenantInfo>::futures) { (void)(trState->getTenantInfo()); this->~GetTenantMetadataActorState(); static_cast<GetTenantMetadataActor*>(this)->destroy(); return 0; }
															#line 24093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetTenantMetadataActor*>(this)->SAV< TenantInfo >::value()) TenantInfo(trState->getTenantInfo());
		this->~GetTenantMetadataActorState();
		static_cast<GetTenantMetadataActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(KeyRangeLocationInfo && locationInfo,int loopDepth) 
	{
															#line 5302 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetTenantMetadataActor*>(this)->SAV<TenantInfo>::futures) { (void)(trState->getTenantInfo()); this->~GetTenantMetadataActorState(); static_cast<GetTenantMetadataActor*>(this)->destroy(); return 0; }
															#line 24105 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetTenantMetadataActor*>(this)->SAV< TenantInfo >::value()) TenantInfo(trState->getTenantInfo());
		this->~GetTenantMetadataActorState();
		static_cast<GetTenantMetadataActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(KeyRangeLocationInfo const& locationInfo,int loopDepth) 
	{
		loopDepth = a_body1cont1(locationInfo, loopDepth);

		return loopDepth;
	}
	int a_body1when1(KeyRangeLocationInfo && locationInfo,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(locationInfo), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetTenantMetadataActor*>(this)->actor_wait_state > 0) static_cast<GetTenantMetadataActor*>(this)->actor_wait_state = 0;
		static_cast<GetTenantMetadataActor*>(this)->ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("getTenantMetadata", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getTenantMetadata", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("getTenantMetadata", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getTenantMetadata", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("getTenantMetadata", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getTenantMetadata", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key key;
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 24182 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getTenantMetadata()
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetTenantMetadataActor final : public Actor<TenantInfo>, public ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >, public FastAllocated<GetTenantMetadataActor>, public GetTenantMetadataActorState<GetTenantMetadataActor> {
															#line 24187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetTenantMetadataActor>::operator new;
	using FastAllocated<GetTenantMetadataActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<TenantInfo>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >;
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetTenantMetadataActor(Reference<TransactionState> const& trState,Key const& key,Version const& version) 
															#line 24198 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<TenantInfo>(),
		   GetTenantMetadataActorState<GetTenantMetadataActor>(trState, key, version)
	{
		fdb_probe_actor_enter("getTenantMetadata", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getTenantMetadata");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getTenantMetadata", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetTenantMetadataActor, 0, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<TenantInfo> getTenantMetadata( Reference<TransactionState> const& trState, Key const& key, Version const& version ) {
															#line 5299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<TenantInfo>(new GetTenantMetadataActor(trState, key, version));
															#line 24226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 5304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<TenantInfo> populateAndGetTenant(Reference<TransactionState> trState, Key const& key, Version version) {
	if (!trState->tenant().present() || key == metadataVersionKey) {
		return TenantInfo();
	} else if (trState->tenantId != TenantInfo::INVALID_TENANT) {
		return trState->getTenantInfo();
	} else {
		return getTenantMetadata(trState, key, version);
	}
}

// FIXME: This seems pretty horrible. Now a Database can't die until all of its watches do...
															#line 24242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via watch()
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WatchActor>
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchActorState {
															#line 24249 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchActorState(Reference<Watch> const& watch,Database const& cx,Future<TenantInfo> const& tenant,TagSet const& tags,SpanID const& spanID,TaskPriority const& taskID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies) 
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : watch(watch),
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(cx),
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tenant(tenant),
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tags(tags),
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   spanID(spanID),
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   taskID(taskID),
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugID(debugID),
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   useProvisionalProxies(useProvisionalProxies)
															#line 24270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("watch", reinterpret_cast<unsigned long>(this));

	}
	~WatchActorState() 
	{
		fdb_probe_actor_destroy("watch", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 5328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_0 = watch->onChangeTrigger.getFuture();
															#line 5325 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<WatchActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 24288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 5331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_1 = watch->onSetWatchTrigger.getFuture();
															#line 24292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
				static_cast<WatchActor*>(this)->actor_wait_state = 1;
															#line 5328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WatchActor, 0, Void >*>(static_cast<WatchActor*>(this)));
															#line 5331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WatchActor, 1, Void >*>(static_cast<WatchActor*>(this)));
															#line 24299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WatchActorState();
		static_cast<WatchActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 5364 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->removeWatch();
															#line 5365 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WatchActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WatchActorState(); static_cast<WatchActor*>(this)->destroy(); return 0; }
															#line 24330 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WatchActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~WatchActorState();
		static_cast<WatchActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 5360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->removeWatch();
															#line 5361 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 24345 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<TenantInfo> __when_expr_2 = tenant;
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 24379 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch2(__when_expr_2.getError(), loopDepth); else return a_body1when2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WatchActor*>(this)->actor_wait_state = 2;
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WatchActor, 2, TenantInfo >*>(static_cast<WatchActor*>(this)));
															#line 24384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<TenantInfo> __when_expr_2 = tenant;
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 24395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch2(__when_expr_2.getError(), loopDepth); else return a_body1when2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WatchActor*>(this)->actor_wait_state = 2;
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WatchActor, 2, TenantInfo >*>(static_cast<WatchActor*>(this)));
															#line 24400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WatchActor*>(this)->actor_wait_state > 0) static_cast<WatchActor*>(this)->actor_wait_state = 0;
		static_cast<WatchActor*>(this)->ActorCallback< WatchActor, 0, Void >::remove();
		static_cast<WatchActor*>(this)->ActorCallback< WatchActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WatchActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WatchActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1when2cont1(int loopDepth) 
	{
															#line 5334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 24461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1when2cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when2when1(TenantInfo const& __tenantInfo,int loopDepth) 
	{
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tenantInfo = __tenantInfo;
															#line 24470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1when2cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when2when1(TenantInfo && __tenantInfo,int loopDepth) 
	{
		tenantInfo = std::move(__tenantInfo);
		loopDepth = a_body1when2cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WatchActor*>(this)->actor_wait_state > 0) static_cast<WatchActor*>(this)->actor_wait_state = 0;
		static_cast<WatchActor*>(this)->ActorCallback< WatchActor, 2, TenantInfo >::remove();

	}
	void a_callback_fire(ActorCallback< WatchActor, 2, TenantInfo >*,TenantInfo const& value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1when2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WatchActor, 2, TenantInfo >*,TenantInfo && value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1when2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WatchActor, 2, TenantInfo >*,Error err) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1when2cont2(int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when2cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1when2cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1when2cont1loopBody1(int loopDepth) 
	{
															#line 5337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = watch->watchFuture;
															#line 5335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WatchActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 24552 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch2(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1when2cont1loopBody1when1(__when_expr_3.get(), loopDepth); };
															#line 5341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_4 = cx->connectionFileChanged();
															#line 24556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch2(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1when2cont1loopBody1when2(__when_expr_4.get(), loopDepth); };
		static_cast<WatchActor*>(this)->actor_wait_state = 3;
															#line 5337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WatchActor, 3, Void >*>(static_cast<WatchActor*>(this)));
															#line 5341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< WatchActor, 4, Void >*>(static_cast<WatchActor*>(this)));
															#line 24563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when2cont1break1(int loopDepth) 
	{
		try {
			return a_body1when2cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1when2cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1when2cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1when2cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		return a_body1when2cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1when2cont1loopBody1when1(Void && _,int loopDepth) 
	{
		return a_body1when2cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1when2cont1loopBody1when2(Void const& _,int loopDepth) 
	{
															#line 5342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TEST(true);
															#line 5343 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->clearWatchMetadata();
															#line 5344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		watch->watchFuture = watchValueMap(cx->minAcceptableReadVersion, tenantInfo, watch->key, watch->value, cx, tags, spanID, taskID, debugID, useProvisionalProxies);
															#line 24607 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1when2cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when2cont1loopBody1when2(Void && _,int loopDepth) 
	{
															#line 5342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TEST(true);
															#line 5343 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->clearWatchMetadata();
															#line 5344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		watch->watchFuture = watchValueMap(cx->minAcceptableReadVersion, tenantInfo, watch->key, watch->value, cx, tags, spanID, taskID, debugID, useProvisionalProxies);
															#line 24620 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1when2cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WatchActor*>(this)->actor_wait_state > 0) static_cast<WatchActor*>(this)->actor_wait_state = 0;
		static_cast<WatchActor*>(this)->ActorCallback< WatchActor, 3, Void >::remove();
		static_cast<WatchActor*>(this)->ActorCallback< WatchActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WatchActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1when2cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WatchActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1when2cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WatchActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WatchActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1when2cont1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< WatchActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1when2cont1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< WatchActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< WatchActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WatchActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WatchActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<Watch> watch;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<TenantInfo> tenant;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TagSet tags;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID spanID;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TaskPriority taskID;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> debugID;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UseProvisionalProxies useProvisionalProxies;
															#line 5333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TenantInfo tenantInfo;
															#line 24798 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via watch()
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WatchActor final : public Actor<Void>, public ActorCallback< WatchActor, 0, Void >, public ActorCallback< WatchActor, 1, Void >, public ActorCallback< WatchActor, 2, TenantInfo >, public ActorCallback< WatchActor, 3, Void >, public ActorCallback< WatchActor, 4, Void >, public FastAllocated<WatchActor>, public WatchActorState<WatchActor> {
															#line 24803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WatchActor>::operator new;
	using FastAllocated<WatchActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WatchActor, 0, Void >;
friend struct ActorCallback< WatchActor, 1, Void >;
friend struct ActorCallback< WatchActor, 2, TenantInfo >;
friend struct ActorCallback< WatchActor, 3, Void >;
friend struct ActorCallback< WatchActor, 4, Void >;
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WatchActor(Reference<Watch> const& watch,Database const& cx,Future<TenantInfo> const& tenant,TagSet const& tags,SpanID const& spanID,TaskPriority const& taskID,Optional<UID> const& debugID,UseProvisionalProxies const& useProvisionalProxies) 
															#line 24818 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   WatchActorState<WatchActor>(watch, cx, tenant, tags, spanID, taskID, debugID, useProvisionalProxies)
	{
		fdb_probe_actor_enter("watch", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("watch");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("watch", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WatchActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WatchActor, 2, TenantInfo >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WatchActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> watch( Reference<Watch> const& watch, Database const& cx, Future<TenantInfo> const& tenant, TagSet const& tags, SpanID const& spanID, TaskPriority const& taskID, Optional<UID> const& debugID, UseProvisionalProxies const& useProvisionalProxies ) {
															#line 5316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new WatchActor(watch, cx, tenant, tags, spanID, taskID, debugID, useProvisionalProxies));
															#line 24848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 5367 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Version> Transaction::getRawReadVersion() {
	return ::getRawVersion(trState);
}

Future<Void> Transaction::watch(Reference<Watch> watch) {
	++trState->cx->transactionWatchRequests;

	trState->cx->addWatch();
	watches.push_back(watch);
	return ::watch(
	    watch,
	    trState->cx,
	    populateAndGetTenant(
	        trState, watch->key, readVersion.isValid() && readVersion.isReady() ? readVersion.get() : latestVersion),
	    trState->options.readTags,
	    trState->spanID,
	    trState->taskID,
	    trState->debugID,
	    trState->useProvisionalProxies);
}

															#line 24874 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getAddressesForKeyActor()
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetAddressesForKeyActorActor>
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetAddressesForKeyActorActorState {
															#line 24881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetAddressesForKeyActorActorState(Reference<TransactionState> const& trState,Future<Version> const& ver,Key const& key) 
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ver(ver),
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   key(key),
															#line 5392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   ssi(),
															#line 5394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   resolvedKey(key)
															#line 24896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this));

	}
	~GetAddressesForKeyActorActorState() 
	{
		fdb_probe_actor_destroy("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 5395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->tenant().present())
															#line 24911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Version> __when_expr_0 = ver;
															#line 5396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24917 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 1;
															#line 5396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetAddressesForKeyActorActor, 0, Version >*>(static_cast<GetAddressesForKeyActorActor*>(this)));
															#line 24922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont1(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetAddressesForKeyActorActorState();
		static_cast<GetAddressesForKeyActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 5404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ksKey = keyServersKey(resolvedKey);
															#line 5405 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResult> __when_expr_2 = getRange(trState, ver, lastLessOrEqual(serverTagKeys.begin), firstGreaterThan(serverTagKeys.end), GetRangeLimits(CLIENT_KNOBS->TOO_MANY), Reverse::False, UseTenant::False);
															#line 5405 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when1(__when_expr_2.get(), loopDepth); };
		static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 3;
															#line 5405 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >*>(static_cast<GetAddressesForKeyActorActor*>(this)));
															#line 24959 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
															#line 5397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<KeyRangeLocationInfo> __when_expr_1 = getKeyLocation( trState, ""_sr, &StorageServerInterface::getValue, Reverse::False, UseTenant::True, version);
															#line 5397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 2;
															#line 5397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >*>(static_cast<GetAddressesForKeyActorActor*>(this)));
															#line 24975 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Version const& __version,int loopDepth) 
	{
															#line 5396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = __version;
															#line 24984 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && __version,int loopDepth) 
	{
		version = std::move(__version);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state > 0) static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetAddressesForKeyActorActor*>(this)->ActorCallback< GetAddressesForKeyActorActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetAddressesForKeyActorActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(KeyRangeLocationInfo const& locationInfo,int loopDepth) 
	{
															#line 5399 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resolvedKey = key.withPrefix(locationInfo.tenantEntry.prefix);
															#line 25051 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(KeyRangeLocationInfo && locationInfo,int loopDepth) 
	{
															#line 5399 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resolvedKey = key.withPrefix(locationInfo.tenantEntry.prefix);
															#line 25060 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(KeyRangeLocationInfo const& locationInfo,int loopDepth) 
	{
		loopDepth = a_body1cont3(locationInfo, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(KeyRangeLocationInfo && locationInfo,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(locationInfo), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state > 0) static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetAddressesForKeyActorActor*>(this)->ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont5(int loopDepth) 
	{
															#line 5412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!serverTagResult.more && serverTagResult.size() < CLIENT_KNOBS->TOO_MANY);
															#line 5413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Future<RangeResult> futureServerUids = getRange(trState, ver, lastLessOrEqual(ksKey), firstGreaterThan(ksKey), GetRangeLimits(1), Reverse::False, UseTenant::False);
															#line 5420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResult> __when_expr_3 = futureServerUids;
															#line 5420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25138 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont5when1(__when_expr_3.get(), loopDepth); };
		static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 4;
															#line 5420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >*>(static_cast<GetAddressesForKeyActorActor*>(this)));
															#line 25143 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(RangeResult const& __serverTagResult,int loopDepth) 
	{
															#line 5405 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		serverTagResult = __serverTagResult;
															#line 25152 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(RangeResult && __serverTagResult,int loopDepth) 
	{
		serverTagResult = std::move(__serverTagResult);
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state > 0) static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetAddressesForKeyActorActor*>(this)->ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont6(RangeResult const& serverUids,int loopDepth) 
	{
															#line 5422 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(serverUids.size());
															#line 5424 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<UID> src;
															#line 5425 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<UID> ignore;
															#line 5428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		decodeKeyServersValue(serverTagResult, serverUids[0].value, src, ignore);
															#line 5429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Optional<std::vector<StorageServerInterface>>> __when_expr_4 = transactionalGetServerInterfaces(trState, ver, src);
															#line 5429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont6when1(__when_expr_4.get(), loopDepth); };
		static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 5;
															#line 5429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >*>(static_cast<GetAddressesForKeyActorActor*>(this)));
															#line 25234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont6(RangeResult && serverUids,int loopDepth) 
	{
															#line 5422 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(serverUids.size());
															#line 5424 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<UID> src;
															#line 5425 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<UID> ignore;
															#line 5428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		decodeKeyServersValue(serverTagResult, serverUids[0].value, src, ignore);
															#line 5429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Optional<std::vector<StorageServerInterface>>> __when_expr_4 = transactionalGetServerInterfaces(trState, ver, src);
															#line 5429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont6when1(__when_expr_4.get(), loopDepth); };
		static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 5;
															#line 5429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >*>(static_cast<GetAddressesForKeyActorActor*>(this)));
															#line 25258 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5when1(RangeResult const& serverUids,int loopDepth) 
	{
		loopDepth = a_body1cont6(serverUids, loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(RangeResult && serverUids,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(serverUids), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state > 0) static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetAddressesForKeyActorActor*>(this)->ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont7(Optional<std::vector<StorageServerInterface>> const& serverInterfaces,int loopDepth) 
	{
															#line 5432 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(serverInterfaces.present());
															#line 5434 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ssi = serverInterfaces.get();
															#line 5436 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Standalone<VectorRef<const char*>> addresses;
															#line 5437 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto i : ssi ) {
															#line 5438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::string ipString = trState->options.includePort ? i.address().toString() : i.address().ip.toString();
															#line 5439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			char* c_string = new (addresses.arena()) char[ipString.length() + 1];
															#line 5440 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			strcpy(c_string, ipString.c_str());
															#line 5441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			addresses.push_back(addresses.arena(), c_string);
															#line 25344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 5443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetAddressesForKeyActorActor*>(this)->SAV<Standalone<VectorRef<const char*>>>::futures) { (void)(addresses); this->~GetAddressesForKeyActorActorState(); static_cast<GetAddressesForKeyActorActor*>(this)->destroy(); return 0; }
															#line 25348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetAddressesForKeyActorActor*>(this)->SAV< Standalone<VectorRef<const char*>> >::value()) Standalone<VectorRef<const char*>>(addresses);
		this->~GetAddressesForKeyActorActorState();
		static_cast<GetAddressesForKeyActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont7(Optional<std::vector<StorageServerInterface>> && serverInterfaces,int loopDepth) 
	{
															#line 5432 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(serverInterfaces.present());
															#line 5434 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ssi = serverInterfaces.get();
															#line 5436 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Standalone<VectorRef<const char*>> addresses;
															#line 5437 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto i : ssi ) {
															#line 5438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::string ipString = trState->options.includePort ? i.address().toString() : i.address().ip.toString();
															#line 5439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			char* c_string = new (addresses.arena()) char[ipString.length() + 1];
															#line 5440 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			strcpy(c_string, ipString.c_str());
															#line 5441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			addresses.push_back(addresses.arena(), c_string);
															#line 25374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 5443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetAddressesForKeyActorActor*>(this)->SAV<Standalone<VectorRef<const char*>>>::futures) { (void)(addresses); this->~GetAddressesForKeyActorActorState(); static_cast<GetAddressesForKeyActorActor*>(this)->destroy(); return 0; }
															#line 25378 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetAddressesForKeyActorActor*>(this)->SAV< Standalone<VectorRef<const char*>> >::value()) Standalone<VectorRef<const char*>>(addresses);
		this->~GetAddressesForKeyActorActorState();
		static_cast<GetAddressesForKeyActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6when1(Optional<std::vector<StorageServerInterface>> const& serverInterfaces,int loopDepth) 
	{
		loopDepth = a_body1cont7(serverInterfaces, loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Optional<std::vector<StorageServerInterface>> && serverInterfaces,int loopDepth) 
	{
		loopDepth = a_body1cont7(std::move(serverInterfaces), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state > 0) static_cast<GetAddressesForKeyActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetAddressesForKeyActorActor*>(this)->ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >::remove();

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >*,Optional<std::vector<StorageServerInterface>> const& value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >*,Optional<std::vector<StorageServerInterface>> && value) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >*,Error err) 
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> ver;
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key key;
															#line 5392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<StorageServerInterface> ssi;
															#line 5394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key resolvedKey;
															#line 5396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 5404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key ksKey;
															#line 5405 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RangeResult serverTagResult;
															#line 25465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getAddressesForKeyActor()
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetAddressesForKeyActorActor final : public Actor<Standalone<VectorRef<const char*>>>, public ActorCallback< GetAddressesForKeyActorActor, 0, Version >, public ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >, public ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >, public ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >, public ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >, public FastAllocated<GetAddressesForKeyActorActor>, public GetAddressesForKeyActorActorState<GetAddressesForKeyActorActor> {
															#line 25470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetAddressesForKeyActorActor>::operator new;
	using FastAllocated<GetAddressesForKeyActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<const char*>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetAddressesForKeyActorActor, 0, Version >;
friend struct ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >;
friend struct ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >;
friend struct ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >;
friend struct ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >;
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetAddressesForKeyActorActor(Reference<TransactionState> const& trState,Future<Version> const& ver,Key const& key) 
															#line 25485 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Standalone<VectorRef<const char*>>>(),
		   GetAddressesForKeyActorActorState<GetAddressesForKeyActorActor>(trState, ver, key)
	{
		fdb_probe_actor_enter("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getAddressesForKeyActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getAddressesForKeyActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetAddressesForKeyActorActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetAddressesForKeyActorActor, 1, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetAddressesForKeyActorActor, 2, RangeResult >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetAddressesForKeyActorActor, 3, RangeResult >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetAddressesForKeyActorActor, 4, Optional<std::vector<StorageServerInterface>> >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Standalone<VectorRef<const char*>>> getAddressesForKeyActor( Reference<TransactionState> const& trState, Future<Version> const& ver, Key const& key ) {
															#line 5389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Standalone<VectorRef<const char*>>>(new GetAddressesForKeyActorActor(trState, ver, key));
															#line 25517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 5445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Standalone<VectorRef<const char*>>> Transaction::getAddressesForKey(const Key& key) {
	++trState->cx->transactionLogicalReads;
	++trState->cx->transactionGetAddressesForKeyRequests;
	auto ver = getReadVersion();

	return getAddressesForKeyActor(trState, ver, key);
}

															#line 25530 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getKeyAndConflictRange()
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetKeyAndConflictRangeActor>
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyAndConflictRangeActorState {
															#line 25537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyAndConflictRangeActorState(Reference<TransactionState> const& trState,KeySelector const& k,Future<Version> const& version,Promise<std::pair<Key, Key>> const& conflictRange) 
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   k(k),
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   conflictRange(conflictRange)
															#line 25550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this));

	}
	~GetKeyAndConflictRangeActorState() 
	{
		fdb_probe_actor_destroy("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 5459 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Key> __when_expr_0 = getKey(trState, k, version);
															#line 5459 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetKeyAndConflictRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 25568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<GetKeyAndConflictRangeActor*>(this)->actor_wait_state = 1;
															#line 5459 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetKeyAndConflictRangeActor, 0, Key >*>(static_cast<GetKeyAndConflictRangeActor*>(this)));
															#line 25573 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetKeyAndConflictRangeActorState();
		static_cast<GetKeyAndConflictRangeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 5467 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			conflictRange.send(std::make_pair(Key(), Key()));
															#line 5468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 25605 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Key const& rep,int loopDepth) 
	{
															#line 5460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (k.offset <= 0)
															#line 25619 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			conflictRange.send(std::make_pair(rep, k.orEqual ? keyAfter(k.getKey()) : Key(k.getKey(), k.arena())));
															#line 25623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 5463 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			conflictRange.send( std::make_pair(k.orEqual ? keyAfter(k.getKey()) : Key(k.getKey(), k.arena()), keyAfter(rep)));
															#line 25629 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 5465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetKeyAndConflictRangeActor*>(this)->SAV<Key>::futures) { (void)(rep); this->~GetKeyAndConflictRangeActorState(); static_cast<GetKeyAndConflictRangeActor*>(this)->destroy(); return 0; }
															#line 25633 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetKeyAndConflictRangeActor*>(this)->SAV< Key >::value()) Key(rep);
		this->~GetKeyAndConflictRangeActorState();
		static_cast<GetKeyAndConflictRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Key && rep,int loopDepth) 
	{
															#line 5460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (k.offset <= 0)
															#line 25645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			conflictRange.send(std::make_pair(rep, k.orEqual ? keyAfter(k.getKey()) : Key(k.getKey(), k.arena())));
															#line 25649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 5463 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			conflictRange.send( std::make_pair(k.orEqual ? keyAfter(k.getKey()) : Key(k.getKey(), k.arena()), keyAfter(rep)));
															#line 25655 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 5465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetKeyAndConflictRangeActor*>(this)->SAV<Key>::futures) { (void)(rep); this->~GetKeyAndConflictRangeActorState(); static_cast<GetKeyAndConflictRangeActor*>(this)->destroy(); return 0; }
															#line 25659 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetKeyAndConflictRangeActor*>(this)->SAV< Key >::value()) Key(rep);
		this->~GetKeyAndConflictRangeActorState();
		static_cast<GetKeyAndConflictRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Key const& rep,int loopDepth) 
	{
		loopDepth = a_body1cont2(rep, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && rep,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(rep), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetKeyAndConflictRangeActor*>(this)->actor_wait_state > 0) static_cast<GetKeyAndConflictRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetKeyAndConflictRangeActor*>(this)->ActorCallback< GetKeyAndConflictRangeActor, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< GetKeyAndConflictRangeActor, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetKeyAndConflictRangeActor, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetKeyAndConflictRangeActor, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeySelector k;
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> version;
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<std::pair<Key, Key>> conflictRange;
															#line 25738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getKeyAndConflictRange()
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetKeyAndConflictRangeActor final : public Actor<Key>, public ActorCallback< GetKeyAndConflictRangeActor, 0, Key >, public FastAllocated<GetKeyAndConflictRangeActor>, public GetKeyAndConflictRangeActorState<GetKeyAndConflictRangeActor> {
															#line 25743 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetKeyAndConflictRangeActor>::operator new;
	using FastAllocated<GetKeyAndConflictRangeActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetKeyAndConflictRangeActor, 0, Key >;
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetKeyAndConflictRangeActor(Reference<TransactionState> const& trState,KeySelector const& k,Future<Version> const& version,Promise<std::pair<Key, Key>> const& conflictRange) 
															#line 25754 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Key>(),
		   GetKeyAndConflictRangeActorState<GetKeyAndConflictRangeActor>(trState, k, version, conflictRange)
	{
		fdb_probe_actor_enter("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getKeyAndConflictRange");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getKeyAndConflictRange", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetKeyAndConflictRangeActor, 0, Key >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Key> getKeyAndConflictRange( Reference<TransactionState> const& trState, KeySelector const& k, Future<Version> const& version, Promise<std::pair<Key, Key>> const& conflictRange ) {
															#line 5454 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Key>(new GetKeyAndConflictRangeActor(trState, k, version, conflictRange));
															#line 25782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 5471 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Key> Transaction::getKey(const KeySelector& key, Snapshot snapshot) {
	++trState->cx->transactionLogicalReads;
	++trState->cx->transactionGetKeyRequests;
	if (snapshot)
		return ::getKey(trState, key, getReadVersion());

	Promise<std::pair<Key, Key>> conflictRange;
	extraConflictRanges.push_back(conflictRange.getFuture());
	return getKeyAndConflictRange(trState, key, getReadVersion(), conflictRange);
}

template <class GetKeyValuesFamilyRequest>
void increaseCounterForRequest(Database cx) {
	if constexpr (std::is_same<GetKeyValuesFamilyRequest, GetKeyValuesRequest>::value) {
		++cx->transactionGetRangeRequests;
	} else if (std::is_same<GetKeyValuesFamilyRequest, GetMappedKeyValuesRequest>::value) {
		++cx->transactionGetMappedRangeRequests;
	} else {
		UNREACHABLE();
	}
}

template <class GetKeyValuesFamilyRequest, class GetKeyValuesFamilyReply, class RangeResultFamily>
Future<RangeResultFamily> Transaction::getRangeInternal(const KeySelector& begin,
                                                        const KeySelector& end,
                                                        const Key& mapper,
                                                        GetRangeLimits limits,
                                                        Snapshot snapshot,
                                                        Reverse reverse) {
	++trState->cx->transactionLogicalReads;
	increaseCounterForRequest<GetKeyValuesFamilyRequest>(trState->cx);

	if (limits.isReached())
		return RangeResultFamily();

	if (!limits.isValid())
		return range_limits_invalid();

	ASSERT(limits.rows != 0);

	KeySelector b = begin;
	if (b.orEqual) {
		TEST(true); // Native begin orEqual==true
		b.removeOrEqual(b.arena());
	}

	KeySelector e = end;
	if (e.orEqual) {
		TEST(true); // Native end orEqual==true
		e.removeOrEqual(e.arena());
	}

	if (b.offset >= e.offset && b.getKey() >= e.getKey()) {
		TEST(true); // Native range inverted
		return RangeResultFamily();
	}

	if (!snapshot && !std::is_same_v<GetKeyValuesFamilyRequest, GetKeyValuesRequest>) {
		// Currently, NativeAPI does not support serialization for getMappedRange. You should consider use
		// ReadYourWrites APIs which wraps around NativeAPI and provides serialization for getMappedRange. (Even if
		// you don't want RYW, you may use ReadYourWrites APIs with RYW disabled.)
		throw unsupported_operation();
	}
	Promise<std::pair<Key, Key>> conflictRange;
	if (!snapshot) {
		extraConflictRanges.push_back(conflictRange.getFuture());
	}

	return ::getRange<GetKeyValuesFamilyRequest, GetKeyValuesFamilyReply, RangeResultFamily>(
	    trState, getReadVersion(), b, e, mapper, limits, conflictRange, snapshot, reverse);
}

Future<RangeResult> Transaction::getRange(const KeySelector& begin,
                                          const KeySelector& end,
                                          GetRangeLimits limits,
                                          Snapshot snapshot,
                                          Reverse reverse) {
	return getRangeInternal<GetKeyValuesRequest, GetKeyValuesReply, RangeResult>(
	    begin, end, ""_sr, limits, snapshot, reverse);
}

Future<MappedRangeResult> Transaction::getMappedRange(const KeySelector& begin,
                                                      const KeySelector& end,
                                                      const Key& mapper,
                                                      GetRangeLimits limits,
                                                      Snapshot snapshot,
                                                      Reverse reverse) {
	return getRangeInternal<GetMappedKeyValuesRequest, GetMappedKeyValuesReply, MappedRangeResult>(
	    begin, end, mapper, limits, snapshot, reverse);
}

Future<RangeResult> Transaction::getRange(const KeySelector& begin,
                                          const KeySelector& end,
                                          int limit,
                                          Snapshot snapshot,
                                          Reverse reverse) {
	return getRange(begin, end, GetRangeLimits(limit), snapshot, reverse);
}

// A method for streaming data from the storage server that is more efficient than getRange when reading large amounts
// of data
Future<Void> Transaction::getRangeStream(const PromiseStream<RangeResult>& results,
                                         const KeySelector& begin,
                                         const KeySelector& end,
                                         GetRangeLimits limits,
                                         Snapshot snapshot,
                                         Reverse reverse) {
	++trState->cx->transactionLogicalReads;
	++trState->cx->transactionGetRangeStreamRequests;

	// FIXME: limits are not implemented yet, and this code has not be tested with reverse=true
	ASSERT(!limits.hasByteLimit() && !limits.hasRowLimit() && !reverse);

	KeySelector b = begin;
	if (b.orEqual) {
		TEST(true); // Native stream begin orEqual==true
		b.removeOrEqual(b.arena());
	}

	KeySelector e = end;
	if (e.orEqual) {
		TEST(true); // Native stream end orEqual==true
		e.removeOrEqual(e.arena());
	}

	if (b.offset >= e.offset && b.getKey() >= e.getKey()) {
		TEST(true); // Native stream range inverted
		results.sendError(end_of_stream());
		return Void();
	}

	Promise<std::pair<Key, Key>> conflictRange;
	if (!snapshot) {
		extraConflictRanges.push_back(conflictRange.getFuture());
	}

	return forwardErrors(
	    ::getRangeStream(trState, results, getReadVersion(), b, e, limits, conflictRange, snapshot, reverse), results);
}

Future<Void> Transaction::getRangeStream(const PromiseStream<RangeResult>& results,
                                         const KeySelector& begin,
                                         const KeySelector& end,
                                         int limit,
                                         Snapshot snapshot,
                                         Reverse reverse) {
	return getRangeStream(results, begin, end, GetRangeLimits(limit), snapshot, reverse);
}

void Transaction::addReadConflictRange(KeyRangeRef const& keys) {
	ASSERT(!keys.empty());

	// There aren't any keys in the database with size larger than the max key size, so if range contains large keys
	// we can translate it to an equivalent one with smaller keys
	KeyRef begin = keys.begin;
	KeyRef end = keys.end;

	int64_t beginMaxSize = getMaxReadKeySize(begin);
	int64_t endMaxSize = getMaxReadKeySize(end);
	if (begin.size() > beginMaxSize) {
		begin = begin.substr(0, beginMaxSize + 1);
	}
	if (end.size() > endMaxSize) {
		end = end.substr(0, endMaxSize + 1);
	}

	KeyRangeRef r = KeyRangeRef(begin, end);

	if (r.empty()) {
		return;
	}

	tr.transaction.read_conflict_ranges.push_back_deep(tr.arena, r);
}

void Transaction::makeSelfConflicting() {
	BinaryWriter wr(Unversioned());
	wr.serializeBytes(LiteralStringRef("\xFF/SC/"));
	wr << deterministicRandom()->randomUniqueID();
	auto r = singleKeyRange(wr.toValue(), tr.arena);
	tr.transaction.read_conflict_ranges.push_back(tr.arena, r);
	tr.transaction.write_conflict_ranges.push_back(tr.arena, r);
}

void Transaction::set(const KeyRef& key, const ValueRef& value, AddConflictRange addConflictRange) {
	++trState->cx->transactionSetMutations;
	if (key.size() > getMaxWriteKeySize(key, trState->options.rawAccess))
		throw key_too_large();
	if (value.size() > CLIENT_KNOBS->VALUE_SIZE_LIMIT)
		throw value_too_large();

	auto& req = tr;
	auto& t = req.transaction;
	auto r = singleKeyRange(key, req.arena);
	auto v = ValueRef(req.arena, value);
	t.mutations.emplace_back(req.arena, MutationRef::SetValue, r.begin, v);

	if (addConflictRange) {
		t.write_conflict_ranges.push_back(req.arena, r);
	}
}

void Transaction::atomicOp(const KeyRef& key,
                           const ValueRef& operand,
                           MutationRef::Type operationType,
                           AddConflictRange addConflictRange) {
	++trState->cx->transactionAtomicMutations;
	if (key.size() > getMaxWriteKeySize(key, trState->options.rawAccess))
		throw key_too_large();
	if (operand.size() > CLIENT_KNOBS->VALUE_SIZE_LIMIT)
		throw value_too_large();

	if (apiVersionAtLeast(510)) {
		if (operationType == MutationRef::Min)
			operationType = MutationRef::MinV2;
		else if (operationType == MutationRef::And)
			operationType = MutationRef::AndV2;
	}

	auto& req = tr;
	auto& t = req.transaction;
	auto r = singleKeyRange(key, req.arena);
	auto v = ValueRef(req.arena, operand);

	t.mutations.emplace_back(req.arena, operationType, r.begin, v);

	if (addConflictRange && operationType != MutationRef::SetVersionstampedKey)
		t.write_conflict_ranges.push_back(req.arena, r);

	TEST(true); // NativeAPI atomic operation
}

void Transaction::clear(const KeyRangeRef& range, AddConflictRange addConflictRange) {
	++trState->cx->transactionClearMutations;
	auto& req = tr;
	auto& t = req.transaction;

	KeyRef begin = range.begin;
	KeyRef end = range.end;

	// There aren't any keys in the database with size larger than the max key size, so if range contains large keys
	// we can translate it to an equivalent one with smaller keys
	int64_t beginMaxSize = getMaxClearKeySize(begin);
	int64_t endMaxSize = getMaxClearKeySize(end);
	if (begin.size() > beginMaxSize) {
		begin = begin.substr(0, beginMaxSize + 1);
	}
	if (end.size() > endMaxSize) {
		end = end.substr(0, endMaxSize + 1);
	}

	auto r = KeyRangeRef(req.arena, KeyRangeRef(begin, end));
	if (r.empty())
		return;

	t.mutations.emplace_back(req.arena, MutationRef::ClearRange, r.begin, r.end);

	if (addConflictRange)
		t.write_conflict_ranges.push_back(req.arena, r);
}
void Transaction::clear(const KeyRef& key, AddConflictRange addConflictRange) {
	++trState->cx->transactionClearMutations;
	// There aren't any keys in the database with size larger than the max key size
	if (key.size() > getMaxClearKeySize(key)) {
		return;
	}

	auto& req = tr;
	auto& t = req.transaction;

	// efficient single key range clear range mutation, see singleKeyRange
	uint8_t* data = new (req.arena) uint8_t[key.size() + 1];
	memcpy(data, key.begin(), key.size());
	data[key.size()] = 0;
	t.mutations.emplace_back(
	    req.arena, MutationRef::ClearRange, KeyRef(data, key.size()), KeyRef(data, key.size() + 1));
	if (addConflictRange)
		t.write_conflict_ranges.emplace_back(req.arena, KeyRef(data, key.size()), KeyRef(data, key.size() + 1));
}
void Transaction::addWriteConflictRange(const KeyRangeRef& keys) {
	ASSERT(!keys.empty());
	auto& req = tr;
	auto& t = req.transaction;

	// There aren't any keys in the database with size larger than the max key size, so if range contains large keys
	// we can translate it to an equivalent one with smaller keys
	KeyRef begin = keys.begin;
	KeyRef end = keys.end;

	int64_t beginMaxSize = getMaxKeySize(begin);
	int64_t endMaxSize = getMaxKeySize(end);
	if (begin.size() > beginMaxSize) {
		begin = begin.substr(0, beginMaxSize + 1);
	}
	if (end.size() > endMaxSize) {
		end = end.substr(0, endMaxSize + 1);
	}
	KeyRangeRef r = KeyRangeRef(begin, end);

	if (r.empty()) {
		return;
	}

	t.write_conflict_ranges.push_back_deep(req.arena, r);
}

double Transaction::getBackoff(int errCode) {
	double returnedBackoff = backoff;

	if (errCode == error_code_tag_throttled) {
		auto priorityItr = trState->cx->throttledTags.find(trState->options.priority);
		for (auto& tag : trState->options.tags) {
			if (priorityItr != trState->cx->throttledTags.end()) {
				auto tagItr = priorityItr->second.find(tag);
				if (tagItr != priorityItr->second.end()) {
					TEST(true); // Returning throttle backoff
					returnedBackoff = std::max(
					    returnedBackoff,
					    std::min(CLIENT_KNOBS->TAG_THROTTLE_RECHECK_INTERVAL, tagItr->second.throttleDuration()));
					if (returnedBackoff == CLIENT_KNOBS->TAG_THROTTLE_RECHECK_INTERVAL) {
						break;
					}
				}
			}
		}
	}

	returnedBackoff *= deterministicRandom()->random01();

	// Set backoff for next time
	if (errCode == error_code_proxy_memory_limit_exceeded) {
		backoff = std::min(backoff * CLIENT_KNOBS->BACKOFF_GROWTH_RATE, CLIENT_KNOBS->RESOURCE_CONSTRAINED_MAX_BACKOFF);
	} else {
		backoff = std::min(backoff * CLIENT_KNOBS->BACKOFF_GROWTH_RATE, trState->options.maxBackoff);
	}

	return returnedBackoff;
}

TransactionOptions::TransactionOptions(Database const& cx) {
	reset(cx);
	if (BUGGIFY) {
		commitOnFirstProxy = true;
	}
}

void TransactionOptions::clear() {
	maxBackoff = CLIENT_KNOBS->DEFAULT_MAX_BACKOFF;
	getReadVersionFlags = 0;
	sizeLimit = CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT;
	maxTransactionLoggingFieldLength = 0;
	checkWritesEnabled = false;
	causalWriteRisky = false;
	commitOnFirstProxy = false;
	debugDump = false;
	lockAware = false;
	readOnly = false;
	firstInBatch = false;
	includePort = false;
	reportConflictingKeys = false;
	tags = TagSet{};
	readTags = TagSet{};
	priority = TransactionPriority::DEFAULT;
	expensiveClearCostEstimation = false;
	useGrvCache = false;
	skipGrvCache = false;
	rawAccess = false;
}

TransactionOptions::TransactionOptions() {
	clear();
}

void TransactionOptions::reset(Database const& cx) {
	clear();
	lockAware = cx->lockAware;
	if (cx->apiVersionAtLeast(630)) {
		includePort = true;
	}
}

void Transaction::resetImpl(bool generateNewSpan) {
	flushTrLogsIfEnabled();
	trState = trState->cloneAndReset(createTrLogInfoProbabilistically(trState->cx), generateNewSpan);
	tr = CommitTransactionRequest(trState->spanID);
	readVersion = Future<Version>();
	metadataVersion = Promise<Optional<Key>>();
	extraConflictRanges.clear();
	commitResult = Promise<Void>();
	committing = Future<Void>();
	cancelWatches();
}

void Transaction::reset() {
	resetImpl(false);
}

void Transaction::fullReset() {
	resetImpl(true);
	span = Span(trState->spanID, "Transaction"_loc);
	backoff = CLIENT_KNOBS->DEFAULT_BACKOFF;
}

int Transaction::apiVersionAtLeast(int minVersion) const {
	return trState->cx->apiVersionAtLeast(minVersion);
}

class MutationBlock {
public:
	bool mutated;
	bool cleared;
	ValueRef setValue;

	MutationBlock() : mutated(false) {}
	MutationBlock(bool _cleared) : mutated(true), cleared(_cleared) {}
	MutationBlock(ValueRef value) : mutated(true), cleared(false), setValue(value) {}
};

bool compareBegin(KeyRangeRef lhs, KeyRangeRef rhs) {
	return lhs.begin < rhs.begin;
}

// If there is any intersection between the two given sets of ranges, returns a range that
//   falls within the intersection
Optional<KeyRangeRef> intersects(VectorRef<KeyRangeRef> lhs, VectorRef<KeyRangeRef> rhs) {
	if (lhs.size() && rhs.size()) {
		std::sort(lhs.begin(), lhs.end(), compareBegin);
		std::sort(rhs.begin(), rhs.end(), compareBegin);

		int l = 0, r = 0;
		while (l < lhs.size() && r < rhs.size()) {
			if (lhs[l].end <= rhs[r].begin)
				l++;
			else if (rhs[r].end <= lhs[l].begin)
				r++;
			else
				return lhs[l] & rhs[r];
		}
	}

	return Optional<KeyRangeRef>();
}

															#line 26230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via checkWrites()
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class CheckWritesActor>
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CheckWritesActorState {
															#line 26237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CheckWritesActorState(Reference<TransactionState> const& trState,Future<Void> const& committed,Promise<Void> const& outCommitted,CommitTransactionRequest const& req) 
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   committed(committed),
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   outCommitted(outCommitted),
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   req(req),
															#line 5919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version()
															#line 26252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("checkWrites", reinterpret_cast<unsigned long>(this));

	}
	~CheckWritesActorState() 
	{
		fdb_probe_actor_destroy("checkWrites", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 5921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_0 = committed;
															#line 5921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
															#line 26270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				static_cast<CheckWritesActor*>(this)->actor_wait_state = 1;
															#line 5921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CheckWritesActor, 0, Void >*>(static_cast<CheckWritesActor*>(this)));
															#line 26274 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		delete static_cast<CheckWritesActor*>(this);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 5931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = delay(deterministicRandom()->random01());
															#line 5931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
															#line 26304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		static_cast<CheckWritesActor*>(this)->actor_wait_state = 2;
															#line 5931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< CheckWritesActor, 1, Void >*>(static_cast<CheckWritesActor*>(this)));
															#line 26308 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 5927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			outCommitted.sendError(e);
															#line 5928 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			delete static_cast<CheckWritesActor*>(this);
															#line 26320 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 5924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = trState->committedVersion;
															#line 5925 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		outCommitted.send(Void());
															#line 26337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 5924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		version = trState->committedVersion;
															#line 5925 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		outCommitted.send(Void());
															#line 26348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CheckWritesActor*>(this)->actor_wait_state > 0) static_cast<CheckWritesActor*>(this)->actor_wait_state = 0;
		static_cast<CheckWritesActor*>(this)->ActorCallback< CheckWritesActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CheckWritesActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
															#line 5933 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		expectedValues = KeyRangeMap<MutationBlock>();
															#line 5935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		auto& mutations = req.transaction.mutations;
															#line 5936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		mCount = mutations.size();
															#line 5938 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int idx = 0;idx < mutations.size();idx++) {
															#line 5939 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (mutations[idx].type == MutationRef::SetValue)
															#line 26441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				expectedValues.insert(singleKeyRange(mutations[idx].param1), MutationBlock(mutations[idx].param2));
															#line 26445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 5941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (mutations[idx].type == MutationRef::ClearRange)
															#line 26451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 5942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					expectedValues.insert(KeyRangeRef(mutations[idx].param1, mutations[idx].param2), MutationBlock(true));
															#line 26455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		try {
															#line 5946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr = Transaction(trState->cx);
															#line 5947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setVersion(version);
															#line 5948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			checkedRanges = 0;
															#line 5949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ranges = expectedValues.ranges();
															#line 5950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			it = ranges.begin();
															#line 5951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 26472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont5loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont5Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont5Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
															#line 5933 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		expectedValues = KeyRangeMap<MutationBlock>();
															#line 5935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		auto& mutations = req.transaction.mutations;
															#line 5936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		mCount = mutations.size();
															#line 5938 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int idx = 0;idx < mutations.size();idx++) {
															#line 5939 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (mutations[idx].type == MutationRef::SetValue)
															#line 26495 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				expectedValues.insert(singleKeyRange(mutations[idx].param1), MutationBlock(mutations[idx].param2));
															#line 26499 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 5941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (mutations[idx].type == MutationRef::ClearRange)
															#line 26505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 5942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					expectedValues.insert(KeyRangeRef(mutations[idx].param1, mutations[idx].param2), MutationBlock(true));
															#line 26509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		try {
															#line 5946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr = Transaction(trState->cx);
															#line 5947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setVersion(version);
															#line 5948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			checkedRanges = 0;
															#line 5949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ranges = expectedValues.ranges();
															#line 5950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			it = ranges.begin();
															#line 5951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 26526 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont5loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont5Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont5Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<CheckWritesActor*>(this)->actor_wait_state > 0) static_cast<CheckWritesActor*>(this)->actor_wait_state = 0;
		static_cast<CheckWritesActor*>(this)->ActorCallback< CheckWritesActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< CheckWritesActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont6(int loopDepth) 
	{
		loopDepth = a_body1cont12(loopDepth);

		return loopDepth;
	}
	int a_body1cont5Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 5983 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bool ok = e.code() == error_code_transaction_too_old || e.code() == error_code_future_version;
															#line 5984 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(ok ? SevWarn : SevError, "CheckWritesFailed").error(e);
															#line 5985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 26615 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11(int loopDepth) 
	{
															#line 5978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("CheckWritesSuccess") .detail("Version", version) .detail("MutationCount", mCount) .detail("CheckedRanges", checkedRanges);
															#line 26629 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont11cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont5loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1(int loopDepth) 
	{
															#line 5951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(it != ranges.end()))
															#line 26645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont5break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 5952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		m = it->value();
															#line 5953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (m.mutated)
															#line 26653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			checkedRanges++;
															#line 5955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (m.cleared)
															#line 26659 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<RangeResult> __when_expr_2 = tr.getRange(it->range(), 1);
															#line 5956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont5Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1cont5loopBody1when1(__when_expr_2.get(), loopDepth); };
															#line 26665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				static_cast<CheckWritesActor*>(this)->actor_wait_state = 3;
															#line 5956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< CheckWritesActor, 2, RangeResult >*>(static_cast<CheckWritesActor*>(this)));
															#line 26669 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 5965 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Optional<Value>> __when_expr_3 = tr.get(it->range().begin);
															#line 5965 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont5Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont5loopBody1when2(__when_expr_3.get(), loopDepth); };
															#line 26678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				static_cast<CheckWritesActor*>(this)->actor_wait_state = 4;
															#line 5965 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< CheckWritesActor, 3, Optional<Value> >*>(static_cast<CheckWritesActor*>(this)));
															#line 26682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
		}
		else
		{
			loopDepth = a_body1cont5loopBody1cont1(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5break1(int loopDepth) 
	{
		try {
			return a_body1cont11(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1cont5Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont5Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5loopBody1cont1(int loopDepth) 
	{
															#line 5951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++it;
															#line 26710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont5loopHead1(0);

		return loopDepth;
	}
	int a_body1cont5loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1cont5loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1cont4(RangeResult const& shouldBeEmpty,int loopDepth) 
	{
															#line 5957 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (shouldBeEmpty.size())
															#line 26725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5958 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "CheckWritesFailed") .detail("Class", "Clear") .detail("KeyBegin", it->range().begin) .detail("KeyEnd", it->range().end);
															#line 5962 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			delete static_cast<CheckWritesActor*>(this);
															#line 26731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return 0;
		}
		loopDepth = a_body1cont5loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1cont4(RangeResult && shouldBeEmpty,int loopDepth) 
	{
															#line 5957 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (shouldBeEmpty.size())
															#line 26742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5958 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "CheckWritesFailed") .detail("Class", "Clear") .detail("KeyBegin", it->range().begin) .detail("KeyEnd", it->range().end);
															#line 5962 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			delete static_cast<CheckWritesActor*>(this);
															#line 26748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return 0;
		}
		loopDepth = a_body1cont5loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1when1(RangeResult const& shouldBeEmpty,int loopDepth) 
	{
		loopDepth = a_body1cont5loopBody1cont4(shouldBeEmpty, loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1when1(RangeResult && shouldBeEmpty,int loopDepth) 
	{
		loopDepth = a_body1cont5loopBody1cont4(std::move(shouldBeEmpty), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<CheckWritesActor*>(this)->actor_wait_state > 0) static_cast<CheckWritesActor*>(this)->actor_wait_state = 0;
		static_cast<CheckWritesActor*>(this)->ActorCallback< CheckWritesActor, 2, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 2, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont5loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 2, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont5loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< CheckWritesActor, 2, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont5Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont5loopBody1cont7(Optional<Value> const& val,int loopDepth) 
	{
															#line 5966 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!val.present() || val.get() != m.setValue)
															#line 26822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5967 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent evt(SevError, "CheckWritesFailed");
															#line 5968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			evt.detail("Class", "Set").detail("Key", it->range().begin).detail("Expected", m.setValue);
															#line 5969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!val.present())
															#line 26830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				evt.detail("Actual", "_Value Missing_");
															#line 26834 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 5972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				evt.detail("Actual", val.get());
															#line 26840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 5973 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			delete static_cast<CheckWritesActor*>(this);
															#line 26844 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return 0;
		}
		loopDepth = a_body1cont5loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1cont7(Optional<Value> && val,int loopDepth) 
	{
															#line 5966 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!val.present() || val.get() != m.setValue)
															#line 26855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 5967 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent evt(SevError, "CheckWritesFailed");
															#line 5968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			evt.detail("Class", "Set").detail("Key", it->range().begin).detail("Expected", m.setValue);
															#line 5969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!val.present())
															#line 26863 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 5970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				evt.detail("Actual", "_Value Missing_");
															#line 26867 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 5972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				evt.detail("Actual", val.get());
															#line 26873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 5973 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			delete static_cast<CheckWritesActor*>(this);
															#line 26877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return 0;
		}
		loopDepth = a_body1cont5loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1when2(Optional<Value> const& val,int loopDepth) 
	{
		loopDepth = a_body1cont5loopBody1cont7(val, loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1when2(Optional<Value> && val,int loopDepth) 
	{
		loopDepth = a_body1cont5loopBody1cont7(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<CheckWritesActor*>(this)->actor_wait_state > 0) static_cast<CheckWritesActor*>(this)->actor_wait_state = 0;
		static_cast<CheckWritesActor*>(this)->ActorCallback< CheckWritesActor, 3, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 3, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< CheckWritesActor, 3, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< CheckWritesActor, 3, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont11cont2(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont12(int loopDepth) 
	{
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		delete static_cast<CheckWritesActor*>(this);
															#line 26964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		return 0;

		return loopDepth;
	}
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> committed;
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<Void> outCommitted;
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CommitTransactionRequest req;
															#line 5919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 5933 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeMap<MutationBlock> expectedValues;
															#line 5936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int mCount;
															#line 5946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 5948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int checkedRanges;
															#line 5949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeMap<MutationBlock>::Ranges ranges;
															#line 5950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeMap<MutationBlock>::iterator it;
															#line 5952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MutationBlock m;
															#line 26993 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via checkWrites()
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CheckWritesActor final : public Actor<void>, public ActorCallback< CheckWritesActor, 0, Void >, public ActorCallback< CheckWritesActor, 1, Void >, public ActorCallback< CheckWritesActor, 2, RangeResult >, public ActorCallback< CheckWritesActor, 3, Optional<Value> >, public FastAllocated<CheckWritesActor>, public CheckWritesActorState<CheckWritesActor> {
															#line 26998 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<CheckWritesActor>::operator new;
	using FastAllocated<CheckWritesActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() {{ ((Actor<void>*)this)->~Actor(); operator delete(this); }}
#pragma clang diagnostic pop
friend struct ActorCallback< CheckWritesActor, 0, Void >;
friend struct ActorCallback< CheckWritesActor, 1, Void >;
friend struct ActorCallback< CheckWritesActor, 2, RangeResult >;
friend struct ActorCallback< CheckWritesActor, 3, Optional<Value> >;
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CheckWritesActor(Reference<TransactionState> const& trState,Future<Void> const& committed,Promise<Void> const& outCommitted,CommitTransactionRequest const& req) 
															#line 27012 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<void>(),
		   CheckWritesActorState<CheckWritesActor>(trState, committed, outCommitted, req)
	{
		fdb_probe_actor_enter("checkWrites", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("checkWrites");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("checkWrites", reinterpret_cast<unsigned long>(this), -1);

	}
};
}
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
void checkWrites( Reference<TransactionState> const& trState, Future<Void> const& committed, Promise<Void> const& outCommitted, CommitTransactionRequest const& req ) {
															#line 5915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	new CheckWritesActor(trState, committed, outCommitted, req);
															#line 27031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 5988 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 27036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via commitDummyTransaction()
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class CommitDummyTransactionActor>
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CommitDummyTransactionActorState {
															#line 27043 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CommitDummyTransactionActorState(Reference<TransactionState> const& trState,KeyRange const& range) 
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 5990 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(trState->cx),
															#line 5991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   retries(0),
															#line 5992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:dummyTransaction"_loc, trState->spanID)
															#line 27058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("commitDummyTransaction", reinterpret_cast<unsigned long>(this));

	}
	~CommitDummyTransactionActorState() 
	{
		fdb_probe_actor_destroy("commitDummyTransaction", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 5993 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.span.addParent(span.context);
															#line 5994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 27075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~CommitDummyTransactionActorState();
		static_cast<CommitDummyTransactionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 5996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("CommitDummyTransaction").detail("Key", range.begin).detail("Retries", retries);
															#line 5997 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.trState->options = trState->options;
															#line 5998 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.trState->taskID = trState->taskID;
															#line 5999 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 6000 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::CAUSAL_WRITE_RISKY);
															#line 6001 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 6002 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.addReadConflictRange(range);
															#line 6003 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.addWriteConflictRange(range);
															#line 6004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = tr.commit();
															#line 6004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 27124 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state = 1;
															#line 6004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CommitDummyTransactionActor, 0, Void >*>(static_cast<CommitDummyTransactionActor*>(this)));
															#line 27129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 6013 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++retries;
															#line 27144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 6007 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("CommitDummyTransactionError") .errorUnsuppressed(e) .detail("Key", range.begin) .detail("Retries", retries);
															#line 6011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = tr.onError(e);
															#line 6011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 27158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_1.get(), loopDepth); };
			static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state = 2;
															#line 6011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< CommitDummyTransactionActor, 1, Void >*>(static_cast<CommitDummyTransactionActor*>(this)));
															#line 27163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 6005 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CommitDummyTransactionActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CommitDummyTransactionActorState(); static_cast<CommitDummyTransactionActor*>(this)->destroy(); return 0; }
															#line 27178 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CommitDummyTransactionActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CommitDummyTransactionActorState();
		static_cast<CommitDummyTransactionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 6005 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CommitDummyTransactionActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CommitDummyTransactionActorState(); static_cast<CommitDummyTransactionActor*>(this)->destroy(); return 0; }
															#line 27190 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CommitDummyTransactionActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CommitDummyTransactionActorState();
		static_cast<CommitDummyTransactionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state > 0) static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state = 0;
		static_cast<CommitDummyTransactionActor*>(this)->ActorCallback< CommitDummyTransactionActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CommitDummyTransactionActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CommitDummyTransactionActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CommitDummyTransactionActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state > 0) static_cast<CommitDummyTransactionActor*>(this)->actor_wait_state = 0;
		static_cast<CommitDummyTransactionActor*>(this)->ActorCallback< CommitDummyTransactionActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CommitDummyTransactionActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< CommitDummyTransactionActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< CommitDummyTransactionActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitDummyTransaction", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange range;
															#line 5990 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 5991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int retries;
															#line 5992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 27346 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via commitDummyTransaction()
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CommitDummyTransactionActor final : public Actor<Void>, public ActorCallback< CommitDummyTransactionActor, 0, Void >, public ActorCallback< CommitDummyTransactionActor, 1, Void >, public FastAllocated<CommitDummyTransactionActor>, public CommitDummyTransactionActorState<CommitDummyTransactionActor> {
															#line 27351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<CommitDummyTransactionActor>::operator new;
	using FastAllocated<CommitDummyTransactionActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< CommitDummyTransactionActor, 0, Void >;
friend struct ActorCallback< CommitDummyTransactionActor, 1, Void >;
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CommitDummyTransactionActor(Reference<TransactionState> const& trState,KeyRange const& range) 
															#line 27363 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   CommitDummyTransactionActorState<CommitDummyTransactionActor>(trState, range)
	{
		fdb_probe_actor_enter("commitDummyTransaction", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("commitDummyTransaction");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("commitDummyTransaction", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< CommitDummyTransactionActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< CommitDummyTransactionActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> commitDummyTransaction( Reference<TransactionState> const& trState, KeyRange const& range ) {
															#line 5989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new CommitDummyTransactionActor(trState, range));
															#line 27392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 6016 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

void Transaction::cancelWatches(Error const& e) {
	for (int i = 0; i < watches.size(); ++i)
		if (!watches[i]->onChangeTrigger.isSet())
			watches[i]->onChangeTrigger.sendError(e);

	watches.clear();
}

void Transaction::setupWatches() {
	try {
		Future<Version> watchVersion = getCommittedVersion() > 0 ? getCommittedVersion() : getReadVersion();

		for (int i = 0; i < watches.size(); ++i)
			watches[i]->setWatch(watchValueMap(watchVersion,
			                                   trState->getTenantInfo(),
			                                   watches[i]->key,
			                                   watches[i]->value,
			                                   trState->cx,
			                                   trState->options.readTags,
			                                   trState->spanID,
			                                   trState->taskID,
			                                   trState->debugID,
			                                   trState->useProvisionalProxies));

		watches.clear();
	} catch (Error&) {
		ASSERT(false); // The above code must NOT throw because commit has already occured.
		throw internal_error();
	}
}

															#line 27428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via estimateCommitCosts()
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class EstimateCommitCostsActor>
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class EstimateCommitCostsActorState {
															#line 27435 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	EstimateCommitCostsActorState(Reference<TransactionState> const& trState,CommitTransactionRef const* const& transaction) 
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   transaction(transaction),
															#line 6050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   trCommitCosts(),
															#line 6051 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keyRange(),
															#line 6052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   i(0)
															#line 27450 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("estimateCommitCosts", reinterpret_cast<unsigned long>(this));

	}
	~EstimateCommitCostsActorState() 
	{
		fdb_probe_actor_destroy("estimateCommitCosts", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 6054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 27465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~EstimateCommitCostsActorState();
		static_cast<EstimateCommitCostsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 6097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!trState->cx->sampleOnCost(trCommitCosts.writeCosts))
															#line 27488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6098 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<EstimateCommitCostsActor*>(this)->SAV<Optional<ClientTrCommitCostEstimation>>::futures) { (void)(Optional<ClientTrCommitCostEstimation>()); this->~EstimateCommitCostsActorState(); static_cast<EstimateCommitCostsActor*>(this)->destroy(); return 0; }
															#line 27492 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<EstimateCommitCostsActor*>(this)->SAV< Optional<ClientTrCommitCostEstimation> >::value()) Optional<ClientTrCommitCostEstimation>(Optional<ClientTrCommitCostEstimation>());
			this->~EstimateCommitCostsActorState();
			static_cast<EstimateCommitCostsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 6106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(trCommitCosts.writeCosts > 0);
															#line 6107 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::deque<std::pair<int, uint64_t>> newClearIdxCosts;
															#line 6108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& [idx, cost] : trCommitCosts.clearIdxCosts ) {
															#line 6109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trCommitCosts.writeCosts >= CLIENT_KNOBS->COMMIT_SAMPLE_COST)
															#line 27506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				double mul = trCommitCosts.writeCosts / std::max(1.0, (double)CLIENT_KNOBS->COMMIT_SAMPLE_COST);
															#line 6111 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (deterministicRandom()->random01() < cost * mul / trCommitCosts.writeCosts)
															#line 27512 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					newClearIdxCosts.emplace_back( idx, cost < CLIENT_KNOBS->COMMIT_SAMPLE_COST ? CLIENT_KNOBS->COMMIT_SAMPLE_COST : cost);
															#line 27516 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
			else
			{
															#line 6115 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (deterministicRandom()->random01() < (double)cost / trCommitCosts.writeCosts)
															#line 27523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6116 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					newClearIdxCosts.emplace_back( idx, cost < CLIENT_KNOBS->COMMIT_SAMPLE_COST ? CLIENT_KNOBS->COMMIT_SAMPLE_COST : cost);
															#line 27527 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 6121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.clearIdxCosts.swap(newClearIdxCosts);
															#line 6122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<EstimateCommitCostsActor*>(this)->SAV<Optional<ClientTrCommitCostEstimation>>::futures) { (void)(trCommitCosts); this->~EstimateCommitCostsActorState(); static_cast<EstimateCommitCostsActor*>(this)->destroy(); return 0; }
															#line 27535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<EstimateCommitCostsActor*>(this)->SAV< Optional<ClientTrCommitCostEstimation> >::value()) Optional<ClientTrCommitCostEstimation>(std::move(trCommitCosts)); // state_var_RVO
		this->~EstimateCommitCostsActorState();
		static_cast<EstimateCommitCostsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 6054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(i < transaction->mutations.size()))
															#line 27554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 6055 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		auto* it = &transaction->mutations[i];
															#line 6057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (it->type == MutationRef::Type::SetValue || it->isAtomicOp())
															#line 27562 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trCommitCosts.opsCount++;
															#line 6059 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trCommitCosts.writeCosts += getWriteOperationCost(it->expectedSize());
															#line 27568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		else
		{
															#line 6060 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (it->type == MutationRef::Type::ClearRange)
															#line 27575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6061 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trCommitCosts.opsCount++;
															#line 6062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				keyRange = KeyRangeRef(it->param1, it->param2);
															#line 6063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (trState->options.expensiveClearCostEstimation)
															#line 27583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<StorageMetrics> __when_expr_0 = trState->cx->getStorageMetrics(keyRange, CLIENT_KNOBS->TOO_MANY);
															#line 6064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 27589 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
					static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state = 1;
															#line 6064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >*>(static_cast<EstimateCommitCostsActor*>(this)));
															#line 27594 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 6070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_1 = getKeyRangeLocations(trState, keyRange, CLIENT_KNOBS->TOO_MANY, Reverse::False, &StorageServerInterface::getShardState, UseTenant::True, latestVersion);
															#line 6070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 27603 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
					static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state = 2;
															#line 6070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >*>(static_cast<EstimateCommitCostsActor*>(this)));
															#line 27608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
			}
			else
			{
				loopDepth = a_body1loopBody1cont4(loopDepth);
			}
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1continue1(int loopDepth) 
	{
															#line 6054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++i;
															#line 27637 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 6054 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++i;
															#line 27646 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont6(StorageMetrics const& m,int loopDepth) 
	{
															#line 6065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.clearIdxCosts.emplace_back(i, getWriteOperationCost(m.bytes));
															#line 6066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.writeCosts += getWriteOperationCost(m.bytes);
															#line 6067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trCommitCosts.expensiveCostEstCount;
															#line 6068 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionsExpensiveClearCostEstCount;
															#line 27673 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont6(StorageMetrics && m,int loopDepth) 
	{
															#line 6065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.clearIdxCosts.emplace_back(i, getWriteOperationCost(m.bytes));
															#line 6066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.writeCosts += getWriteOperationCost(m.bytes);
															#line 6067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trCommitCosts.expensiveCostEstCount;
															#line 6068 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionsExpensiveClearCostEstCount;
															#line 27688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(StorageMetrics const& m,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(m, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(StorageMetrics && m,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(std::move(m), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state > 0) static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state = 0;
		static_cast<EstimateCommitCostsActor*>(this)->ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >::remove();

	}
	void a_callback_fire(ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >*,StorageMetrics const& value) 
	{
		fdb_probe_actor_enter("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >*,StorageMetrics && value) 
	{
		fdb_probe_actor_enter("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >*,Error err) 
	{
		fdb_probe_actor_enter("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont8(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
															#line 6078 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.empty())
															#line 27760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1continue1(loopDepth); // continue
		}
															#line 6082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		uint64_t bytes = 0;
															#line 6083 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() == 1)
															#line 27768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bytes = CLIENT_KNOBS->INCOMPLETE_SHARD_PLUS;
															#line 27772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 6086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bytes = CLIENT_KNOBS->INCOMPLETE_SHARD_PLUS * 2 + (locations.size() - 2) * (int64_t)trState->cx->smoothMidShardSize.smoothTotal();
															#line 27778 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.clearIdxCosts.emplace_back(i, getWriteOperationCost(bytes));
															#line 6091 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.writeCosts += getWriteOperationCost(bytes);
															#line 27784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont8(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
															#line 6078 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.empty())
															#line 27793 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1continue1(loopDepth); // continue
		}
															#line 6082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		uint64_t bytes = 0;
															#line 6083 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() == 1)
															#line 27801 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bytes = CLIENT_KNOBS->INCOMPLETE_SHARD_PLUS;
															#line 27805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 6086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			bytes = CLIENT_KNOBS->INCOMPLETE_SHARD_PLUS * 2 + (locations.size() - 2) * (int64_t)trState->cx->smoothMidShardSize.smoothTotal();
															#line 27811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.clearIdxCosts.emplace_back(i, getWriteOperationCost(bytes));
															#line 6091 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trCommitCosts.writeCosts += getWriteOperationCost(bytes);
															#line 27817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(locations, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont8(std::move(locations), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state > 0) static_cast<EstimateCommitCostsActor*>(this)->actor_wait_state = 0;
		static_cast<EstimateCommitCostsActor*>(this)->ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("estimateCommitCosts", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CommitTransactionRef const* transaction;
															#line 6050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ClientTrCommitCostEstimation trCommitCosts;
															#line 6051 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeRef keyRange;
															#line 6052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int i;
															#line 27895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via estimateCommitCosts()
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class EstimateCommitCostsActor final : public Actor<Optional<ClientTrCommitCostEstimation>>, public ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >, public ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >, public FastAllocated<EstimateCommitCostsActor>, public EstimateCommitCostsActorState<EstimateCommitCostsActor> {
															#line 27900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<EstimateCommitCostsActor>::operator new;
	using FastAllocated<EstimateCommitCostsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Optional<ClientTrCommitCostEstimation>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >;
friend struct ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >;
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	EstimateCommitCostsActor(Reference<TransactionState> const& trState,CommitTransactionRef const* const& transaction) 
															#line 27912 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Optional<ClientTrCommitCostEstimation>>(),
		   EstimateCommitCostsActorState<EstimateCommitCostsActor>(trState, transaction)
	{
		fdb_probe_actor_enter("estimateCommitCosts", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("estimateCommitCosts");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("estimateCommitCosts", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< EstimateCommitCostsActor, 0, StorageMetrics >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< EstimateCommitCostsActor, 1, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Optional<ClientTrCommitCostEstimation>> estimateCommitCosts( Reference<TransactionState> const& trState, CommitTransactionRef const* const& transaction ) {
															#line 6048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Optional<ClientTrCommitCostEstimation>>(new EstimateCommitCostsActor(trState, transaction));
															#line 27941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 6124 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// TODO: send the prefix as part of the commit request and ship it all the way
// through to the storage servers
void applyTenantPrefix(CommitTransactionRequest& req, Key tenantPrefix) {
	for (auto& m : req.transaction.mutations) {
		if (m.param1 != metadataVersionKey) {
			m.param1 = m.param1.withPrefix(tenantPrefix, req.arena);
			if (m.type == MutationRef::ClearRange) {
				m.param2 = m.param2.withPrefix(tenantPrefix, req.arena);
			} else if (m.type == MutationRef::SetVersionstampedKey) {
				uint8_t* key = mutateString(m.param1);
				int* offset = reinterpret_cast<int*>(&key[m.param1.size() - 4]);
				*offset += tenantPrefix.size();
			}
		}
	}

	for (auto& rc : req.transaction.read_conflict_ranges) {
		if (rc.begin != metadataVersionKey) {
			rc = rc.withPrefix(tenantPrefix, req.arena);
		}
	}

	for (auto& wc : req.transaction.write_conflict_ranges) {
		if (wc.begin != metadataVersionKey) {
			wc = wc.withPrefix(tenantPrefix, req.arena);
		}
	}
}

															#line 27975 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via tryCommit()
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class TryCommitActor>
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TryCommitActorState {
															#line 27982 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TryCommitActorState(Reference<TransactionState> const& trState,CommitTransactionRequest const& req,Future<Version> const& readVersion) 
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   req(req),
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   readVersion(readVersion),
															#line 6157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   interval("TransactionCommit"),
															#line 6158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   startTime(now()),
															#line 6159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:tryCommit"_loc, trState->spanID),
															#line 6160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugID(trState->debugID)
															#line 28001 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("tryCommit", reinterpret_cast<unsigned long>(this));

	}
	~TryCommitActorState() 
	{
		fdb_probe_actor_destroy("tryCommit", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 6161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 28016 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(interval.begin()).detail("Parent", debugID.get());
															#line 28020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			try {
															#line 6165 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (CLIENT_BUGGIFY)
															#line 28025 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6166 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch2(deterministicRandom()->randomChoice(std::vector<Error>{ not_committed(), transaction_too_old(), proxy_memory_limit_exceeded(), commit_unknown_result() }), loopDepth);
															#line 28029 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 6170 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (req.tagSet.present() && trState->options.priority < TransactionPriority::IMMEDIATE)
															#line 28033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6171 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_0 = store(req.transaction.read_snapshot, readVersion) && store(req.commitCostEstimation, estimateCommitCosts(trState, &req.transaction));
															#line 6171 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<TryCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 28039 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
					static_cast<TryCommitActor*>(this)->actor_wait_state = 1;
															#line 6171 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TryCommitActor, 0, Void >*>(static_cast<TryCommitActor*>(this)));
															#line 28044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 6174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_1 = store(req.transaction.read_snapshot, readVersion);
															#line 6174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<TryCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 28053 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
					static_cast<TryCommitActor*>(this)->actor_wait_state = 2;
															#line 6174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< TryCommitActor, 1, Void >*>(static_cast<TryCommitActor*>(this)));
															#line 28058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TryCommitActorState();
		static_cast<TryCommitActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 6298 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_request_maybe_delivered || e.code() == error_code_commit_unknown_result)
															#line 28089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!trState->options.causalWriteRisky)
															#line 28093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					KeyRangeRef selfConflictingRange = intersects(req.transaction.write_conflict_ranges, req.transaction.read_conflict_ranges).get();
															#line 6314 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(true);
															#line 6316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_5 = commitDummyTransaction(trState, singleKeyRange(selfConflictingRange.begin));
															#line 6316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<TryCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 28103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1Catch2when1(__when_expr_5.get(), loopDepth); };
					static_cast<TryCommitActor*>(this)->actor_wait_state = 5;
															#line 6316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< TryCommitActor, 5, Void >*>(static_cast<TryCommitActor*>(this)));
															#line 28108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
					loopDepth = a_body1Catch2cont2(loopDepth);
				}
			}
			else
			{
															#line 6322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 28120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6323 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(trState->tenant().present());
															#line 6324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->cx->invalidateCachedTenant(trState->tenant().get());
															#line 6325 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch1(e, loopDepth);
															#line 28128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 6327 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (e.code() != error_code_transaction_too_old && e.code() != error_code_not_committed && e.code() != error_code_database_locked && e.code() != error_code_proxy_memory_limit_exceeded && e.code() != error_code_batch_transaction_throttled && e.code() != error_code_tag_throttled && e.code() != error_code_process_behind && e.code() != error_code_future_version && e.code() != error_code_tenant_not_found)
															#line 28134 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 6332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						TraceEvent(SevError, "TryCommitError").error(e);
															#line 28138 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 6334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (trState->trLogInfo)
															#line 28142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 6335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						trState->trLogInfo->addLog(FdbClientLogEvents::EventCommitError( startTime, trState->cx->clientLocality.dcId(), static_cast<int>(e.code()), req, trState->tenant()));
															#line 28146 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 6337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch1(e, loopDepth);
															#line 28150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3(int loopDepth) 
	{
															#line 6177 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tenantPrefix = Key();
															#line 6178 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->tenant().present())
															#line 28168 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<KeyRangeLocationInfo> __when_expr_2 = getKeyLocation(trState, ""_sr, &StorageServerInterface::getValue, Reverse::False, UseTenant::True, req.transaction.read_snapshot);
															#line 6179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<TryCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 28174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch2(__when_expr_2.getError(), loopDepth); else return a_body1cont3when1(__when_expr_2.get(), loopDepth); };
			static_cast<TryCommitActor*>(this)->actor_wait_state = 3;
															#line 6179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >*>(static_cast<TryCommitActor*>(this)));
															#line 28179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont7(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TryCommitActor*>(this)->actor_wait_state > 0) static_cast<TryCommitActor*>(this)->actor_wait_state = 0;
		static_cast<TryCommitActor*>(this)->ActorCallback< TryCommitActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TryCommitActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont6(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont6(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<TryCommitActor*>(this)->actor_wait_state > 0) static_cast<TryCommitActor*>(this)->actor_wait_state = 0;
		static_cast<TryCommitActor*>(this)->ActorCallback< TryCommitActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< TryCommitActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont7(int loopDepth) 
	{
															#line 6189 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.tenantInfo = trState->getTenantInfo();
															#line 6191 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		startTime = now();
															#line 6192 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		commitID = Optional<UID>();
															#line 6194 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (debugID.present())
															#line 28349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6195 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			commitID = nondeterministicRandom()->randomUniqueID();
															#line 6196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addAttach("CommitAttachID", debugID.get().first(), commitID.get().first());
															#line 6197 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent("CommitDebug", commitID.get().first(), "NativeAPI.commit.Before");
															#line 28357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6200 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.debugID = commitID;
															#line 6201 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		reply = Future<CommitID>();
															#line 6202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->options.commitOnFirstProxy)
															#line 28365 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6203 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->cx->clientInfo->get().firstCommitProxy.present())
															#line 28369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				reply = throwErrorOr(brokenPromiseToMaybeDelivered( trState->cx->clientInfo->get().firstCommitProxy.get().commit.tryGetReply(req)));
															#line 28373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 6207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				const std::vector<CommitProxyInterface>& proxies = trState->cx->clientInfo->get().commitProxies;
															#line 6208 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				reply = proxies.size() ? throwErrorOr(brokenPromiseToMaybeDelivered(proxies[0].commit.tryGetReply(req))) : Never();
															#line 28381 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		else
		{
															#line 6212 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			reply = basicLoadBalance(trState->cx->getCommitProxies(trState->useProvisionalProxies), &CommitProxyInterface::commit, req, TaskPriority::DefaultPromiseEndpoint, AtMostOnce::True);
															#line 28388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		grvTime = now();
															#line 6220 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = trState->cx->onProxiesChanged();
															#line 6219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<TryCommitActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 28396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch2(__when_expr_3.getError(), loopDepth); else return a_body1cont7when1(__when_expr_3.get(), loopDepth); };
															#line 6224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<CommitID> __when_expr_4 = reply;
															#line 28400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch2(__when_expr_4.getError(), loopDepth); else return a_body1cont7when2(__when_expr_4.get(), loopDepth); };
		static_cast<TryCommitActor*>(this)->actor_wait_state = 4;
															#line 6220 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< TryCommitActor, 3, Void >*>(static_cast<TryCommitActor*>(this)));
															#line 6224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< TryCommitActor, 4, CommitID >*>(static_cast<TryCommitActor*>(this)));
															#line 28407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont8(KeyRangeLocationInfo const& locationInfo,int loopDepth) 
	{
															#line 6185 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		applyTenantPrefix(req, locationInfo.tenantEntry.prefix);
															#line 6186 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tenantPrefix = locationInfo.tenantEntry.prefix;
															#line 28418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont8(KeyRangeLocationInfo && locationInfo,int loopDepth) 
	{
															#line 6185 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		applyTenantPrefix(req, locationInfo.tenantEntry.prefix);
															#line 6186 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tenantPrefix = locationInfo.tenantEntry.prefix;
															#line 28429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(KeyRangeLocationInfo const& locationInfo,int loopDepth) 
	{
		loopDepth = a_body1cont8(locationInfo, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(KeyRangeLocationInfo && locationInfo,int loopDepth) 
	{
		loopDepth = a_body1cont8(std::move(locationInfo), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<TryCommitActor*>(this)->actor_wait_state > 0) static_cast<TryCommitActor*>(this)->actor_wait_state = 0;
		static_cast<TryCommitActor*>(this)->ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >::remove();

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >*,KeyRangeLocationInfo const& value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >*,KeyRangeLocationInfo && value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >*,Error err) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont7when1(Void const& _,int loopDepth) 
	{
															#line 6221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		reply.cancel();
															#line 6222 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1Catch2(request_maybe_delivered(), loopDepth);
															#line 28503 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont7when1(Void && _,int loopDepth) 
	{
															#line 6221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		reply.cancel();
															#line 6222 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1Catch2(request_maybe_delivered(), loopDepth);
															#line 28513 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont7when2(CommitID const& ci,int loopDepth) 
	{
															#line 6225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Version v = ci.version;
															#line 6226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v != invalidVersion)
															#line 28523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (CLIENT_BUGGIFY)
															#line 28527 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch2(commit_unknown_result(), loopDepth);
															#line 28531 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->updateCachedReadVersion(grvTime, v);
															#line 6231 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 28537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(interval.end()).detail("CommittedVersion", v);
															#line 28541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->committedVersion = v;
															#line 6234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (v > trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation].first)
															#line 28547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->mvCacheInsertLocation = (trState->cx->mvCacheInsertLocation + 1) % trState->cx->metadataVersionCache.size();
															#line 6237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation] = std::make_pair(v, ci.metadataVersion);
															#line 28553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Standalone<StringRef> ret = makeString(10);
															#line 6242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			placeVersionstamp(mutateString(ret), v, ci.txnBatchId);
															#line 6243 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->versionstampPromise.send(ret);
															#line 6245 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->numErrors = 0;
															#line 6246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionsCommitCompleted;
															#line 6247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->transactionCommittedMutations += req.transaction.mutations.size();
															#line 6248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->transactionCommittedMutationBytes += req.transaction.mutations.expectedSize();
															#line 6250 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (commitID.present())
															#line 28571 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("CommitDebug", commitID.get().first(), "NativeAPI.commit.After");
															#line 28575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			double latency = now() - startTime;
															#line 6254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->commitLatencies.addSample(latency);
															#line 6255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->latencies.addSample(now() - trState->startTime);
															#line 6256 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->trLogInfo)
															#line 28585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6257 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->trLogInfo->addLog( FdbClientLogEvents::EventCommit_V2(startTime, trState->cx->clientLocality.dcId(), latency, req.transaction.mutations.size(), req.transaction.mutations.expectedSize(), ci.version, req, trState->tenant()));
															#line 28589 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<TryCommitActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TryCommitActorState(); static_cast<TryCommitActor*>(this)->destroy(); return 0; }
															#line 28593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<TryCommitActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~TryCommitActorState();
			static_cast<TryCommitActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 6269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->conflictingKeys.reset();
															#line 6270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (ci.conflictingKRIndices.present())
															#line 28605 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->conflictingKeys = std::make_shared<CoalescedKeyRangeMap<Value>>(conflictingKeysFalse, specialKeys.end);
															#line 6273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				conflictingKRIndices = ci.conflictingKRIndices.get();
															#line 6276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				mergedIds = std::unordered_set<int>(conflictingKRIndices.begin(), conflictingKRIndices.end());
															#line 6278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for( auto const& rCRIndex : mergedIds ) {
															#line 6279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					const KeyRangeRef kr = req.transaction.read_conflict_ranges[rCRIndex];
															#line 6280 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					const KeyRange krWithPrefix = KeyRangeRef(kr.begin.removePrefix(tenantPrefix).withPrefix(conflictingKeysRange.begin), kr.end.removePrefix(tenantPrefix).withPrefix(conflictingKeysRange.begin));
															#line 6283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->conflictingKeys->insert(krWithPrefix, conflictingKeysTrue);
															#line 28621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 6287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 28626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(interval.end()).detail("Conflict", 1);
															#line 28630 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (commitID.present())
															#line 28634 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("CommitDebug", commitID.get().first(), "NativeAPI.commit.After");
															#line 28638 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6293 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch2(not_committed(), loopDepth);
															#line 28642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}

		return loopDepth;
	}
	int a_body1cont7when2(CommitID && ci,int loopDepth) 
	{
															#line 6225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Version v = ci.version;
															#line 6226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (v != invalidVersion)
															#line 28653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (CLIENT_BUGGIFY)
															#line 28657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch2(commit_unknown_result(), loopDepth);
															#line 28661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->updateCachedReadVersion(grvTime, v);
															#line 6231 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 28667 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(interval.end()).detail("CommittedVersion", v);
															#line 28671 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->committedVersion = v;
															#line 6234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (v > trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation].first)
															#line 28677 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->mvCacheInsertLocation = (trState->cx->mvCacheInsertLocation + 1) % trState->cx->metadataVersionCache.size();
															#line 6237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation] = std::make_pair(v, ci.metadataVersion);
															#line 28683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Standalone<StringRef> ret = makeString(10);
															#line 6242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			placeVersionstamp(mutateString(ret), v, ci.txnBatchId);
															#line 6243 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->versionstampPromise.send(ret);
															#line 6245 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->numErrors = 0;
															#line 6246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++trState->cx->transactionsCommitCompleted;
															#line 6247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->transactionCommittedMutations += req.transaction.mutations.size();
															#line 6248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->transactionCommittedMutationBytes += req.transaction.mutations.expectedSize();
															#line 6250 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (commitID.present())
															#line 28701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("CommitDebug", commitID.get().first(), "NativeAPI.commit.After");
															#line 28705 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			double latency = now() - startTime;
															#line 6254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->commitLatencies.addSample(latency);
															#line 6255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->latencies.addSample(now() - trState->startTime);
															#line 6256 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->trLogInfo)
															#line 28715 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6257 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->trLogInfo->addLog( FdbClientLogEvents::EventCommit_V2(startTime, trState->cx->clientLocality.dcId(), latency, req.transaction.mutations.size(), req.transaction.mutations.expectedSize(), ci.version, req, trState->tenant()));
															#line 28719 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<TryCommitActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~TryCommitActorState(); static_cast<TryCommitActor*>(this)->destroy(); return 0; }
															#line 28723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<TryCommitActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~TryCommitActorState();
			static_cast<TryCommitActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 6269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->conflictingKeys.reset();
															#line 6270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (ci.conflictingKRIndices.present())
															#line 28735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->conflictingKeys = std::make_shared<CoalescedKeyRangeMap<Value>>(conflictingKeysFalse, specialKeys.end);
															#line 6273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				conflictingKRIndices = ci.conflictingKRIndices.get();
															#line 6276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				mergedIds = std::unordered_set<int>(conflictingKRIndices.begin(), conflictingKRIndices.end());
															#line 6278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for( auto const& rCRIndex : mergedIds ) {
															#line 6279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					const KeyRangeRef kr = req.transaction.read_conflict_ranges[rCRIndex];
															#line 6280 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					const KeyRange krWithPrefix = KeyRangeRef(kr.begin.removePrefix(tenantPrefix).withPrefix(conflictingKeysRange.begin), kr.end.removePrefix(tenantPrefix).withPrefix(conflictingKeysRange.begin));
															#line 6283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->conflictingKeys->insert(krWithPrefix, conflictingKeysTrue);
															#line 28751 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 6287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 28756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(interval.end()).detail("Conflict", 1);
															#line 28760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (commitID.present())
															#line 28764 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("CommitDebug", commitID.get().first(), "NativeAPI.commit.After");
															#line 28768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6293 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch2(not_committed(), loopDepth);
															#line 28772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<TryCommitActor*>(this)->actor_wait_state > 0) static_cast<TryCommitActor*>(this)->actor_wait_state = 0;
		static_cast<TryCommitActor*>(this)->ActorCallback< TryCommitActor, 3, Void >::remove();
		static_cast<TryCommitActor*>(this)->ActorCallback< TryCommitActor, 4, CommitID >::remove();

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont7when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont7when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< TryCommitActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 4, CommitID >*,CommitID const& value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont7when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 4, CommitID >*,CommitID && value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont7when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< TryCommitActor, 4, CommitID >*,Error err) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1Catch2cont2(int loopDepth) 
	{
															#line 6321 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1Catch1(commit_unknown_result(), loopDepth);
															#line 28878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1Catch2cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont2(loopDepth);

		return loopDepth;
	}
	int a_body1Catch2cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont2(loopDepth);

		return loopDepth;
	}
	int a_body1Catch2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1Catch2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1Catch2cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<TryCommitActor*>(this)->actor_wait_state > 0) static_cast<TryCommitActor*>(this)->actor_wait_state = 0;
		static_cast<TryCommitActor*>(this)->ActorCallback< TryCommitActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1Catch2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< TryCommitActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1Catch2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< TryCommitActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), 5);

	}
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CommitTransactionRequest req;
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Version> readVersion;
															#line 6157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TraceInterval interval;
															#line 6158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double startTime;
															#line 6159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 6160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> debugID;
															#line 6177 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key tenantPrefix;
															#line 6192 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> commitID;
															#line 6201 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<CommitID> reply;
															#line 6218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double grvTime;
															#line 6273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Standalone<VectorRef<int>> conflictingKRIndices;
															#line 6276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::unordered_set<int> mergedIds;
															#line 28983 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via tryCommit()
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TryCommitActor final : public Actor<Void>, public ActorCallback< TryCommitActor, 0, Void >, public ActorCallback< TryCommitActor, 1, Void >, public ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >, public ActorCallback< TryCommitActor, 3, Void >, public ActorCallback< TryCommitActor, 4, CommitID >, public ActorCallback< TryCommitActor, 5, Void >, public FastAllocated<TryCommitActor>, public TryCommitActorState<TryCommitActor> {
															#line 28988 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<TryCommitActor>::operator new;
	using FastAllocated<TryCommitActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< TryCommitActor, 0, Void >;
friend struct ActorCallback< TryCommitActor, 1, Void >;
friend struct ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >;
friend struct ActorCallback< TryCommitActor, 3, Void >;
friend struct ActorCallback< TryCommitActor, 4, CommitID >;
friend struct ActorCallback< TryCommitActor, 5, Void >;
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TryCommitActor(Reference<TransactionState> const& trState,CommitTransactionRequest const& req,Future<Version> const& readVersion) 
															#line 29004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   TryCommitActorState<TryCommitActor>(trState, req, readVersion)
	{
		fdb_probe_actor_enter("tryCommit", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("tryCommit");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("tryCommit", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TryCommitActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< TryCommitActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< TryCommitActor, 2, KeyRangeLocationInfo >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< TryCommitActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< TryCommitActor, 5, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> tryCommit( Reference<TransactionState> const& trState, CommitTransactionRequest const& req, Future<Version> const& readVersion ) {
															#line 6154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new TryCommitActor(trState, req, readVersion));
															#line 29036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 6341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> Transaction::commitMutations() {
	try {
		// if this is a read-only transaction return immediately
		if (!tr.transaction.write_conflict_ranges.size() && !tr.transaction.mutations.size()) {
			trState->numErrors = 0;

			trState->committedVersion = invalidVersion;
			trState->versionstampPromise.sendError(no_commit_version());
			return Void();
		}

		++trState->cx->transactionsCommitStarted;

		if (trState->options.readOnly)
			return transaction_read_only();

		trState->cx->mutationsPerCommit.addSample(tr.transaction.mutations.size());
		trState->cx->bytesPerCommit.addSample(tr.transaction.mutations.expectedSize());
		if (trState->options.tags.size())
			tr.tagSet = trState->options.tags;

		size_t transactionSize = getSize();
		if (transactionSize > (uint64_t)FLOW_KNOBS->PACKET_WARNING) {
			TraceEvent(!g_network->isSimulated() ? SevWarnAlways : SevWarn, "LargeTransaction")
			    .suppressFor(1.0)
			    .detail("Size", transactionSize)
			    .detail("NumMutations", tr.transaction.mutations.size())
			    .detail("ReadConflictSize", tr.transaction.read_conflict_ranges.expectedSize())
			    .detail("WriteConflictSize", tr.transaction.write_conflict_ranges.expectedSize())
			    .detail("DebugIdentifier", trState->trLogInfo ? trState->trLogInfo->identifier : "");
		}

		if (!apiVersionAtLeast(300)) {
			transactionSize =
			    tr.transaction.mutations.expectedSize(); // Old API versions didn't account for conflict ranges when
			                                             // determining whether to throw transaction_too_large
		}

		if (transactionSize > trState->options.sizeLimit) {
			return transaction_too_large();
		}

		if (!readVersion.isValid())
			getReadVersion(
			    GetReadVersionRequest::FLAG_CAUSAL_READ_RISKY); // sets up readVersion field.  We had no reads, so no
			                                                    // need for (expensive) full causal consistency.

		bool isCheckingWrites = trState->options.checkWritesEnabled && deterministicRandom()->random01() < 0.01;
		for (int i = 0; i < extraConflictRanges.size(); i++)
			if (extraConflictRanges[i].isReady() &&
			    extraConflictRanges[i].get().first < extraConflictRanges[i].get().second)
				tr.transaction.read_conflict_ranges.emplace_back(
				    tr.arena, extraConflictRanges[i].get().first, extraConflictRanges[i].get().second);

		if (!trState->options.causalWriteRisky &&
		    !intersects(tr.transaction.write_conflict_ranges, tr.transaction.read_conflict_ranges).present())
			makeSelfConflicting();

		if (isCheckingWrites) {
			// add all writes into the read conflict range...
			tr.transaction.read_conflict_ranges.append(
			    tr.arena, tr.transaction.write_conflict_ranges.begin(), tr.transaction.write_conflict_ranges.size());
		}

		if (trState->options.debugDump) {
			UID u = nondeterministicRandom()->randomUniqueID();
			TraceEvent("TransactionDump", u).log();
			for (auto i = tr.transaction.mutations.begin(); i != tr.transaction.mutations.end(); ++i)
				TraceEvent("TransactionMutation", u)
				    .detail("T", i->type)
				    .detail("P1", i->param1)
				    .detail("P2", i->param2);
		}

		if (trState->options.lockAware) {
			tr.flags = tr.flags | CommitTransactionRequest::FLAG_IS_LOCK_AWARE;
		}
		if (trState->options.firstInBatch) {
			tr.flags = tr.flags | CommitTransactionRequest::FLAG_FIRST_IN_BATCH;
		}
		if (trState->options.reportConflictingKeys) {
			tr.transaction.report_conflicting_keys = true;
		}

		Future<Void> commitResult = tryCommit(trState, tr, readVersion);

		if (isCheckingWrites) {
			Promise<Void> committed;
			checkWrites(trState, commitResult, committed, tr);
			return committed.getFuture();
		}
		return commitResult;
	} catch (Error& e) {
		TraceEvent("ClientCommitError").error(e);
		return Future<Void>(e);
	} catch (...) {
		Error e(error_code_unknown_error);
		TraceEvent("ClientCommitError").error(e);
		return Future<Void>(e);
	}
}

															#line 29143 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via commitAndWatch()
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class CommitAndWatchActor>
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CommitAndWatchActorState {
															#line 29150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CommitAndWatchActorState(Transaction* const& self) 
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self)
															#line 29157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("commitAndWatch", reinterpret_cast<unsigned long>(this));

	}
	~CommitAndWatchActorState() 
	{
		fdb_probe_actor_destroy("commitAndWatch", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 6446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_0 = self->commitMutations();
															#line 6446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<CommitAndWatchActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), loopDepth);
															#line 29175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<CommitAndWatchActor*>(this)->actor_wait_state = 1;
															#line 6446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CommitAndWatchActor, 0, Void >*>(static_cast<CommitAndWatchActor*>(this)));
															#line 29180 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~CommitAndWatchActorState();
		static_cast<CommitAndWatchActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 6461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_actor_cancelled)
															#line 29210 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6462 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!self->watches.empty())
															#line 29214 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6463 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					self->cancelWatches(e);
															#line 29218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 6466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				self->trState->versionstampPromise.sendError(transaction_invalid_version());
															#line 6468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!self->apiVersionAtLeast(700))
															#line 29224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6469 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					self->reset();
															#line 29228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 6473 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 29233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 6448 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->getDatabase()->transactionTracingSample = (self->getCommittedVersion() % 60000000) < (60000000 * FLOW_KNOBS->TRACING_SAMPLE_RATE);
															#line 6451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!self->watches.empty())
															#line 29249 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6452 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->setupWatches();
															#line 29253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!self->apiVersionAtLeast(700))
															#line 29257 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6456 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->reset();
															#line 29261 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6459 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CommitAndWatchActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CommitAndWatchActorState(); static_cast<CommitAndWatchActor*>(this)->destroy(); return 0; }
															#line 29265 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CommitAndWatchActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CommitAndWatchActorState();
		static_cast<CommitAndWatchActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 6448 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->getDatabase()->transactionTracingSample = (self->getCommittedVersion() % 60000000) < (60000000 * FLOW_KNOBS->TRACING_SAMPLE_RATE);
															#line 6451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!self->watches.empty())
															#line 29279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6452 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->setupWatches();
															#line 29283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!self->apiVersionAtLeast(700))
															#line 29287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6456 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->reset();
															#line 29291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6459 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CommitAndWatchActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CommitAndWatchActorState(); static_cast<CommitAndWatchActor*>(this)->destroy(); return 0; }
															#line 29295 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CommitAndWatchActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CommitAndWatchActorState();
		static_cast<CommitAndWatchActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CommitAndWatchActor*>(this)->actor_wait_state > 0) static_cast<CommitAndWatchActor*>(this)->actor_wait_state = 0;
		static_cast<CommitAndWatchActor*>(this)->ActorCallback< CommitAndWatchActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CommitAndWatchActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("commitAndWatch", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitAndWatch", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CommitAndWatchActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("commitAndWatch", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitAndWatch", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CommitAndWatchActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("commitAndWatch", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("commitAndWatch", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction* self;
															#line 29368 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via commitAndWatch()
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CommitAndWatchActor final : public Actor<Void>, public ActorCallback< CommitAndWatchActor, 0, Void >, public FastAllocated<CommitAndWatchActor>, public CommitAndWatchActorState<CommitAndWatchActor> {
															#line 29373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<CommitAndWatchActor>::operator new;
	using FastAllocated<CommitAndWatchActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< CommitAndWatchActor, 0, Void >;
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CommitAndWatchActor(Transaction* const& self) 
															#line 29384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   CommitAndWatchActorState<CommitAndWatchActor>(self)
	{
		fdb_probe_actor_enter("commitAndWatch", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("commitAndWatch");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("commitAndWatch", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< CommitAndWatchActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> commitAndWatch( Transaction* const& self ) {
															#line 6444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new CommitAndWatchActor(self));
															#line 29412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 6476 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> Transaction::commit() {
	ASSERT(!committing.isValid());
	committing = commitAndWatch(this);
	return committing;
}

void Transaction::setOption(FDBTransactionOptions::Option option, Optional<StringRef> value) {
	switch (option) {
	case FDBTransactionOptions::INITIALIZE_NEW_DATABASE:
		validateOptionValueNotPresent(value);
		if (readVersion.isValid())
			throw read_version_already_set();
		readVersion = Version(0);
		trState->options.causalWriteRisky = true;
		break;

	case FDBTransactionOptions::CAUSAL_READ_RISKY:
		validateOptionValueNotPresent(value);
		trState->options.getReadVersionFlags |= GetReadVersionRequest::FLAG_CAUSAL_READ_RISKY;
		break;

	case FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE:
		validateOptionValueNotPresent(value);
		trState->options.priority = TransactionPriority::IMMEDIATE;
		break;

	case FDBTransactionOptions::PRIORITY_BATCH:
		validateOptionValueNotPresent(value);
		trState->options.priority = TransactionPriority::BATCH;
		break;

	case FDBTransactionOptions::CAUSAL_WRITE_RISKY:
		validateOptionValueNotPresent(value);
		trState->options.causalWriteRisky = true;
		break;

	case FDBTransactionOptions::COMMIT_ON_FIRST_PROXY:
		validateOptionValueNotPresent(value);
		trState->options.commitOnFirstProxy = true;
		break;

	case FDBTransactionOptions::CHECK_WRITES_ENABLE:
		validateOptionValueNotPresent(value);
		trState->options.checkWritesEnabled = true;
		break;

	case FDBTransactionOptions::DEBUG_DUMP:
		validateOptionValueNotPresent(value);
		trState->options.debugDump = true;
		break;

	case FDBTransactionOptions::TRANSACTION_LOGGING_ENABLE:
		setOption(FDBTransactionOptions::DEBUG_TRANSACTION_IDENTIFIER, value);
		setOption(FDBTransactionOptions::LOG_TRANSACTION);
		break;

	case FDBTransactionOptions::DEBUG_TRANSACTION_IDENTIFIER:
		validateOptionValuePresent(value);

		if (value.get().size() > 100 || value.get().size() == 0) {
			throw invalid_option_value();
		}

		if (trState->trLogInfo) {
			if (trState->trLogInfo->identifier.empty()) {
				trState->trLogInfo->identifier = value.get().printable();
			} else if (trState->trLogInfo->identifier != value.get().printable()) {
				TraceEvent(SevWarn, "CannotChangeDebugTransactionIdentifier")
				    .detail("PreviousIdentifier", trState->trLogInfo->identifier)
				    .detail("NewIdentifier", value.get());
				throw client_invalid_operation();
			}
		} else {
			trState->trLogInfo =
			    makeReference<TransactionLogInfo>(value.get().printable(), TransactionLogInfo::DONT_LOG);
			trState->trLogInfo->maxFieldLength = trState->options.maxTransactionLoggingFieldLength;
		}
		if (trState->debugID.present()) {
			TraceEvent(SevInfo, "TransactionBeingTraced")
			    .detail("DebugTransactionID", trState->trLogInfo->identifier)
			    .detail("ServerTraceID", trState->debugID.get());
		}
		break;

	case FDBTransactionOptions::LOG_TRANSACTION:
		validateOptionValueNotPresent(value);
		if (trState->trLogInfo && !trState->trLogInfo->identifier.empty()) {
			trState->trLogInfo->logTo(TransactionLogInfo::TRACE_LOG);
		} else {
			TraceEvent(SevWarn, "DebugTransactionIdentifierNotSet")
			    .detail("Error", "Debug Transaction Identifier option must be set before logging the transaction");
			throw client_invalid_operation();
		}
		break;

	case FDBTransactionOptions::TRANSACTION_LOGGING_MAX_FIELD_LENGTH:
		validateOptionValuePresent(value);
		{
			int maxFieldLength = extractIntOption(value, -1, std::numeric_limits<int32_t>::max());
			if (maxFieldLength == 0) {
				throw invalid_option_value();
			}
			trState->options.maxTransactionLoggingFieldLength = maxFieldLength;
		}
		if (trState->trLogInfo) {
			trState->trLogInfo->maxFieldLength = trState->options.maxTransactionLoggingFieldLength;
		}
		break;

	case FDBTransactionOptions::SERVER_REQUEST_TRACING:
		validateOptionValueNotPresent(value);
		debugTransaction(deterministicRandom()->randomUniqueID());
		if (trState->trLogInfo && !trState->trLogInfo->identifier.empty()) {
			TraceEvent(SevInfo, "TransactionBeingTraced")
			    .detail("DebugTransactionID", trState->trLogInfo->identifier)
			    .detail("ServerTraceID", trState->debugID.get());
		}
		break;

	case FDBTransactionOptions::MAX_RETRY_DELAY:
		validateOptionValuePresent(value);
		trState->options.maxBackoff = extractIntOption(value, 0, std::numeric_limits<int32_t>::max()) / 1000.0;
		break;

	case FDBTransactionOptions::SIZE_LIMIT:
		validateOptionValuePresent(value);
		trState->options.sizeLimit = extractIntOption(value, 32, CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT);
		break;

	case FDBTransactionOptions::LOCK_AWARE:
		validateOptionValueNotPresent(value);
		trState->options.lockAware = true;
		trState->options.readOnly = false;
		break;

	case FDBTransactionOptions::READ_LOCK_AWARE:
		validateOptionValueNotPresent(value);
		if (!trState->options.lockAware) {
			trState->options.lockAware = true;
			trState->options.readOnly = true;
		}
		break;

	case FDBTransactionOptions::FIRST_IN_BATCH:
		validateOptionValueNotPresent(value);
		trState->options.firstInBatch = true;
		break;

	case FDBTransactionOptions::USE_PROVISIONAL_PROXIES:
		validateOptionValueNotPresent(value);
		trState->options.getReadVersionFlags |= GetReadVersionRequest::FLAG_USE_PROVISIONAL_PROXIES;
		trState->useProvisionalProxies = UseProvisionalProxies::True;
		break;

	case FDBTransactionOptions::INCLUDE_PORT_IN_ADDRESS:
		validateOptionValueNotPresent(value);
		trState->options.includePort = true;
		break;

	case FDBTransactionOptions::TAG:
		validateOptionValuePresent(value);
		trState->options.tags.addTag(value.get());
		break;

	case FDBTransactionOptions::AUTO_THROTTLE_TAG:
		validateOptionValuePresent(value);
		trState->options.tags.addTag(value.get());
		trState->options.readTags.addTag(value.get());
		break;

	case FDBTransactionOptions::SPAN_PARENT:
		validateOptionValuePresent(value);
		if (value.get().size() != 16) {
			throw invalid_option_value();
		}
		span.addParent(BinaryReader::fromStringRef<UID>(value.get(), Unversioned()));
		break;

	case FDBTransactionOptions::REPORT_CONFLICTING_KEYS:
		validateOptionValueNotPresent(value);
		trState->options.reportConflictingKeys = true;
		break;

	case FDBTransactionOptions::EXPENSIVE_CLEAR_COST_ESTIMATION_ENABLE:
		validateOptionValueNotPresent(value);
		trState->options.expensiveClearCostEstimation = true;
		break;

	case FDBTransactionOptions::USE_GRV_CACHE:
		validateOptionValueNotPresent(value);
		if (trState->numErrors == 0) {
			trState->options.useGrvCache = true;
		}
		break;

	case FDBTransactionOptions::SKIP_GRV_CACHE:
		validateOptionValueNotPresent(value);
		trState->options.skipGrvCache = true;
		break;
	case FDBTransactionOptions::READ_SYSTEM_KEYS:
	case FDBTransactionOptions::ACCESS_SYSTEM_KEYS:
	case FDBTransactionOptions::RAW_ACCESS:
		// System key access implies raw access. Native API handles the raw access,
		// system key access is handled in RYW.
		validateOptionValueNotPresent(value);
		if (trState->hasTenant()) {
			Error e = invalid_option();
			TraceEvent(SevWarn, "TenantTransactionRawAccess").error(e).detail("Tenant", trState->tenant());
			throw e;
		}
		trState->options.rawAccess = true;
		break;

	default:
		break;
	}
}

															#line 29635 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getConsistentReadVersion()
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetConsistentReadVersionActor>
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetConsistentReadVersionActorState {
															#line 29642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetConsistentReadVersionActorState(SpanID const& parentSpan,DatabaseContext* const& cx,uint32_t const& transactionCount,TransactionPriority const& priority,uint32_t const& flags,TransactionTagMap<uint32_t> const& tags,Optional<UID> const& debugID) 
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : parentSpan(parentSpan),
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(cx),
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   transactionCount(transactionCount),
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   priority(priority),
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   flags(flags),
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tags(tags),
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugID(debugID),
															#line 6702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:getConsistentReadVersion"_loc, parentSpan)
															#line 29663 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getConsistentReadVersion", reinterpret_cast<unsigned long>(this));

	}
	~GetConsistentReadVersionActorState() 
	{
		fdb_probe_actor_destroy("getConsistentReadVersion", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 6704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++cx->transactionReadVersionBatches;
															#line 6705 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (debugID.present())
															#line 29680 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6706 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				g_traceBatch.addEvent("TransactionDebug", debugID.get().first(), "NativeAPI.getConsistentReadVersion.Before");
															#line 29684 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 29688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetConsistentReadVersionActorState();
		static_cast<GetConsistentReadVersionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 6709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req = GetReadVersionRequest(span.context, transactionCount, priority, cx->ssVersionVectorCache.getMaxVersion(), flags, tags, debugID);
															#line 6716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			onProxiesChanged = cx->onProxiesChanged();
															#line 6719 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = onProxiesChanged;
															#line 6718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 6722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<GetReadVersionReply> __when_expr_1 = basicLoadBalance(cx->getGrvProxies(UseProvisionalProxies( flags & GetReadVersionRequest::FLAG_USE_PROVISIONAL_PROXIES)), &GrvProxyInterface::getConsistentReadVersion, req, cx->taskID);
															#line 29729 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
			static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state = 1;
															#line 6719 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetConsistentReadVersionActor, 0, Void >*>(static_cast<GetConsistentReadVersionActor*>(this)));
															#line 6722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetConsistentReadVersionActor, 1, GetReadVersionReply >*>(static_cast<GetConsistentReadVersionActor*>(this)));
															#line 29736 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 6761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_broken_promise && e.code() != error_code_batch_transaction_throttled && e.code() != error_code_proxy_memory_limit_exceeded)
															#line 29758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "GetConsistentReadVersionError").error(e);
															#line 29762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6764 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if ((e.code() == error_code_batch_transaction_throttled || e.code() == error_code_proxy_memory_limit_exceeded) && !cx->apiVersionAtLeast(630))
															#line 29766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_2 = delayJittered(5.0);
															#line 6767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 29772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_2.get(), loopDepth); };
				static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state = 2;
															#line 6767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetConsistentReadVersionActor, 2, Void >*>(static_cast<GetConsistentReadVersionActor*>(this)));
															#line 29777 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 6769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 29784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
															#line 6720 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		onProxiesChanged = cx->onProxiesChanged();
															#line 29805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
															#line 6720 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		onProxiesChanged = cx->onProxiesChanged();
															#line 29814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(GetReadVersionReply const& v,int loopDepth) 
	{
															#line 6728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tags.size() != 0)
															#line 29823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6729 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto& priorityThrottledTags = cx->throttledTags[priority];
															#line 6730 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& tag : tags ) {
															#line 6731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto itr = v.tagThrottleInfo.find(tag.first);
															#line 6732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (itr == v.tagThrottleInfo.end())
															#line 29833 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(true);
															#line 6734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					priorityThrottledTags.erase(tag.first);
															#line 29839 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 6736 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(true);
															#line 6737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					auto result = priorityThrottledTags.try_emplace(tag.first, itr->second);
															#line 6738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!result.second)
															#line 29849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 6739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						result.first->second.update(itr->second);
															#line 29853 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
			}
		}
															#line 6745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (debugID.present())
															#line 29860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", debugID.get().first(), "NativeAPI.getConsistentReadVersion.After");
															#line 29864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(v.version > 0);
															#line 6749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->minAcceptableReadVersion = std::min(cx->minAcceptableReadVersion, v.version);
															#line 6750 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (cx->versionVectorCacheActive(v.ssVersionVectorDelta))
															#line 29872 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6751 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (cx->isCurrentGrvProxy(v.proxyId))
															#line 29876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6752 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->ssVersionVectorCache.applyDelta(v.ssVersionVectorDelta);
															#line 29880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
				return a_body1loopHead1(loopDepth); // continue
			}
		}
															#line 6757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetConsistentReadVersionActor*>(this)->SAV<GetReadVersionReply>::futures) { (void)(v); this->~GetConsistentReadVersionActorState(); static_cast<GetConsistentReadVersionActor*>(this)->destroy(); return 0; }
															#line 29889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetConsistentReadVersionActor*>(this)->SAV< GetReadVersionReply >::value()) GetReadVersionReply(v);
		this->~GetConsistentReadVersionActorState();
		static_cast<GetConsistentReadVersionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when2(GetReadVersionReply && v,int loopDepth) 
	{
															#line 6728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (tags.size() != 0)
															#line 29901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6729 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto& priorityThrottledTags = cx->throttledTags[priority];
															#line 6730 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& tag : tags ) {
															#line 6731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto itr = v.tagThrottleInfo.find(tag.first);
															#line 6732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (itr == v.tagThrottleInfo.end())
															#line 29911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(true);
															#line 6734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					priorityThrottledTags.erase(tag.first);
															#line 29917 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 6736 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(true);
															#line 6737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					auto result = priorityThrottledTags.try_emplace(tag.first, itr->second);
															#line 6738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (!result.second)
															#line 29927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 6739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						result.first->second.update(itr->second);
															#line 29931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
			}
		}
															#line 6745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (debugID.present())
															#line 29938 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addEvent( "TransactionDebug", debugID.get().first(), "NativeAPI.getConsistentReadVersion.After");
															#line 29942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(v.version > 0);
															#line 6749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->minAcceptableReadVersion = std::min(cx->minAcceptableReadVersion, v.version);
															#line 6750 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (cx->versionVectorCacheActive(v.ssVersionVectorDelta))
															#line 29950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6751 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (cx->isCurrentGrvProxy(v.proxyId))
															#line 29954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6752 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->ssVersionVectorCache.applyDelta(v.ssVersionVectorDelta);
															#line 29958 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
				return a_body1loopHead1(loopDepth); // continue
			}
		}
															#line 6757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetConsistentReadVersionActor*>(this)->SAV<GetReadVersionReply>::futures) { (void)(v); this->~GetConsistentReadVersionActorState(); static_cast<GetConsistentReadVersionActor*>(this)->destroy(); return 0; }
															#line 29967 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetConsistentReadVersionActor*>(this)->SAV< GetReadVersionReply >::value()) GetReadVersionReply(v);
		this->~GetConsistentReadVersionActorState();
		static_cast<GetConsistentReadVersionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state > 0) static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state = 0;
		static_cast<GetConsistentReadVersionActor*>(this)->ActorCallback< GetConsistentReadVersionActor, 0, Void >::remove();
		static_cast<GetConsistentReadVersionActor*>(this)->ActorCallback< GetConsistentReadVersionActor, 1, GetReadVersionReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetConsistentReadVersionActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetConsistentReadVersionActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetConsistentReadVersionActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetConsistentReadVersionActor, 1, GetReadVersionReply >*,GetReadVersionReply const& value) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetConsistentReadVersionActor, 1, GetReadVersionReply >*,GetReadVersionReply && value) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetConsistentReadVersionActor, 1, GetReadVersionReply >*,Error err) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state > 0) static_cast<GetConsistentReadVersionActor*>(this)->actor_wait_state = 0;
		static_cast<GetConsistentReadVersionActor*>(this)->ActorCallback< GetConsistentReadVersionActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetConsistentReadVersionActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetConsistentReadVersionActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetConsistentReadVersionActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID parentSpan;
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	uint32_t transactionCount;
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionPriority priority;
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	uint32_t flags;
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionTagMap<uint32_t> tags;
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> debugID;
															#line 6702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 6709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetReadVersionRequest req;
															#line 6716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> onProxiesChanged;
															#line 30186 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getConsistentReadVersion()
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetConsistentReadVersionActor final : public Actor<GetReadVersionReply>, public ActorCallback< GetConsistentReadVersionActor, 0, Void >, public ActorCallback< GetConsistentReadVersionActor, 1, GetReadVersionReply >, public ActorCallback< GetConsistentReadVersionActor, 2, Void >, public FastAllocated<GetConsistentReadVersionActor>, public GetConsistentReadVersionActorState<GetConsistentReadVersionActor> {
															#line 30191 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetConsistentReadVersionActor>::operator new;
	using FastAllocated<GetConsistentReadVersionActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<GetReadVersionReply>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetConsistentReadVersionActor, 0, Void >;
friend struct ActorCallback< GetConsistentReadVersionActor, 1, GetReadVersionReply >;
friend struct ActorCallback< GetConsistentReadVersionActor, 2, Void >;
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetConsistentReadVersionActor(SpanID const& parentSpan,DatabaseContext* const& cx,uint32_t const& transactionCount,TransactionPriority const& priority,uint32_t const& flags,TransactionTagMap<uint32_t> const& tags,Optional<UID> const& debugID) 
															#line 30204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<GetReadVersionReply>(),
		   GetConsistentReadVersionActorState<GetConsistentReadVersionActor>(parentSpan, cx, transactionCount, priority, flags, tags, debugID)
	{
		fdb_probe_actor_enter("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getConsistentReadVersion");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getConsistentReadVersion", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetConsistentReadVersionActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetConsistentReadVersionActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<GetReadVersionReply> getConsistentReadVersion( SpanID const& parentSpan, DatabaseContext* const& cx, uint32_t const& transactionCount, TransactionPriority const& priority, uint32_t const& flags, TransactionTagMap<uint32_t> const& tags, Optional<UID> const& debugID ) {
															#line 6695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<GetReadVersionReply>(new GetConsistentReadVersionActor(parentSpan, cx, transactionCount, priority, flags, tags, debugID));
															#line 30233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 6774 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 30238 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via readVersionBatcher()
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ReadVersionBatcherActor>
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ReadVersionBatcherActorState {
															#line 30245 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadVersionBatcherActorState(DatabaseContext* const& cx,FutureStream<DatabaseContext::VersionRequest> const& versionStream,TransactionPriority const& priority,uint32_t const& flags) 
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   versionStream(versionStream),
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   priority(priority),
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   flags(flags),
															#line 6779 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   requests(),
															#line 6780 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   addActor(),
															#line 6781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   collection(actorCollection(addActor.getFuture())),
															#line 6782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   timeout(),
															#line 6783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugID(),
															#line 6784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   send_batch(),
															#line 6785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   batchSizeDist(Histogram::getHistogram(LiteralStringRef("GrvBatcher"), LiteralStringRef("ClientGrvBatchSize"), Histogram::Unit::countLinear, 0, CLIENT_KNOBS->MAX_BATCH_SIZE * 2)),
															#line 6790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   batchIntervalDist(Histogram::getHistogram(LiteralStringRef("GrvBatcher"), LiteralStringRef("ClientGrvBatchInterval"), Histogram::Unit::microseconds, 0, CLIENT_KNOBS->GRV_BATCH_TIMEOUT * 1000000 * 2)),
															#line 6796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   grvReplyLatencyDist(Histogram::getHistogram( LiteralStringRef("GrvBatcher"), LiteralStringRef("ClientGrvReplyLatency"), Histogram::Unit::microseconds)),
															#line 6798 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   lastRequestTime(now()),
															#line 6800 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tags(),
															#line 6803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   replyTimes(),
															#line 6804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   _errorStream(),
															#line 6805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   batchTime(0),
															#line 6806 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:readVersionBatcher"_loc)
															#line 30288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("readVersionBatcher", reinterpret_cast<unsigned long>(this));

	}
	~ReadVersionBatcherActorState() 
	{
		fdb_probe_actor_destroy("readVersionBatcher", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 6807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 30303 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ReadVersionBatcherActorState();
		static_cast<ReadVersionBatcherActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 6808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		send_batch = false;
															#line 6810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		FutureStream<DatabaseContext::VersionRequest> __when_expr_0 = versionStream;
															#line 6809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ReadVersionBatcherActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 30337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
															#line 6830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = timeout.isValid() ? timeout : Never();
															#line 30341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
															#line 6835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		FutureStream<double> __when_expr_2 = replyTimes.getFuture();
															#line 30345 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when3(__when_expr_2.pop(), loopDepth); };
															#line 6840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = collection;
															#line 30349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when4(__when_expr_3.get(), loopDepth); };
		static_cast<ReadVersionBatcherActor*>(this)->actor_wait_state = 1;
															#line 6810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >*>(static_cast<ReadVersionBatcherActor*>(this)));
															#line 6830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ReadVersionBatcherActor, 1, Void >*>(static_cast<ReadVersionBatcherActor*>(this)));
															#line 6835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorSingleCallback< ReadVersionBatcherActor, 2, double >*>(static_cast<ReadVersionBatcherActor*>(this)));
															#line 6840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< ReadVersionBatcherActor, 3, Void >*>(static_cast<ReadVersionBatcherActor*>(this)));
															#line 30360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 6842 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (send_batch)
															#line 30369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6843 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			int count = requests.size();
															#line 6844 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(count);
															#line 6846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			batchSizeDist->sampleRecordCounter(count);
															#line 6847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto requestTime = now();
															#line 6848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			batchIntervalDist->sampleSeconds(requestTime - lastRequestTime);
															#line 6849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			lastRequestTime = requestTime;
															#line 6852 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Promise<GetReadVersionReply> GRVReply;
															#line 6853 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			requests.push_back(GRVReply);
															#line 6854 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			addActor.send(ready(timeReply(GRVReply.getFuture(), replyTimes)));
															#line 6856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Future<Void> batch = incrementalBroadcastWithError( getConsistentReadVersion(span.context, cx, count, priority, flags, std::move(tags), std::move(debugID)), std::move(requests), CLIENT_KNOBS->BROADCAST_BATCH_SIZE);
															#line 6861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			span = Span("NAPI:readVersionBatcher"_loc);
															#line 6862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tags.clear();
															#line 6863 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			debugID = Optional<UID>();
															#line 6864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			requests.clear();
															#line 6865 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			addActor.send(batch);
															#line 6866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			timeout = Future<Void>();
															#line 30403 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(DatabaseContext::VersionRequest const& req,int loopDepth) 
	{
															#line 6811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (req.debugID.present())
															#line 30413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!debugID.present())
															#line 30417 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				debugID = nondeterministicRandom()->randomUniqueID();
															#line 30421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addAttach("TransactionAttachID", req.debugID.get().first(), debugID.get().first());
															#line 30425 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		span.addParent(req.spanContext);
															#line 6818 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		requests.push_back(req.reply);
															#line 6819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto tag : req.tags ) {
															#line 6820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++tags[tag];
															#line 30435 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (requests.size() == CLIENT_KNOBS->MAX_BATCH_SIZE)
															#line 30439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			send_batch = true;
															#line 6825 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++cx->transactionGrvFullBatches;
															#line 30445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 6826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!timeout.isValid())
															#line 30451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6827 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				timeout = delay(batchTime, TaskPriority::GetConsistentReadVersion);
															#line 30455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(DatabaseContext::VersionRequest && req,int loopDepth) 
	{
															#line 6811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (req.debugID.present())
															#line 30466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!debugID.present())
															#line 30470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				debugID = nondeterministicRandom()->randomUniqueID();
															#line 30474 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 6815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			g_traceBatch.addAttach("TransactionAttachID", req.debugID.get().first(), debugID.get().first());
															#line 30478 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		span.addParent(req.spanContext);
															#line 6818 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		requests.push_back(req.reply);
															#line 6819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto tag : req.tags ) {
															#line 6820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++tags[tag];
															#line 30488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (requests.size() == CLIENT_KNOBS->MAX_BATCH_SIZE)
															#line 30492 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			send_batch = true;
															#line 6825 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			++cx->transactionGrvFullBatches;
															#line 30498 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 6826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!timeout.isValid())
															#line 30504 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6827 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				timeout = delay(batchTime, TaskPriority::GetConsistentReadVersion);
															#line 30508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
															#line 6831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		send_batch = true;
															#line 6832 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionGrvTimedOutBatches;
															#line 30521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
															#line 6831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		send_batch = true;
															#line 6832 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++cx->transactionGrvTimedOutBatches;
															#line 30532 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when3(double const& reply_latency,int loopDepth) 
	{
															#line 6836 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double target_latency = reply_latency * 0.5;
															#line 6837 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		batchTime = std::min(0.1 * target_latency + 0.9 * batchTime, CLIENT_KNOBS->GRV_BATCH_TIMEOUT);
															#line 6838 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		grvReplyLatencyDist->sampleSeconds(reply_latency);
															#line 30545 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when3(double && reply_latency,int loopDepth) 
	{
															#line 6836 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double target_latency = reply_latency * 0.5;
															#line 6837 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		batchTime = std::min(0.1 * target_latency + 0.9 * batchTime, CLIENT_KNOBS->GRV_BATCH_TIMEOUT);
															#line 6838 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		grvReplyLatencyDist->sampleSeconds(reply_latency);
															#line 30558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ReadVersionBatcherActor*>(this)->actor_wait_state > 0) static_cast<ReadVersionBatcherActor*>(this)->actor_wait_state = 0;
		static_cast<ReadVersionBatcherActor*>(this)->ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >::remove();
		static_cast<ReadVersionBatcherActor*>(this)->ActorCallback< ReadVersionBatcherActor, 1, Void >::remove();
		static_cast<ReadVersionBatcherActor*>(this)->ActorSingleCallback< ReadVersionBatcherActor, 2, double >::remove();
		static_cast<ReadVersionBatcherActor*>(this)->ActorCallback< ReadVersionBatcherActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >*,DatabaseContext::VersionRequest const& value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >*,DatabaseContext::VersionRequest && value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >*,Error err) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ReadVersionBatcherActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ReadVersionBatcherActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ReadVersionBatcherActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorSingleCallback< ReadVersionBatcherActor, 2, double >*,double const& value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1loopBody1when3(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorSingleCallback< ReadVersionBatcherActor, 2, double >*,double && value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1loopBody1when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorSingleCallback< ReadVersionBatcherActor, 2, double >*,Error err) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< ReadVersionBatcherActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose1();
		try {
			a_body1loopBody1when4(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< ReadVersionBatcherActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose1();
		try {
			a_body1loopBody1when4(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< ReadVersionBatcherActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	FutureStream<DatabaseContext::VersionRequest> versionStream;
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionPriority priority;
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	uint32_t flags;
															#line 6779 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Promise<GetReadVersionReply>> requests;
															#line 6780 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<Future<Void>> addActor;
															#line 6781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> collection;
															#line 6782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> timeout;
															#line 6783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<UID> debugID;
															#line 6784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool send_batch;
															#line 6785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<Histogram> batchSizeDist;
															#line 6790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<Histogram> batchIntervalDist;
															#line 6796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<Histogram> grvReplyLatencyDist;
															#line 6798 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double lastRequestTime;
															#line 6800 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TransactionTagMap<uint32_t> tags;
															#line 6803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<double> replyTimes;
															#line 6804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<Error> _errorStream;
															#line 6805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double batchTime;
															#line 6806 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 30802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via readVersionBatcher()
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ReadVersionBatcherActor final : public Actor<Void>, public ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >, public ActorCallback< ReadVersionBatcherActor, 1, Void >, public ActorSingleCallback< ReadVersionBatcherActor, 2, double >, public ActorCallback< ReadVersionBatcherActor, 3, Void >, public FastAllocated<ReadVersionBatcherActor>, public ReadVersionBatcherActorState<ReadVersionBatcherActor> {
															#line 30807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ReadVersionBatcherActor>::operator new;
	using FastAllocated<ReadVersionBatcherActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >;
friend struct ActorCallback< ReadVersionBatcherActor, 1, Void >;
friend struct ActorSingleCallback< ReadVersionBatcherActor, 2, double >;
friend struct ActorCallback< ReadVersionBatcherActor, 3, Void >;
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadVersionBatcherActor(DatabaseContext* const& cx,FutureStream<DatabaseContext::VersionRequest> const& versionStream,TransactionPriority const& priority,uint32_t const& flags) 
															#line 30821 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   ReadVersionBatcherActorState<ReadVersionBatcherActor>(cx, versionStream, priority, flags)
	{
		fdb_probe_actor_enter("readVersionBatcher", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("readVersionBatcher");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("readVersionBatcher", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< ReadVersionBatcherActor, 0, DatabaseContext::VersionRequest >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> readVersionBatcher( DatabaseContext* const& cx, FutureStream<DatabaseContext::VersionRequest> const& versionStream, TransactionPriority const& priority, uint32_t const& flags ) {
															#line 6775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new ReadVersionBatcherActor(cx, versionStream, priority, flags));
															#line 30849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 6870 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 30854 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via extractReadVersion()
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ExtractReadVersionActor>
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ExtractReadVersionActorState {
															#line 30861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ExtractReadVersionActorState(Reference<TransactionState> const& trState,Location const& location,SpanID const& spanContext,Future<GetReadVersionReply> const& f,Promise<Optional<Value>> const& metadataVersion) 
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   location(location),
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   spanContext(spanContext),
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   f(f),
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   metadataVersion(metadataVersion),
															#line 6876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span(spanContext, location, { trState->spanID })
															#line 30878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("extractReadVersion", reinterpret_cast<unsigned long>(this));

	}
	~ExtractReadVersionActorState() 
	{
		fdb_probe_actor_destroy("extractReadVersion", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 6877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<GetReadVersionReply> __when_expr_0 = f;
															#line 6877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ExtractReadVersionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 30895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<ExtractReadVersionActor*>(this)->actor_wait_state = 1;
															#line 6877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >*>(static_cast<ExtractReadVersionActor*>(this)));
															#line 30900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ExtractReadVersionActorState();
		static_cast<ExtractReadVersionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(GetReadVersionReply const& rep,int loopDepth) 
	{
															#line 6878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double replyTime = now();
															#line 6879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double latency = replyTime - trState->startTime;
															#line 6880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->lastProxyRequestTime = trState->startTime;
															#line 6881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->updateCachedReadVersion(trState->startTime, rep.version);
															#line 6882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.rkBatchThrottled)
															#line 30931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->lastRkBatchThrottleTime = replyTime;
															#line 30935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6885 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.rkDefaultThrottled)
															#line 30939 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->lastRkDefaultThrottleTime = replyTime;
															#line 30943 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->GRVLatencies.addSample(latency);
															#line 6889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->trLogInfo)
															#line 30949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6890 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->trLogInfo->addLog(FdbClientLogEvents::EventGetVersion_V3(trState->startTime, trState->cx->clientLocality.dcId(), latency, trState->options.priority, rep.version, trState->tenant()));
															#line 30953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.locked && !trState->options.lockAware)
															#line 30957 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(database_locked(), loopDepth);
															#line 30961 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6899 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionReadVersionsCompleted;
															#line 6900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		switch (trState->options.priority) { case TransactionPriority::IMMEDIATE: ++trState->cx->transactionImmediateReadVersionsCompleted; break; case TransactionPriority::DEFAULT: ++trState->cx->transactionDefaultReadVersionsCompleted; break; case TransactionPriority::BATCH: ++trState->cx->transactionBatchReadVersionsCompleted; break; default: ASSERT(false); };
															#line 6914 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->options.tags.size() != 0)
															#line 30969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto& priorityThrottledTags = trState->cx->throttledTags[trState->options.priority];
															#line 6916 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& tag : trState->options.tags ) {
															#line 6917 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto itr = priorityThrottledTags.find(tag);
															#line 6918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (itr != priorityThrottledTags.end())
															#line 30979 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (itr->second.expired())
															#line 30983 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 6920 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						priorityThrottledTags.erase(itr);
															#line 30987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
					else
					{
															#line 6921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						if (itr->second.throttleDuration() > 0)
															#line 30993 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
						{
															#line 6922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							TEST(true);
															#line 6923 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							++trState->cx->transactionReadVersionsThrottled;
															#line 6924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							return a_body1Catch1(tag_throttled(), loopDepth);
															#line 31001 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
						}
					}
				}
			}
															#line 6929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& tag : trState->options.tags ) {
															#line 6930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto itr = priorityThrottledTags.find(tag);
															#line 6931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (itr != priorityThrottledTags.end())
															#line 31012 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6932 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					itr->second.addReleased(1);
															#line 31016 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 6937 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.version > trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation].first)
															#line 31022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6938 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->mvCacheInsertLocation = (trState->cx->mvCacheInsertLocation + 1) % trState->cx->metadataVersionCache.size();
															#line 6940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation] = std::make_pair(rep.version, rep.metadataVersion);
															#line 31028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		metadataVersion.send(rep.metadataVersion);
															#line 6945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->cx->versionVectorCacheActive(rep.ssVersionVectorDelta))
															#line 31034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->cx->isCurrentGrvProxy(rep.proxyId))
															#line 31038 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.applyDelta(rep.ssVersionVectorDelta);
															#line 31042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 6949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.clear();
															#line 31048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 6952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ExtractReadVersionActor*>(this)->SAV<Version>::futures) { (void)(rep.version); this->~ExtractReadVersionActorState(); static_cast<ExtractReadVersionActor*>(this)->destroy(); return 0; }
															#line 31053 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ExtractReadVersionActor*>(this)->SAV< Version >::value()) Version(rep.version);
		this->~ExtractReadVersionActorState();
		static_cast<ExtractReadVersionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(GetReadVersionReply && rep,int loopDepth) 
	{
															#line 6878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double replyTime = now();
															#line 6879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		double latency = replyTime - trState->startTime;
															#line 6880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->lastProxyRequestTime = trState->startTime;
															#line 6881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->updateCachedReadVersion(trState->startTime, rep.version);
															#line 6882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.rkBatchThrottled)
															#line 31073 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->lastRkBatchThrottleTime = replyTime;
															#line 31077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6885 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.rkDefaultThrottled)
															#line 31081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->lastRkDefaultThrottleTime = replyTime;
															#line 31085 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		trState->cx->GRVLatencies.addSample(latency);
															#line 6889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->trLogInfo)
															#line 31091 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6890 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->trLogInfo->addLog(FdbClientLogEvents::EventGetVersion_V3(trState->startTime, trState->cx->clientLocality.dcId(), latency, trState->options.priority, rep.version, trState->tenant()));
															#line 31095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.locked && !trState->options.lockAware)
															#line 31099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(database_locked(), loopDepth);
															#line 31103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6899 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		++trState->cx->transactionReadVersionsCompleted;
															#line 6900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		switch (trState->options.priority) { case TransactionPriority::IMMEDIATE: ++trState->cx->transactionImmediateReadVersionsCompleted; break; case TransactionPriority::DEFAULT: ++trState->cx->transactionDefaultReadVersionsCompleted; break; case TransactionPriority::BATCH: ++trState->cx->transactionBatchReadVersionsCompleted; break; default: ASSERT(false); };
															#line 6914 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->options.tags.size() != 0)
															#line 31111 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto& priorityThrottledTags = trState->cx->throttledTags[trState->options.priority];
															#line 6916 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& tag : trState->options.tags ) {
															#line 6917 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto itr = priorityThrottledTags.find(tag);
															#line 6918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (itr != priorityThrottledTags.end())
															#line 31121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (itr->second.expired())
															#line 31125 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 6920 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						priorityThrottledTags.erase(itr);
															#line 31129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
					else
					{
															#line 6921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						if (itr->second.throttleDuration() > 0)
															#line 31135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
						{
															#line 6922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							TEST(true);
															#line 6923 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							++trState->cx->transactionReadVersionsThrottled;
															#line 6924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
							return a_body1Catch1(tag_throttled(), loopDepth);
															#line 31143 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
						}
					}
				}
			}
															#line 6929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& tag : trState->options.tags ) {
															#line 6930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				auto itr = priorityThrottledTags.find(tag);
															#line 6931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (itr != priorityThrottledTags.end())
															#line 31154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 6932 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					itr->second.addReleased(1);
															#line 31158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 6937 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.version > trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation].first)
															#line 31164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6938 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->mvCacheInsertLocation = (trState->cx->mvCacheInsertLocation + 1) % trState->cx->metadataVersionCache.size();
															#line 6940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			trState->cx->metadataVersionCache[trState->cx->mvCacheInsertLocation] = std::make_pair(rep.version, rep.metadataVersion);
															#line 31170 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 6944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		metadataVersion.send(rep.metadataVersion);
															#line 6945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (trState->cx->versionVectorCacheActive(rep.ssVersionVectorDelta))
															#line 31176 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 6946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (trState->cx->isCurrentGrvProxy(rep.proxyId))
															#line 31180 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 6947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.applyDelta(rep.ssVersionVectorDelta);
															#line 31184 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 6949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->ssVersionVectorCache.clear();
															#line 31190 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 6952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ExtractReadVersionActor*>(this)->SAV<Version>::futures) { (void)(rep.version); this->~ExtractReadVersionActorState(); static_cast<ExtractReadVersionActor*>(this)->destroy(); return 0; }
															#line 31195 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ExtractReadVersionActor*>(this)->SAV< Version >::value()) Version(rep.version);
		this->~ExtractReadVersionActorState();
		static_cast<ExtractReadVersionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(GetReadVersionReply const& rep,int loopDepth) 
	{
		loopDepth = a_body1cont1(rep, loopDepth);

		return loopDepth;
	}
	int a_body1when1(GetReadVersionReply && rep,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(rep), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ExtractReadVersionActor*>(this)->actor_wait_state > 0) static_cast<ExtractReadVersionActor*>(this)->actor_wait_state = 0;
		static_cast<ExtractReadVersionActor*>(this)->ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >::remove();

	}
	void a_callback_fire(ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >*,GetReadVersionReply const& value) 
	{
		fdb_probe_actor_enter("extractReadVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("extractReadVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >*,GetReadVersionReply && value) 
	{
		fdb_probe_actor_enter("extractReadVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("extractReadVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >*,Error err) 
	{
		fdb_probe_actor_enter("extractReadVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("extractReadVersion", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Location location;
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SpanID spanContext;
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<GetReadVersionReply> f;
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<Optional<Value>> metadataVersion;
															#line 6876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 31278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via extractReadVersion()
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ExtractReadVersionActor final : public Actor<Version>, public ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >, public FastAllocated<ExtractReadVersionActor>, public ExtractReadVersionActorState<ExtractReadVersionActor> {
															#line 31283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ExtractReadVersionActor>::operator new;
	using FastAllocated<ExtractReadVersionActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Version>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >;
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ExtractReadVersionActor(Reference<TransactionState> const& trState,Location const& location,SpanID const& spanContext,Future<GetReadVersionReply> const& f,Promise<Optional<Value>> const& metadataVersion) 
															#line 31294 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Version>(),
		   ExtractReadVersionActorState<ExtractReadVersionActor>(trState, location, spanContext, f, metadataVersion)
	{
		fdb_probe_actor_enter("extractReadVersion", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("extractReadVersion");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("extractReadVersion", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ExtractReadVersionActor, 0, GetReadVersionReply >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Version> extractReadVersion( Reference<TransactionState> const& trState, Location const& location, SpanID const& spanContext, Future<GetReadVersionReply> const& f, Promise<Optional<Value>> const& metadataVersion ) {
															#line 6871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Version>(new ExtractReadVersionActor(trState, location, spanContext, f, metadataVersion));
															#line 31322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 6954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

bool rkThrottlingCooledDown(DatabaseContext* cx, TransactionPriority priority) {
	if (priority == TransactionPriority::IMMEDIATE) {
		return true;
	} else if (priority == TransactionPriority::BATCH) {
		if (cx->lastRkBatchThrottleTime == 0.0) {
			return true;
		}
		return (now() - cx->lastRkBatchThrottleTime > CLIENT_KNOBS->GRV_CACHE_RK_COOLDOWN);
	} else if (priority == TransactionPriority::DEFAULT) {
		if (cx->lastRkDefaultThrottleTime == 0.0) {
			return true;
		}
		return (now() - cx->lastRkDefaultThrottleTime > CLIENT_KNOBS->GRV_CACHE_RK_COOLDOWN);
	}
	return false;
}

Future<Version> Transaction::getReadVersion(uint32_t flags) {
	if (!readVersion.isValid()) {
		if (!CLIENT_KNOBS->FORCE_GRV_CACHE_OFF && !trState->options.skipGrvCache &&
		    (deterministicRandom()->random01() <= CLIENT_KNOBS->DEBUG_USE_GRV_CACHE_CHANCE ||
		     trState->options.useGrvCache) &&
		    rkThrottlingCooledDown(getDatabase().getPtr(), trState->options.priority)) {
			// Upon our first request to use cached RVs, start the background updater
			if (!trState->cx->grvUpdateHandler.isValid()) {
				trState->cx->grvUpdateHandler = backgroundGrvUpdater(getDatabase().getPtr());
			}
			Version rv = trState->cx->getCachedReadVersion();
			double lastTime = trState->cx->getLastGrvTime();
			double requestTime = now();
			if (requestTime - lastTime <= CLIENT_KNOBS->MAX_VERSION_CACHE_LAG && rv != Version(0)) {
				ASSERT(!debug_checkVersionTime(rv, requestTime, "CheckStaleness"));
				readVersion = rv;
				return readVersion;
			} // else go through regular GRV path
		}
		++trState->cx->transactionReadVersions;
		flags |= trState->options.getReadVersionFlags;
		switch (trState->options.priority) {
		case TransactionPriority::IMMEDIATE:
			flags |= GetReadVersionRequest::PRIORITY_SYSTEM_IMMEDIATE;
			++trState->cx->transactionImmediateReadVersions;
			break;
		case TransactionPriority::DEFAULT:
			flags |= GetReadVersionRequest::PRIORITY_DEFAULT;
			++trState->cx->transactionDefaultReadVersions;
			break;
		case TransactionPriority::BATCH:
			flags |= GetReadVersionRequest::PRIORITY_BATCH;
			++trState->cx->transactionBatchReadVersions;
			break;
		default:
			ASSERT(false);
		}

		if (trState->options.tags.size() != 0) {
			double maxThrottleDelay = 0.0;
			bool canRecheck = false;

			auto& priorityThrottledTags = trState->cx->throttledTags[trState->options.priority];
			for (auto& tag : trState->options.tags) {
				auto itr = priorityThrottledTags.find(tag);
				if (itr != priorityThrottledTags.end()) {
					if (!itr->second.expired()) {
						maxThrottleDelay = std::max(maxThrottleDelay, itr->second.throttleDuration());
						canRecheck = itr->second.canRecheck();
					} else {
						priorityThrottledTags.erase(itr);
					}
				}
			}

			if (maxThrottleDelay > 0.0 && !canRecheck) { // TODO: allow delaying?
				TEST(true); // Throttling tag before GRV request
				++trState->cx->transactionReadVersionsThrottled;
				readVersion = tag_throttled();
				return readVersion;
			} else {
				TEST(maxThrottleDelay > 0.0); // Rechecking throttle
			}

			for (auto& tag : trState->options.tags) {
				auto itr = priorityThrottledTags.find(tag);
				if (itr != priorityThrottledTags.end()) {
					itr->second.updateChecked();
				}
			}
		}

		auto& batcher = trState->cx->versionBatcher[flags];
		if (!batcher.actor.isValid()) {
			batcher.actor =
			    readVersionBatcher(trState->cx.getPtr(), batcher.stream.getFuture(), trState->options.priority, flags);
		}

		Location location = "NAPI:getReadVersion"_loc;
		UID spanContext = generateSpanID(trState->cx->transactionTracingSample, trState->spanID);
		auto const req = DatabaseContext::VersionRequest(spanContext, trState->options.tags, trState->debugID);
		batcher.stream.send(req);
		trState->startTime = now();
		readVersion = extractReadVersion(trState, location, spanContext, req.reply.getFuture(), metadataVersion);
	}
	return readVersion;
}

Optional<Version> Transaction::getCachedReadVersion() const {
	if (readVersion.isValid() && readVersion.isReady() && !readVersion.isError()) {
		return readVersion.get();
	} else {
		return Optional<Version>();
	}
}

Future<Standalone<StringRef>> Transaction::getVersionstamp() {
	if (committing.isValid()) {
		return transaction_invalid_version();
	}
	return trState->versionstampPromise.getFuture();
}

// Gets the protocol version reported by a coordinator via the protocol info interface
															#line 31448 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getCoordinatorProtocol()
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetCoordinatorProtocolActor>
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCoordinatorProtocolActorState {
															#line 31455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCoordinatorProtocolActorState(NetworkAddress const& coordinatorAddress) 
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : coordinatorAddress(coordinatorAddress)
															#line 31462 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this));

	}
	~GetCoordinatorProtocolActorState() 
	{
		fdb_probe_actor_destroy("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			RequestStream<ProtocolInfoRequest> requestStream( Endpoint::wellKnown({ coordinatorAddress }, WLTOKEN_PROTOCOL_INFO));
															#line 7079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<ProtocolInfoReply> __when_expr_0 = retryBrokenPromise(requestStream, ProtocolInfoRequest{});
															#line 7079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetCoordinatorProtocolActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 31481 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetCoordinatorProtocolActor*>(this)->actor_wait_state = 1;
															#line 7079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >*>(static_cast<GetCoordinatorProtocolActor*>(this)));
															#line 31486 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetCoordinatorProtocolActorState();
		static_cast<GetCoordinatorProtocolActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(ProtocolInfoReply const& reply,int loopDepth) 
	{
															#line 7080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetCoordinatorProtocolActor*>(this)->SAV<ProtocolVersion>::futures) { (void)(reply.version); this->~GetCoordinatorProtocolActorState(); static_cast<GetCoordinatorProtocolActor*>(this)->destroy(); return 0; }
															#line 31509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetCoordinatorProtocolActor*>(this)->SAV< ProtocolVersion >::value()) ProtocolVersion(reply.version);
		this->~GetCoordinatorProtocolActorState();
		static_cast<GetCoordinatorProtocolActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(ProtocolInfoReply && reply,int loopDepth) 
	{
															#line 7080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetCoordinatorProtocolActor*>(this)->SAV<ProtocolVersion>::futures) { (void)(reply.version); this->~GetCoordinatorProtocolActorState(); static_cast<GetCoordinatorProtocolActor*>(this)->destroy(); return 0; }
															#line 31521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetCoordinatorProtocolActor*>(this)->SAV< ProtocolVersion >::value()) ProtocolVersion(reply.version);
		this->~GetCoordinatorProtocolActorState();
		static_cast<GetCoordinatorProtocolActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(ProtocolInfoReply const& reply,int loopDepth) 
	{
		loopDepth = a_body1cont1(reply, loopDepth);

		return loopDepth;
	}
	int a_body1when1(ProtocolInfoReply && reply,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(reply), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetCoordinatorProtocolActor*>(this)->actor_wait_state > 0) static_cast<GetCoordinatorProtocolActor*>(this)->actor_wait_state = 0;
		static_cast<GetCoordinatorProtocolActor*>(this)->ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >::remove();

	}
	void a_callback_fire(ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >*,ProtocolInfoReply const& value) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >*,ProtocolInfoReply && value) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >*,Error err) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	NetworkAddress coordinatorAddress;
															#line 31594 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getCoordinatorProtocol()
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCoordinatorProtocolActor final : public Actor<ProtocolVersion>, public ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >, public FastAllocated<GetCoordinatorProtocolActor>, public GetCoordinatorProtocolActorState<GetCoordinatorProtocolActor> {
															#line 31599 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetCoordinatorProtocolActor>::operator new;
	using FastAllocated<GetCoordinatorProtocolActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<ProtocolVersion>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >;
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCoordinatorProtocolActor(NetworkAddress const& coordinatorAddress) 
															#line 31610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<ProtocolVersion>(),
		   GetCoordinatorProtocolActorState<GetCoordinatorProtocolActor>(coordinatorAddress)
	{
		fdb_probe_actor_enter("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getCoordinatorProtocol");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getCoordinatorProtocol", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetCoordinatorProtocolActor, 0, ProtocolInfoReply >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<ProtocolVersion> getCoordinatorProtocol( NetworkAddress const& coordinatorAddress ) {
															#line 7076 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<ProtocolVersion>(new GetCoordinatorProtocolActor(coordinatorAddress));
															#line 31638 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Gets the protocol version reported by a coordinator in its connect packet
// If we are unable to get a version from the connect packet (e.g. because we lost connection with the peer), then this
// function will return with an unset result.
// If an expected version is given, this future won't return if the actual protocol version matches the expected version
															#line 31647 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getCoordinatorProtocolFromConnectPacket()
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetCoordinatorProtocolFromConnectPacketActor>
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCoordinatorProtocolFromConnectPacketActorState {
															#line 31654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCoordinatorProtocolFromConnectPacketActorState(NetworkAddress const& coordinatorAddress,Optional<ProtocolVersion> const& expectedVersion) 
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : coordinatorAddress(coordinatorAddress),
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   expectedVersion(expectedVersion),
															#line 7090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   protocolVersion(FlowTransport::transport().getPeerProtocolAsyncVar(coordinatorAddress))
															#line 31665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this));

	}
	~GetCoordinatorProtocolFromConnectPacketActorState() 
	{
		fdb_probe_actor_destroy("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!protocolVersion.present())
															#line 31680 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7094 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevWarnAlways, "GetCoordinatorProtocolPeerMissing").detail("Address", coordinatorAddress);
															#line 7095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_0 = delay(FLOW_KNOBS->CONNECTION_MONITOR_TIMEOUT);
															#line 7095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 31688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state = 1;
															#line 7095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >*>(static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)));
															#line 31693 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont1(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetCoordinatorProtocolFromConnectPacketActorState();
		static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 7099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 31721 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 7096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV<Optional<ProtocolVersion>>::futures) { (void)(Optional<ProtocolVersion>()); this->~GetCoordinatorProtocolFromConnectPacketActorState(); static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->destroy(); return 0; }
															#line 31730 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV< Optional<ProtocolVersion> >::value()) Optional<ProtocolVersion>(Optional<ProtocolVersion>());
		this->~GetCoordinatorProtocolFromConnectPacketActorState();
		static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 7096 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV<Optional<ProtocolVersion>>::futures) { (void)(Optional<ProtocolVersion>()); this->~GetCoordinatorProtocolFromConnectPacketActorState(); static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->destroy(); return 0; }
															#line 31742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV< Optional<ProtocolVersion> >::value()) Optional<ProtocolVersion>(Optional<ProtocolVersion>());
		this->~GetCoordinatorProtocolFromConnectPacketActorState();
		static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state > 0) static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state = 0;
		static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 7100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (protocolVersion.get()->get().present() && protocolVersion.get()->get() != expectedVersion)
															#line 31824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7101 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV<Optional<ProtocolVersion>>::futures) { (void)(protocolVersion.get()->get()); this->~GetCoordinatorProtocolFromConnectPacketActorState(); static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->destroy(); return 0; }
															#line 31828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV< Optional<ProtocolVersion> >::value()) Optional<ProtocolVersion>(protocolVersion.get()->get());
			this->~GetCoordinatorProtocolFromConnectPacketActorState();
			static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7104 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Future<Void> change = protocolVersion.get()->onChange();
															#line 7105 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!protocolVersion.get()->get().present())
															#line 31838 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7107 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			change = timeout(change, FLOW_KNOBS->CONNECTION_MONITOR_TIMEOUT, Void());
															#line 31842 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = change;
															#line 7110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 31848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state = 2;
															#line 7110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >*>(static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)));
															#line 31853 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 7112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!protocolVersion.get()->get().present())
															#line 31862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7113 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV<Optional<ProtocolVersion>>::futures) { (void)(protocolVersion.get()->get()); this->~GetCoordinatorProtocolFromConnectPacketActorState(); static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->destroy(); return 0; }
															#line 31866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV< Optional<ProtocolVersion> >::value()) Optional<ProtocolVersion>(protocolVersion.get()->get());
			this->~GetCoordinatorProtocolFromConnectPacketActorState();
			static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 7112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!protocolVersion.get()->get().present())
															#line 31880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7113 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV<Optional<ProtocolVersion>>::futures) { (void)(protocolVersion.get()->get()); this->~GetCoordinatorProtocolFromConnectPacketActorState(); static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->destroy(); return 0; }
															#line 31884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->SAV< Optional<ProtocolVersion> >::value()) Optional<ProtocolVersion>(protocolVersion.get()->get());
			this->~GetCoordinatorProtocolFromConnectPacketActorState();
			static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state > 0) static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->actor_wait_state = 0;
		static_cast<GetCoordinatorProtocolFromConnectPacketActor*>(this)->ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	NetworkAddress coordinatorAddress;
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<ProtocolVersion> expectedVersion;
															#line 7090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<Reference<AsyncVar<Optional<ProtocolVersion>> const>> protocolVersion;
															#line 31963 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getCoordinatorProtocolFromConnectPacket()
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCoordinatorProtocolFromConnectPacketActor final : public Actor<Optional<ProtocolVersion>>, public ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >, public ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >, public FastAllocated<GetCoordinatorProtocolFromConnectPacketActor>, public GetCoordinatorProtocolFromConnectPacketActorState<GetCoordinatorProtocolFromConnectPacketActor> {
															#line 31968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetCoordinatorProtocolFromConnectPacketActor>::operator new;
	using FastAllocated<GetCoordinatorProtocolFromConnectPacketActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Optional<ProtocolVersion>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >;
friend struct ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >;
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCoordinatorProtocolFromConnectPacketActor(NetworkAddress const& coordinatorAddress,Optional<ProtocolVersion> const& expectedVersion) 
															#line 31980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Optional<ProtocolVersion>>(),
		   GetCoordinatorProtocolFromConnectPacketActorState<GetCoordinatorProtocolFromConnectPacketActor>(coordinatorAddress, expectedVersion)
	{
		fdb_probe_actor_enter("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getCoordinatorProtocolFromConnectPacket");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getCoordinatorProtocolFromConnectPacket", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetCoordinatorProtocolFromConnectPacketActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Optional<ProtocolVersion>> getCoordinatorProtocolFromConnectPacket( NetworkAddress const& coordinatorAddress, Optional<ProtocolVersion> const& expectedVersion ) {
															#line 7087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Optional<ProtocolVersion>>(new GetCoordinatorProtocolFromConnectPacketActor(coordinatorAddress, expectedVersion));
															#line 32009 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7117 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Returns the protocol version reported by the given coordinator
// If an expected version is given, the future won't return until the protocol version is different than expected
															#line 32016 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getClusterProtocolImpl()
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetClusterProtocolImplActor>
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetClusterProtocolImplActorState {
															#line 32023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetClusterProtocolImplActorState(Reference<AsyncVar<Optional<ClientLeaderRegInterface>> const> const& coordinator,Optional<ProtocolVersion> const& expectedVersion) 
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : coordinator(coordinator),
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   expectedVersion(expectedVersion),
															#line 7123 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   needToConnect(true),
															#line 7124 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   protocolVersion(Never())
															#line 32036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this));

	}
	~GetClusterProtocolImplActorState() 
	{
		fdb_probe_actor_destroy("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 32051 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetClusterProtocolImplActorState();
		static_cast<GetClusterProtocolImplActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!coordinator->get().present())
															#line 32081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = coordinator->onChange();
															#line 7128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 32087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state = 1;
															#line 7128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetClusterProtocolImplActor, 0, Void >*>(static_cast<GetClusterProtocolImplActor*>(this)));
															#line 32092 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 7130 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			coordinatorAddress = NetworkAddress();
															#line 7131 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (coordinator->get().get().hostname.present())
															#line 32101 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				h = coordinator->get().get().hostname.get();
															#line 7133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_1 = store(coordinatorAddress, h.resolveWithRetry());
															#line 7133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 32109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
				static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state = 2;
															#line 7133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetClusterProtocolImplActor, 1, Void >*>(static_cast<GetClusterProtocolImplActor*>(this)));
															#line 32114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 7135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				coordinatorAddress = coordinator->get().get().getLeader.getEndpoint().getPrimaryAddress();
															#line 32121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopBody1cont3(loopDepth);
			}
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state > 0) static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state = 0;
		static_cast<GetClusterProtocolImplActor*>(this)->ActorCallback< GetClusterProtocolImplActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetClusterProtocolImplActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
															#line 7138 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (needToConnect)
															#line 32213 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7141 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			protocolVersion = getCoordinatorProtocol(coordinatorAddress);
															#line 7142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			needToConnect = false;
															#line 32219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = coordinator->onChange();
															#line 7144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 32225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
															#line 7149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<ProtocolVersion> __when_expr_3 = protocolVersion;
															#line 32229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont3when2(__when_expr_3.get(), loopDepth); };
															#line 7159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Optional<ProtocolVersion>> __when_expr_4 = getCoordinatorProtocolFromConnectPacket(coordinatorAddress, expectedVersion);
															#line 32233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont3when3(__when_expr_4.get(), loopDepth); };
		static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state = 3;
															#line 7145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetClusterProtocolImplActor, 2, Void >*>(static_cast<GetClusterProtocolImplActor*>(this)));
															#line 7149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetClusterProtocolImplActor, 3, ProtocolVersion >*>(static_cast<GetClusterProtocolImplActor*>(this)));
															#line 7159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetClusterProtocolImplActor, 4, Optional<ProtocolVersion> >*>(static_cast<GetClusterProtocolImplActor*>(this)));
															#line 32242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state > 0) static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state = 0;
		static_cast<GetClusterProtocolImplActor*>(this)->ActorCallback< GetClusterProtocolImplActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetClusterProtocolImplActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
															#line 7146 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		needToConnect = true;
															#line 32332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void && _,int loopDepth) 
	{
															#line 7146 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		needToConnect = true;
															#line 32341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when2(ProtocolVersion const& pv,int loopDepth) 
	{
															#line 7150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!expectedVersion.present() || expectedVersion.get() != pv)
															#line 32350 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetClusterProtocolImplActor*>(this)->SAV<ProtocolVersion>::futures) { (void)(pv); this->~GetClusterProtocolImplActorState(); static_cast<GetClusterProtocolImplActor*>(this)->destroy(); return 0; }
															#line 32354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetClusterProtocolImplActor*>(this)->SAV< ProtocolVersion >::value()) ProtocolVersion(pv);
			this->~GetClusterProtocolImplActorState();
			static_cast<GetClusterProtocolImplActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		protocolVersion = Never();
															#line 32362 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when2(ProtocolVersion && pv,int loopDepth) 
	{
															#line 7150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!expectedVersion.present() || expectedVersion.get() != pv)
															#line 32371 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetClusterProtocolImplActor*>(this)->SAV<ProtocolVersion>::futures) { (void)(pv); this->~GetClusterProtocolImplActorState(); static_cast<GetClusterProtocolImplActor*>(this)->destroy(); return 0; }
															#line 32375 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetClusterProtocolImplActor*>(this)->SAV< ProtocolVersion >::value()) ProtocolVersion(pv);
			this->~GetClusterProtocolImplActorState();
			static_cast<GetClusterProtocolImplActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		protocolVersion = Never();
															#line 32383 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when3(Optional<ProtocolVersion> const& pv,int loopDepth) 
	{
															#line 7161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (pv.present())
															#line 32392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetClusterProtocolImplActor*>(this)->SAV<ProtocolVersion>::futures) { (void)(pv.get()); this->~GetClusterProtocolImplActorState(); static_cast<GetClusterProtocolImplActor*>(this)->destroy(); return 0; }
															#line 32396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetClusterProtocolImplActor*>(this)->SAV< ProtocolVersion >::value()) ProtocolVersion(pv.get());
			this->~GetClusterProtocolImplActorState();
			static_cast<GetClusterProtocolImplActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 7164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			needToConnect = true;
															#line 32406 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when3(Optional<ProtocolVersion> && pv,int loopDepth) 
	{
															#line 7161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (pv.present())
															#line 32416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetClusterProtocolImplActor*>(this)->SAV<ProtocolVersion>::futures) { (void)(pv.get()); this->~GetClusterProtocolImplActorState(); static_cast<GetClusterProtocolImplActor*>(this)->destroy(); return 0; }
															#line 32420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetClusterProtocolImplActor*>(this)->SAV< ProtocolVersion >::value()) ProtocolVersion(pv.get());
			this->~GetClusterProtocolImplActorState();
			static_cast<GetClusterProtocolImplActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 7164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			needToConnect = true;
															#line 32430 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state > 0) static_cast<GetClusterProtocolImplActor*>(this)->actor_wait_state = 0;
		static_cast<GetClusterProtocolImplActor*>(this)->ActorCallback< GetClusterProtocolImplActor, 2, Void >::remove();
		static_cast<GetClusterProtocolImplActor*>(this)->ActorCallback< GetClusterProtocolImplActor, 3, ProtocolVersion >::remove();
		static_cast<GetClusterProtocolImplActor*>(this)->ActorCallback< GetClusterProtocolImplActor, 4, Optional<ProtocolVersion> >::remove();

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetClusterProtocolImplActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 3, ProtocolVersion >*,ProtocolVersion const& value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 3, ProtocolVersion >*,ProtocolVersion && value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetClusterProtocolImplActor, 3, ProtocolVersion >*,Error err) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 4, Optional<ProtocolVersion> >*,Optional<ProtocolVersion> const& value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when3(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetClusterProtocolImplActor, 4, Optional<ProtocolVersion> >*,Optional<ProtocolVersion> && value) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetClusterProtocolImplActor, 4, Optional<ProtocolVersion> >*,Error err) 
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<AsyncVar<Optional<ClientLeaderRegInterface>> const> coordinator;
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<ProtocolVersion> expectedVersion;
															#line 7123 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool needToConnect;
															#line 7124 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<ProtocolVersion> protocolVersion;
															#line 7130 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	NetworkAddress coordinatorAddress;
															#line 7132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Hostname h;
															#line 32591 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getClusterProtocolImpl()
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetClusterProtocolImplActor final : public Actor<ProtocolVersion>, public ActorCallback< GetClusterProtocolImplActor, 0, Void >, public ActorCallback< GetClusterProtocolImplActor, 1, Void >, public ActorCallback< GetClusterProtocolImplActor, 2, Void >, public ActorCallback< GetClusterProtocolImplActor, 3, ProtocolVersion >, public ActorCallback< GetClusterProtocolImplActor, 4, Optional<ProtocolVersion> >, public FastAllocated<GetClusterProtocolImplActor>, public GetClusterProtocolImplActorState<GetClusterProtocolImplActor> {
															#line 32596 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetClusterProtocolImplActor>::operator new;
	using FastAllocated<GetClusterProtocolImplActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<ProtocolVersion>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetClusterProtocolImplActor, 0, Void >;
friend struct ActorCallback< GetClusterProtocolImplActor, 1, Void >;
friend struct ActorCallback< GetClusterProtocolImplActor, 2, Void >;
friend struct ActorCallback< GetClusterProtocolImplActor, 3, ProtocolVersion >;
friend struct ActorCallback< GetClusterProtocolImplActor, 4, Optional<ProtocolVersion> >;
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetClusterProtocolImplActor(Reference<AsyncVar<Optional<ClientLeaderRegInterface>> const> const& coordinator,Optional<ProtocolVersion> const& expectedVersion) 
															#line 32611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<ProtocolVersion>(),
		   GetClusterProtocolImplActorState<GetClusterProtocolImplActor>(coordinator, expectedVersion)
	{
		fdb_probe_actor_enter("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getClusterProtocolImpl");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getClusterProtocolImpl", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetClusterProtocolImplActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetClusterProtocolImplActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetClusterProtocolImplActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<ProtocolVersion> getClusterProtocolImpl( Reference<AsyncVar<Optional<ClientLeaderRegInterface>> const> const& coordinator, Optional<ProtocolVersion> const& expectedVersion ) {
															#line 7120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<ProtocolVersion>(new GetClusterProtocolImplActor(coordinator, expectedVersion));
															#line 32641 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7171 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// Returns the protocol version reported by the coordinator this client is currently connected to
// If an expected version is given, the future won't return until the protocol version is different than expected
// Note: this will never return if the server is running a protocol from FDB 5.0 or older
Future<ProtocolVersion> DatabaseContext::getClusterProtocol(Optional<ProtocolVersion> expectedVersion) {
	return getClusterProtocolImpl(coordinator, expectedVersion);
}

uint32_t Transaction::getSize() {
	auto s = tr.transaction.mutations.expectedSize() + tr.transaction.read_conflict_ranges.expectedSize() +
	         tr.transaction.write_conflict_ranges.expectedSize();
	return s;
}

Future<Void> Transaction::onError(Error const& e) {
	if (g_network->isSimulated() && ++trState->numErrors % 10 == 0) {
		TraceEvent(SevWarnAlways, "TransactionTooManyRetries").detail("NumRetries", trState->numErrors);
	}
	if (e.code() == error_code_success) {
		return client_invalid_operation();
	}
	if (e.code() == error_code_not_committed || e.code() == error_code_commit_unknown_result ||
	    e.code() == error_code_database_locked || e.code() == error_code_proxy_memory_limit_exceeded ||
	    e.code() == error_code_process_behind || e.code() == error_code_batch_transaction_throttled ||
	    e.code() == error_code_tag_throttled) {
		if (e.code() == error_code_not_committed)
			++trState->cx->transactionsNotCommitted;
		else if (e.code() == error_code_commit_unknown_result)
			++trState->cx->transactionsMaybeCommitted;
		else if (e.code() == error_code_proxy_memory_limit_exceeded)
			++trState->cx->transactionsResourceConstrained;
		else if (e.code() == error_code_process_behind)
			++trState->cx->transactionsProcessBehind;
		else if (e.code() == error_code_batch_transaction_throttled || e.code() == error_code_tag_throttled) {
			++trState->cx->transactionsThrottled;
		}

		double backoff = getBackoff(e.code());
		reset();
		return delay(backoff, trState->taskID);
	}
	if (e.code() == error_code_transaction_too_old || e.code() == error_code_future_version) {
		if (e.code() == error_code_transaction_too_old)
			++trState->cx->transactionsTooOld;
		else if (e.code() == error_code_future_version)
			++trState->cx->transactionsFutureVersions;

		double maxBackoff = trState->options.maxBackoff;
		reset();
		return delay(std::min(CLIENT_KNOBS->FUTURE_VERSION_RETRY_DELAY, maxBackoff), trState->taskID);
	}
	if (e.code() == error_code_unknown_tenant) {
		double maxBackoff = trState->options.maxBackoff;
		reset();
		return delay(std::min(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, maxBackoff), trState->taskID);
	}

	return e;
}
															#line 32704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
[[nodiscard]] Future<StorageMetrics> getStorageMetricsLargeKeyRange( Database const& cx, KeyRange const& keys );

#line 7231 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 32709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via doGetStorageMetrics()
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class DoGetStorageMetricsActor>
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class DoGetStorageMetricsActorState {
															#line 32716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DoGetStorageMetricsActorState(Database const& cx,KeyRange const& keys,Reference<LocationInfo> const& locationInfo) 
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   locationInfo(locationInfo)
															#line 32727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("doGetStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	~DoGetStorageMetricsActorState() 
	{
		fdb_probe_actor_destroy("doGetStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 32742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DoGetStorageMetricsActorState();
		static_cast<DoGetStorageMetricsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 7235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			WaitMetricsRequest req(keys, StorageMetrics(), StorageMetrics());
															#line 7236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.min.bytes = 0;
															#line 7237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.max.bytes = -1;
															#line 7238 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<StorageMetrics> __when_expr_0 = loadBalance( locationInfo->locations(), &StorageServerInterface::waitMetrics, req, TaskPriority::DataDistribution);
															#line 7238 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 32781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state = 1;
															#line 7238 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >*>(static_cast<DoGetStorageMetricsActor*>(this)));
															#line 32786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_wrong_shard_server && e.code() != error_code_all_alternatives_failed)
															#line 32802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7243 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "WaitStorageMetricsError").error(e);
															#line 7244 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 32808 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, TaskPriority::DataDistribution);
															#line 7246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 32814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_1.get(), loopDepth); };
			static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state = 2;
															#line 7246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DoGetStorageMetricsActor, 1, Void >*>(static_cast<DoGetStorageMetricsActor*>(this)));
															#line 32819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(StorageMetrics const& m,int loopDepth) 
	{
															#line 7240 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<DoGetStorageMetricsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(m); this->~DoGetStorageMetricsActorState(); static_cast<DoGetStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 32834 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<DoGetStorageMetricsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(m);
		this->~DoGetStorageMetricsActorState();
		static_cast<DoGetStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(StorageMetrics && m,int loopDepth) 
	{
															#line 7240 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<DoGetStorageMetricsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(m); this->~DoGetStorageMetricsActorState(); static_cast<DoGetStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 32846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<DoGetStorageMetricsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(m);
		this->~DoGetStorageMetricsActorState();
		static_cast<DoGetStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(StorageMetrics const& m,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(m, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(StorageMetrics && m,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(m), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<DoGetStorageMetricsActor*>(this)->ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >::remove();

	}
	void a_callback_fire(ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >*,StorageMetrics const& value) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >*,StorageMetrics && value) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >*,Error err) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
															#line 7247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(Key(), keys);
															#line 7248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<StorageMetrics> __when_expr_2 = getStorageMetricsLargeKeyRange(cx, keys);
															#line 7248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 32925 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1cont1when1(__when_expr_2.get(), loopDepth); };
		static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state = 3;
															#line 7248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >*>(static_cast<DoGetStorageMetricsActor*>(this)));
															#line 32930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
															#line 7247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(Key(), keys);
															#line 7248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<StorageMetrics> __when_expr_2 = getStorageMetricsLargeKeyRange(cx, keys);
															#line 7248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 32943 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1cont1when1(__when_expr_2.get(), loopDepth); };
		static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state = 3;
															#line 7248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >*>(static_cast<DoGetStorageMetricsActor*>(this)));
															#line 32948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<DoGetStorageMetricsActor*>(this)->ActorCallback< DoGetStorageMetricsActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DoGetStorageMetricsActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DoGetStorageMetricsActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DoGetStorageMetricsActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1Catch1cont3(StorageMetrics const& m,int loopDepth) 
	{
															#line 7249 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<DoGetStorageMetricsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(m); this->~DoGetStorageMetricsActorState(); static_cast<DoGetStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 33020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<DoGetStorageMetricsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(m);
		this->~DoGetStorageMetricsActorState();
		static_cast<DoGetStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont3(StorageMetrics && m,int loopDepth) 
	{
															#line 7249 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<DoGetStorageMetricsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(m); this->~DoGetStorageMetricsActorState(); static_cast<DoGetStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 33032 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<DoGetStorageMetricsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(m);
		this->~DoGetStorageMetricsActorState();
		static_cast<DoGetStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1when1(StorageMetrics const& m,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont3(m, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1when1(StorageMetrics && m,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont3(std::move(m), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<DoGetStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<DoGetStorageMetricsActor*>(this)->ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >::remove();

	}
	void a_callback_fire(ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >*,StorageMetrics const& value) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >*,StorageMetrics && value) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >*,Error err) 
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<LocationInfo> locationInfo;
															#line 33109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via doGetStorageMetrics()
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class DoGetStorageMetricsActor final : public Actor<StorageMetrics>, public ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >, public ActorCallback< DoGetStorageMetricsActor, 1, Void >, public ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >, public FastAllocated<DoGetStorageMetricsActor>, public DoGetStorageMetricsActorState<DoGetStorageMetricsActor> {
															#line 33114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<DoGetStorageMetricsActor>::operator new;
	using FastAllocated<DoGetStorageMetricsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<StorageMetrics>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >;
friend struct ActorCallback< DoGetStorageMetricsActor, 1, Void >;
friend struct ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >;
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DoGetStorageMetricsActor(Database const& cx,KeyRange const& keys,Reference<LocationInfo> const& locationInfo) 
															#line 33127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<StorageMetrics>(),
		   DoGetStorageMetricsActorState<DoGetStorageMetricsActor>(cx, keys, locationInfo)
	{
		fdb_probe_actor_enter("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("doGetStorageMetrics");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("doGetStorageMetrics", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DoGetStorageMetricsActor, 0, StorageMetrics >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DoGetStorageMetricsActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< DoGetStorageMetricsActor, 2, StorageMetrics >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<StorageMetrics> doGetStorageMetrics( Database const& cx, KeyRange const& keys, Reference<LocationInfo> const& locationInfo ) {
															#line 7232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<StorageMetrics>(new DoGetStorageMetricsActor(cx, keys, locationInfo));
															#line 33157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 33162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getStorageMetricsLargeKeyRange()
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetStorageMetricsLargeKeyRangeActor>
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetStorageMetricsLargeKeyRangeActorState {
															#line 33169 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetStorageMetricsLargeKeyRangeActorState(Database const& cx,KeyRange const& keys) 
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 7255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:GetStorageMetricsLargeKeyRange"_loc)
															#line 33180 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this));

	}
	~GetStorageMetricsLargeKeyRangeActorState() 
	{
		fdb_probe_actor_destroy("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7256 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, std::numeric_limits<int>::max(), Reverse::False, &StorageServerInterface::waitMetrics, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 7256 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 33197 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state = 1;
															#line 7256 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)));
															#line 33202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetStorageMetricsLargeKeyRangeActorState();
		static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
															#line 7266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nLocs = locations.size();
															#line 7267 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		fx = std::vector<Future<StorageMetrics>>(nLocs);
															#line 7268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		total = StorageMetrics();
															#line 7269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRef partBegin, partEnd;
															#line 7270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			partBegin = (i == 0) ? keys.begin : locations[i].range.begin;
															#line 7272 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			partEnd = (i == nLocs - 1) ? keys.end : locations[i].range.end;
															#line 7273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fx[i] = doGetStorageMetrics(cx, KeyRangeRef(partBegin, partEnd), locations[i].locations);
															#line 33239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitForAll(fx);
															#line 7275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 33245 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state = 2;
															#line 7275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >*>(static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)));
															#line 33250 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
															#line 7266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nLocs = locations.size();
															#line 7267 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		fx = std::vector<Future<StorageMetrics>>(nLocs);
															#line 7268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		total = StorageMetrics();
															#line 7269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRef partBegin, partEnd;
															#line 7270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			partBegin = (i == 0) ? keys.begin : locations[i].range.begin;
															#line 7272 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			partEnd = (i == nLocs - 1) ? keys.end : locations[i].range.end;
															#line 7273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fx[i] = doGetStorageMetrics(cx, KeyRangeRef(partBegin, partEnd), locations[i].locations);
															#line 33273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitForAll(fx);
															#line 7275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 33279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state = 2;
															#line 7275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >*>(static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)));
															#line 33284 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
		loopDepth = a_body1cont1(locations, loopDepth);

		return loopDepth;
	}
	int a_body1when1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(locations), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state > 0) static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 7276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			total += fx[i].get();
															#line 33358 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~GetStorageMetricsLargeKeyRangeActorState(); static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->destroy(); return 0; }
															#line 33362 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
		this->~GetStorageMetricsLargeKeyRangeActorState();
		static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 7276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			total += fx[i].get();
															#line 33376 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~GetStorageMetricsLargeKeyRangeActorState(); static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->destroy(); return 0; }
															#line 33380 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
		this->~GetStorageMetricsLargeKeyRangeActorState();
		static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state > 0) static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetStorageMetricsLargeKeyRangeActor*>(this)->ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 7266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int nLocs;
															#line 7267 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<StorageMetrics>> fx;
															#line 7268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics total;
															#line 33463 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getStorageMetricsLargeKeyRange()
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetStorageMetricsLargeKeyRangeActor final : public Actor<StorageMetrics>, public ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >, public FastAllocated<GetStorageMetricsLargeKeyRangeActor>, public GetStorageMetricsLargeKeyRangeActorState<GetStorageMetricsLargeKeyRangeActor> {
															#line 33468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetStorageMetricsLargeKeyRangeActor>::operator new;
	using FastAllocated<GetStorageMetricsLargeKeyRangeActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<StorageMetrics>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >;
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetStorageMetricsLargeKeyRangeActor(Database const& cx,KeyRange const& keys) 
															#line 33480 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<StorageMetrics>(),
		   GetStorageMetricsLargeKeyRangeActorState<GetStorageMetricsLargeKeyRangeActor>(cx, keys)
	{
		fdb_probe_actor_enter("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getStorageMetricsLargeKeyRange");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getStorageMetricsLargeKeyRange", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetStorageMetricsLargeKeyRangeActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetStorageMetricsLargeKeyRangeActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<StorageMetrics> getStorageMetricsLargeKeyRange( Database const& cx, KeyRange const& keys ) {
															#line 7254 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<StorageMetrics>(new GetStorageMetricsLargeKeyRangeActor(cx, keys));
															#line 33509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 33514 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via trackBoundedStorageMetrics()
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class TrackBoundedStorageMetricsActor>
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TrackBoundedStorageMetricsActorState {
															#line 33521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TrackBoundedStorageMetricsActorState(KeyRange const& keys,Reference<LocationInfo> const& location,StorageMetrics const& x,StorageMetrics const& halfError,PromiseStream<StorageMetrics> const& deltaStream) 
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : keys(keys),
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   location(location),
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   x(x),
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   halfError(halfError),
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   deltaStream(deltaStream)
															#line 33536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	~TrackBoundedStorageMetricsActorState() 
	{
		fdb_probe_actor_destroy("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 7288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				;
															#line 33552 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~TrackBoundedStorageMetricsActorState();
		static_cast<TrackBoundedStorageMetricsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7295 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			deltaStream.sendError(e);
															#line 7296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 33584 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		WaitMetricsRequest req(keys, x - halfError, x + halfError);
															#line 7290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<StorageMetrics> __when_expr_0 = loadBalance(location->locations(), &StorageServerInterface::waitMetrics, req);
															#line 7290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<TrackBoundedStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 33609 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<TrackBoundedStorageMetricsActor*>(this)->actor_wait_state = 1;
															#line 7290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >*>(static_cast<TrackBoundedStorageMetricsActor*>(this)));
															#line 33614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(StorageMetrics const& nextX,int loopDepth) 
	{
															#line 7291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		deltaStream.send(nextX - x);
															#line 7292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		x = nextX;
															#line 33625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(StorageMetrics && nextX,int loopDepth) 
	{
															#line 7291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		deltaStream.send(nextX - x);
															#line 7292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		x = nextX;
															#line 33636 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(StorageMetrics const& nextX,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(nextX, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(StorageMetrics && nextX,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(nextX), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<TrackBoundedStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<TrackBoundedStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<TrackBoundedStorageMetricsActor*>(this)->ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >::remove();

	}
	void a_callback_fire(ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >*,StorageMetrics const& value) 
	{
		fdb_probe_actor_enter("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >*,StorageMetrics && value) 
	{
		fdb_probe_actor_enter("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >*,Error err) 
	{
		fdb_probe_actor_enter("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<LocationInfo> location;
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics x;
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics halfError;
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<StorageMetrics> deltaStream;
															#line 33714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via trackBoundedStorageMetrics()
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class TrackBoundedStorageMetricsActor final : public Actor<Void>, public ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >, public FastAllocated<TrackBoundedStorageMetricsActor>, public TrackBoundedStorageMetricsActorState<TrackBoundedStorageMetricsActor> {
															#line 33719 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<TrackBoundedStorageMetricsActor>::operator new;
	using FastAllocated<TrackBoundedStorageMetricsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >;
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	TrackBoundedStorageMetricsActor(KeyRange const& keys,Reference<LocationInfo> const& location,StorageMetrics const& x,StorageMetrics const& halfError,PromiseStream<StorageMetrics> const& deltaStream) 
															#line 33730 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   TrackBoundedStorageMetricsActorState<TrackBoundedStorageMetricsActor>(keys, location, x, halfError, deltaStream)
	{
		fdb_probe_actor_enter("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("trackBoundedStorageMetrics");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("trackBoundedStorageMetrics", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< TrackBoundedStorageMetricsActor, 0, StorageMetrics >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> trackBoundedStorageMetrics( KeyRange const& keys, Reference<LocationInfo> const& location, StorageMetrics const& x, StorageMetrics const& halfError, PromiseStream<StorageMetrics> const& deltaStream ) {
															#line 7282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new TrackBoundedStorageMetricsActor(keys, location, x, halfError, deltaStream));
															#line 33758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 33763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via waitStorageMetricsMultipleLocations()
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WaitStorageMetricsMultipleLocationsActor>
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitStorageMetricsMultipleLocationsActorState {
															#line 33770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitStorageMetricsMultipleLocationsActorState(std::vector<KeyRangeLocationInfo> const& locations,StorageMetrics const& min,StorageMetrics const& max,StorageMetrics const& permittedError) 
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : locations(locations),
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   min(min),
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   max(max),
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   permittedError(permittedError),
															#line 7304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   nLocs(locations.size()),
															#line 7305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   fx(nLocs),
															#line 7306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   total(),
															#line 7307 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   deltas(),
															#line 7308 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   wx(fx.size()),
															#line 7309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   halfErrorPerMachine(permittedError * (0.5 / nLocs)),
															#line 7310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   maxPlus(max + halfErrorPerMachine * (nLocs - 1)),
															#line 7311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   minMinus(min - halfErrorPerMachine * (nLocs - 1))
															#line 33799 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this));

	}
	~WaitStorageMetricsMultipleLocationsActorState() 
	{
		fdb_probe_actor_destroy("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < nLocs;i++) {
															#line 7314 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				WaitMetricsRequest req(locations[i].range, StorageMetrics(), StorageMetrics());
															#line 7315 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.min.bytes = 0;
															#line 7316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.max.bytes = -1;
															#line 7317 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fx[i] = loadBalance(locations[i].locations->locations(), &StorageServerInterface::waitMetrics, req, TaskPriority::DataDistribution);
															#line 33822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = waitForAll(fx);
															#line 7322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 33828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state = 1;
															#line 7322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >*>(static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)));
															#line 33833 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitStorageMetricsMultipleLocationsActorState();
		static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 7325 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7326 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			total += fx[i].get();
															#line 33858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!total.allLessOrEqual(maxPlus))
															#line 33862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 33866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7330 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!minMinus.allLessOrEqual(total))
															#line 33874 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 33878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			wx[i] = trackBoundedStorageMetrics( locations[i].range, locations[i].locations, fx[i].get(), halfErrorPerMachine, deltas);
															#line 33888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 33892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 7325 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7326 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			total += fx[i].get();
															#line 33903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!total.allLessOrEqual(maxPlus))
															#line 33907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 33911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7330 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!minMinus.allLessOrEqual(total))
															#line 33919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 33923 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			wx[i] = trackBoundedStorageMetrics( locations[i].range, locations[i].locations, fx[i].get(), halfErrorPerMachine, deltas);
															#line 33933 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 33937 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state > 0) static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state = 0;
		static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 7338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		FutureStream<StorageMetrics> __when_expr_1 = deltas.getFuture();
															#line 7338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 34018 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.pop(), loopDepth); };
		static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state = 2;
															#line 7338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >*>(static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)));
															#line 34023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(StorageMetrics const& delta,int loopDepth) 
	{
															#line 7339 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		total += delta;
															#line 7340 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!total.allLessOrEqual(maxPlus))
															#line 34034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 34038 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!minMinus.allLessOrEqual(total))
															#line 34046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7343 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 34050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(StorageMetrics && delta,int loopDepth) 
	{
															#line 7339 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		total += delta;
															#line 7340 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!total.allLessOrEqual(maxPlus))
															#line 34066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7341 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 34070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!minMinus.allLessOrEqual(total))
															#line 34078 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7343 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(total); this->~WaitStorageMetricsMultipleLocationsActorState(); static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->destroy(); return 0; }
															#line 34082 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(std::move(total)); // state_var_RVO
			this->~WaitStorageMetricsMultipleLocationsActorState();
			static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(StorageMetrics const& delta,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(delta, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(StorageMetrics && delta,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(std::move(delta), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state > 0) static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->actor_wait_state = 0;
		static_cast<WaitStorageMetricsMultipleLocationsActor*>(this)->ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >::remove();

	}
	void a_callback_fire(ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >*,StorageMetrics const& value) 
	{
		fdb_probe_actor_enter("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >*,StorageMetrics && value) 
	{
		fdb_probe_actor_enter("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >*,Error err) 
	{
		fdb_probe_actor_enter("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics min;
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics max;
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics permittedError;
															#line 7304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int nLocs;
															#line 7305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<StorageMetrics>> fx;
															#line 7306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics total;
															#line 7307 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<StorageMetrics> deltas;
															#line 7308 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<Void>> wx;
															#line 7309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics halfErrorPerMachine;
															#line 7310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics maxPlus;
															#line 7311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics minMinus;
															#line 34179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via waitStorageMetricsMultipleLocations()
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitStorageMetricsMultipleLocationsActor final : public Actor<StorageMetrics>, public ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >, public ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >, public FastAllocated<WaitStorageMetricsMultipleLocationsActor>, public WaitStorageMetricsMultipleLocationsActorState<WaitStorageMetricsMultipleLocationsActor> {
															#line 34184 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WaitStorageMetricsMultipleLocationsActor>::operator new;
	using FastAllocated<WaitStorageMetricsMultipleLocationsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<StorageMetrics>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >;
friend struct ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >;
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitStorageMetricsMultipleLocationsActor(std::vector<KeyRangeLocationInfo> const& locations,StorageMetrics const& min,StorageMetrics const& max,StorageMetrics const& permittedError) 
															#line 34196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<StorageMetrics>(),
		   WaitStorageMetricsMultipleLocationsActorState<WaitStorageMetricsMultipleLocationsActor>(locations, min, max, permittedError)
	{
		fdb_probe_actor_enter("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitStorageMetricsMultipleLocations");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitStorageMetricsMultipleLocations", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitStorageMetricsMultipleLocationsActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorSingleCallback< WaitStorageMetricsMultipleLocationsActor, 1, StorageMetrics >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<StorageMetrics> waitStorageMetricsMultipleLocations( std::vector<KeyRangeLocationInfo> const& locations, StorageMetrics const& min, StorageMetrics const& max, StorageMetrics const& permittedError ) {
															#line 7300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<StorageMetrics>(new WaitStorageMetricsMultipleLocationsActor(locations, min, max, permittedError));
															#line 34225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7346 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 34230 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via extractMetrics()
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ExtractMetricsActor>
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ExtractMetricsActorState {
															#line 34237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ExtractMetricsActorState(Future<std::pair<Optional<StorageMetrics>, int>> const& fMetrics) 
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : fMetrics(fMetrics)
															#line 34244 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("extractMetrics", reinterpret_cast<unsigned long>(this));

	}
	~ExtractMetricsActorState() 
	{
		fdb_probe_actor_destroy("extractMetrics", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<std::pair<Optional<StorageMetrics>, int>> __when_expr_0 = fMetrics;
															#line 7348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ExtractMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 34261 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<ExtractMetricsActor*>(this)->actor_wait_state = 1;
															#line 7348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >*>(static_cast<ExtractMetricsActor*>(this)));
															#line 34266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ExtractMetricsActorState();
		static_cast<ExtractMetricsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(std::pair<Optional<StorageMetrics>, int> const& x,int loopDepth) 
	{
															#line 7349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ExtractMetricsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(x.first.get()); this->~ExtractMetricsActorState(); static_cast<ExtractMetricsActor*>(this)->destroy(); return 0; }
															#line 34289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ExtractMetricsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(x.first.get());
		this->~ExtractMetricsActorState();
		static_cast<ExtractMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(std::pair<Optional<StorageMetrics>, int> && x,int loopDepth) 
	{
															#line 7349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ExtractMetricsActor*>(this)->SAV<StorageMetrics>::futures) { (void)(x.first.get()); this->~ExtractMetricsActorState(); static_cast<ExtractMetricsActor*>(this)->destroy(); return 0; }
															#line 34301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ExtractMetricsActor*>(this)->SAV< StorageMetrics >::value()) StorageMetrics(x.first.get());
		this->~ExtractMetricsActorState();
		static_cast<ExtractMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(std::pair<Optional<StorageMetrics>, int> const& x,int loopDepth) 
	{
		loopDepth = a_body1cont1(x, loopDepth);

		return loopDepth;
	}
	int a_body1when1(std::pair<Optional<StorageMetrics>, int> && x,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(x), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ExtractMetricsActor*>(this)->actor_wait_state > 0) static_cast<ExtractMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<ExtractMetricsActor*>(this)->ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >::remove();

	}
	void a_callback_fire(ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >*,std::pair<Optional<StorageMetrics>, int> const& value) 
	{
		fdb_probe_actor_enter("extractMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("extractMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >*,std::pair<Optional<StorageMetrics>, int> && value) 
	{
		fdb_probe_actor_enter("extractMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("extractMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >*,Error err) 
	{
		fdb_probe_actor_enter("extractMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("extractMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<std::pair<Optional<StorageMetrics>, int>> fMetrics;
															#line 34374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via extractMetrics()
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ExtractMetricsActor final : public Actor<StorageMetrics>, public ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >, public FastAllocated<ExtractMetricsActor>, public ExtractMetricsActorState<ExtractMetricsActor> {
															#line 34379 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ExtractMetricsActor>::operator new;
	using FastAllocated<ExtractMetricsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<StorageMetrics>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >;
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ExtractMetricsActor(Future<std::pair<Optional<StorageMetrics>, int>> const& fMetrics) 
															#line 34390 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<StorageMetrics>(),
		   ExtractMetricsActorState<ExtractMetricsActor>(fMetrics)
	{
		fdb_probe_actor_enter("extractMetrics", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("extractMetrics");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("extractMetrics", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ExtractMetricsActor, 0, std::pair<Optional<StorageMetrics>, int> >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<StorageMetrics> extractMetrics( Future<std::pair<Optional<StorageMetrics>, int>> const& fMetrics ) {
															#line 7347 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<StorageMetrics>(new ExtractMetricsActor(fMetrics));
															#line 34418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 34423 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getReadHotRanges()
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetReadHotRangesActor>
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetReadHotRangesActorState {
															#line 34430 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetReadHotRangesActorState(Database const& cx,KeyRange const& keys) 
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 7353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:GetReadHotRanges"_loc)
															#line 34441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getReadHotRanges", reinterpret_cast<unsigned long>(this));

	}
	~GetReadHotRangesActorState() 
	{
		fdb_probe_actor_destroy("getReadHotRanges", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 34456 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetReadHotRangesActorState();
		static_cast<GetReadHotRangesActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7355 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int64_t shardLimit = 100;
															#line 7357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, shardLimit, Reverse::False, &StorageServerInterface::getReadHotRanges, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 7357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetReadHotRangesActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 34490 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<GetReadHotRangesActor*>(this)->actor_wait_state = 1;
															#line 7357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetReadHotRangesActor*>(this)));
															#line 34495 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
		try {
															#line 7373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			nLocs = locations.size();
															#line 7380 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fReplies = std::vector<Future<ReadHotSubRangeReply>>(nLocs);
															#line 7381 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			KeyRef partBegin, partEnd;
															#line 7382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < nLocs;i++) {
															#line 7383 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				partBegin = (i == 0) ? keys.begin : locations[i].range.begin;
															#line 7384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				partEnd = (i == nLocs - 1) ? keys.end : locations[i].range.end;
															#line 7385 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ReadHotSubRangeRequest req(KeyRangeRef(partBegin, partEnd));
															#line 7386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fReplies[i] = loadBalance(locations[i].locations->locations(), &StorageServerInterface::getReadHotRanges, req, TaskPriority::DataDistribution);
															#line 34519 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = waitForAll(fReplies);
															#line 7392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetReadHotRangesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 34525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<GetReadHotRangesActor*>(this)->actor_wait_state = 2;
															#line 7392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetReadHotRangesActor, 1, Void >*>(static_cast<GetReadHotRangesActor*>(this)));
															#line 34530 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
		try {
															#line 7373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			nLocs = locations.size();
															#line 7380 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fReplies = std::vector<Future<ReadHotSubRangeReply>>(nLocs);
															#line 7381 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			KeyRef partBegin, partEnd;
															#line 7382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < nLocs;i++) {
															#line 7383 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				partBegin = (i == 0) ? keys.begin : locations[i].range.begin;
															#line 7384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				partEnd = (i == nLocs - 1) ? keys.end : locations[i].range.end;
															#line 7385 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ReadHotSubRangeRequest req(KeyRangeRef(partBegin, partEnd));
															#line 7386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fReplies[i] = loadBalance(locations[i].locations->locations(), &StorageServerInterface::getReadHotRanges, req, TaskPriority::DataDistribution);
															#line 34560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = waitForAll(fReplies);
															#line 7392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetReadHotRangesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 34566 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<GetReadHotRangesActor*>(this)->actor_wait_state = 2;
															#line 7392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetReadHotRangesActor, 1, Void >*>(static_cast<GetReadHotRangesActor*>(this)));
															#line 34571 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(locations, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(locations), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetReadHotRangesActor*>(this)->actor_wait_state > 0) static_cast<GetReadHotRangesActor*>(this)->actor_wait_state = 0;
		static_cast<GetReadHotRangesActor*>(this)->ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_wrong_shard_server && e.code() != error_code_all_alternatives_failed)
															#line 34656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7411 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "GetReadHotSubRangesError").error(e);
															#line 7412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 34662 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7414 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->invalidateCache(Key(), keys);
															#line 7415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, TaskPriority::DataDistribution);
															#line 7415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetReadHotRangesActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 34670 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<GetReadHotRangesActor*>(this)->actor_wait_state = 3;
															#line 7415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetReadHotRangesActor, 2, Void >*>(static_cast<GetReadHotRangesActor*>(this)));
															#line 34675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 7394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nLocs == 1)
															#line 34690 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 7396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetReadHotRangesActor*>(this)->SAV<Standalone<VectorRef<ReadHotRangeWithMetrics>>>::futures) { (void)(fReplies[0].get().readHotRanges); this->~GetReadHotRangesActorState(); static_cast<GetReadHotRangesActor*>(this)->destroy(); return 0; }
															#line 34696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetReadHotRangesActor*>(this)->SAV< Standalone<VectorRef<ReadHotRangeWithMetrics>> >::value()) Standalone<VectorRef<ReadHotRangeWithMetrics>>(fReplies[0].get().readHotRanges);
			this->~GetReadHotRangesActorState();
			static_cast<GetReadHotRangesActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 7398 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 7399 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Standalone<VectorRef<ReadHotRangeWithMetrics>> results;
															#line 7400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < nLocs;i++) {
															#line 7401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.append(results.arena(), fReplies[i].get().readHotRanges.begin(), fReplies[i].get().readHotRanges.size());
															#line 7404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.arena().dependsOn(fReplies[i].get().readHotRanges.arena());
															#line 34714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetReadHotRangesActor*>(this)->SAV<Standalone<VectorRef<ReadHotRangeWithMetrics>>>::futures) { (void)(results); this->~GetReadHotRangesActorState(); static_cast<GetReadHotRangesActor*>(this)->destroy(); return 0; }
															#line 34718 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetReadHotRangesActor*>(this)->SAV< Standalone<VectorRef<ReadHotRangeWithMetrics>> >::value()) Standalone<VectorRef<ReadHotRangeWithMetrics>>(results);
			this->~GetReadHotRangesActorState();
			static_cast<GetReadHotRangesActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 7394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nLocs == 1)
															#line 34731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 7396 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetReadHotRangesActor*>(this)->SAV<Standalone<VectorRef<ReadHotRangeWithMetrics>>>::futures) { (void)(fReplies[0].get().readHotRanges); this->~GetReadHotRangesActorState(); static_cast<GetReadHotRangesActor*>(this)->destroy(); return 0; }
															#line 34737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetReadHotRangesActor*>(this)->SAV< Standalone<VectorRef<ReadHotRangeWithMetrics>> >::value()) Standalone<VectorRef<ReadHotRangeWithMetrics>>(fReplies[0].get().readHotRanges);
			this->~GetReadHotRangesActorState();
			static_cast<GetReadHotRangesActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		else
		{
															#line 7398 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 7399 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Standalone<VectorRef<ReadHotRangeWithMetrics>> results;
															#line 7400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < nLocs;i++) {
															#line 7401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.append(results.arena(), fReplies[i].get().readHotRanges.begin(), fReplies[i].get().readHotRanges.size());
															#line 7404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.arena().dependsOn(fReplies[i].get().readHotRanges.arena());
															#line 34755 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetReadHotRangesActor*>(this)->SAV<Standalone<VectorRef<ReadHotRangeWithMetrics>>>::futures) { (void)(results); this->~GetReadHotRangesActorState(); static_cast<GetReadHotRangesActor*>(this)->destroy(); return 0; }
															#line 34759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetReadHotRangesActor*>(this)->SAV< Standalone<VectorRef<ReadHotRangeWithMetrics>> >::value()) Standalone<VectorRef<ReadHotRangeWithMetrics>>(results);
			this->~GetReadHotRangesActorState();
			static_cast<GetReadHotRangesActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetReadHotRangesActor*>(this)->actor_wait_state > 0) static_cast<GetReadHotRangesActor*>(this)->actor_wait_state = 0;
		static_cast<GetReadHotRangesActor*>(this)->ActorCallback< GetReadHotRangesActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetReadHotRangesActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetReadHotRangesActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetReadHotRangesActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetReadHotRangesActor*>(this)->actor_wait_state > 0) static_cast<GetReadHotRangesActor*>(this)->actor_wait_state = 0;
		static_cast<GetReadHotRangesActor*>(this)->ActorCallback< GetReadHotRangesActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetReadHotRangesActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetReadHotRangesActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetReadHotRangesActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 7373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int nLocs;
															#line 7380 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<ReadHotSubRangeReply>> fReplies;
															#line 34916 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getReadHotRanges()
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetReadHotRangesActor final : public Actor<Standalone<VectorRef<ReadHotRangeWithMetrics>>>, public ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetReadHotRangesActor, 1, Void >, public ActorCallback< GetReadHotRangesActor, 2, Void >, public FastAllocated<GetReadHotRangesActor>, public GetReadHotRangesActorState<GetReadHotRangesActor> {
															#line 34921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetReadHotRangesActor>::operator new;
	using FastAllocated<GetReadHotRangesActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<ReadHotRangeWithMetrics>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetReadHotRangesActor, 1, Void >;
friend struct ActorCallback< GetReadHotRangesActor, 2, Void >;
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetReadHotRangesActor(Database const& cx,KeyRange const& keys) 
															#line 34934 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Standalone<VectorRef<ReadHotRangeWithMetrics>>>(),
		   GetReadHotRangesActorState<GetReadHotRangesActor>(cx, keys)
	{
		fdb_probe_actor_enter("getReadHotRanges", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getReadHotRanges");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getReadHotRanges", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetReadHotRangesActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetReadHotRangesActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetReadHotRangesActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Standalone<VectorRef<ReadHotRangeWithMetrics>>> getReadHotRanges( Database const& cx, KeyRange const& keys ) {
															#line 7352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Standalone<VectorRef<ReadHotRangeWithMetrics>>>(new GetReadHotRangesActor(cx, keys));
															#line 34964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7419 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 34969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via waitStorageMetrics()
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WaitStorageMetricsActor>
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitStorageMetricsActorState {
															#line 34976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitStorageMetricsActorState(Database const& cx,KeyRange const& keys,StorageMetrics const& min,StorageMetrics const& max,StorageMetrics const& permittedError,int const& shardLimit,int const& expectedShardCount) 
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   min(min),
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   max(max),
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   permittedError(permittedError),
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   shardLimit(shardLimit),
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   expectedShardCount(expectedShardCount),
															#line 7427 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:WaitStorageMetrics"_loc, generateSpanID(cx->transactionTracingSample))
															#line 34997 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("waitStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	~WaitStorageMetricsActorState() 
	{
		fdb_probe_actor_destroy("waitStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 35012 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitStorageMetricsActorState();
		static_cast<WaitStorageMetricsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, shardLimit, Reverse::False, &StorageServerInterface::waitMetrics, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 7429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 35044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 1;
															#line 7429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<WaitStorageMetricsActor*>(this)));
															#line 35049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
															#line 7439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (expectedShardCount >= 0 && locations.size() != expectedShardCount)
															#line 35058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7440 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsActor*>(this)->SAV<std::pair<Optional<StorageMetrics>, int>>::futures) { (void)(std::make_pair(Optional<StorageMetrics>(), locations.size())); this->~WaitStorageMetricsActorState(); static_cast<WaitStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 35062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsActor*>(this)->SAV< std::pair<Optional<StorageMetrics>, int> >::value()) std::pair<Optional<StorageMetrics>, int>(std::make_pair(Optional<StorageMetrics>(), locations.size()));
			this->~WaitStorageMetricsActorState();
			static_cast<WaitStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() < shardLimit)
															#line 35070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			try {
															#line 7447 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				Future<StorageMetrics> fx;
															#line 7448 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (locations.size() > 1)
															#line 35077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 7449 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fx = waitStorageMetricsMultipleLocations(locations, min, max, permittedError);
															#line 35081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 7451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					WaitMetricsRequest req(keys, min, max);
															#line 7452 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fx = loadBalance(locations[0].locations->locations(), &StorageServerInterface::waitMetrics, req, TaskPriority::DataDistribution);
															#line 35089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 7457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<StorageMetrics> __when_expr_1 = fx;
															#line 7457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 35095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
				static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 2;
															#line 7457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >*>(static_cast<WaitStorageMetricsActor*>(this)));
															#line 35100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
															#line 7468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarn, "WaitStorageMetricsPenalty") .detail("Keys", keys) .detail("Limit", CLIENT_KNOBS->STORAGE_METRICS_SHARD_LIMIT) .detail("JitteredSecondsOfPenitence", CLIENT_KNOBS->STORAGE_METRICS_TOO_MANY_SHARDS_DELAY);
															#line 7472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = delayJittered(CLIENT_KNOBS->STORAGE_METRICS_TOO_MANY_SHARDS_DELAY, TaskPriority::DataDistribution);
															#line 7472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 35117 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when2(__when_expr_3.get(), loopDepth); };
			static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 4;
															#line 7472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitStorageMetricsActor, 3, Void >*>(static_cast<WaitStorageMetricsActor*>(this)));
															#line 35122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
															#line 7439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (expectedShardCount >= 0 && locations.size() != expectedShardCount)
															#line 35132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7440 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitStorageMetricsActor*>(this)->SAV<std::pair<Optional<StorageMetrics>, int>>::futures) { (void)(std::make_pair(Optional<StorageMetrics>(), locations.size())); this->~WaitStorageMetricsActorState(); static_cast<WaitStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 35136 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitStorageMetricsActor*>(this)->SAV< std::pair<Optional<StorageMetrics>, int> >::value()) std::pair<Optional<StorageMetrics>, int>(std::make_pair(Optional<StorageMetrics>(), locations.size()));
			this->~WaitStorageMetricsActorState();
			static_cast<WaitStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 7445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() < shardLimit)
															#line 35144 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			try {
															#line 7447 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				Future<StorageMetrics> fx;
															#line 7448 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (locations.size() > 1)
															#line 35151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 7449 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fx = waitStorageMetricsMultipleLocations(locations, min, max, permittedError);
															#line 35155 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 7451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					WaitMetricsRequest req(keys, min, max);
															#line 7452 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fx = loadBalance(locations[0].locations->locations(), &StorageServerInterface::waitMetrics, req, TaskPriority::DataDistribution);
															#line 35163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 7457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<StorageMetrics> __when_expr_1 = fx;
															#line 7457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 35169 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
				static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 2;
															#line 7457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >*>(static_cast<WaitStorageMetricsActor*>(this)));
															#line 35174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
															#line 7468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarn, "WaitStorageMetricsPenalty") .detail("Keys", keys) .detail("Limit", CLIENT_KNOBS->STORAGE_METRICS_SHARD_LIMIT) .detail("JitteredSecondsOfPenitence", CLIENT_KNOBS->STORAGE_METRICS_TOO_MANY_SHARDS_DELAY);
															#line 7472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = delayJittered(CLIENT_KNOBS->STORAGE_METRICS_TOO_MANY_SHARDS_DELAY, TaskPriority::DataDistribution);
															#line 7472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 35191 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when2(__when_expr_3.get(), loopDepth); };
			static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 4;
															#line 7472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitStorageMetricsActor, 3, Void >*>(static_cast<WaitStorageMetricsActor*>(this)));
															#line 35196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& locations,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(locations, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && locations,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(locations), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<WaitStorageMetricsActor*>(this)->ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_wrong_shard_server && e.code() != error_code_all_alternatives_failed)
															#line 35282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "WaitStorageMetricsError").error(e);
															#line 7462 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 35288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->invalidateCache(Key(), keys);
															#line 7465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, TaskPriority::DataDistribution);
															#line 7465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 35296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 3;
															#line 7465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitStorageMetricsActor, 2, Void >*>(static_cast<WaitStorageMetricsActor*>(this)));
															#line 35301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont5(StorageMetrics const& x,int loopDepth) 
	{
															#line 7458 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WaitStorageMetricsActor*>(this)->SAV<std::pair<Optional<StorageMetrics>, int>>::futures) { (void)(std::make_pair(x, -1)); this->~WaitStorageMetricsActorState(); static_cast<WaitStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 35316 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WaitStorageMetricsActor*>(this)->SAV< std::pair<Optional<StorageMetrics>, int> >::value()) std::pair<Optional<StorageMetrics>, int>(std::make_pair(x, -1));
		this->~WaitStorageMetricsActorState();
		static_cast<WaitStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont5(StorageMetrics && x,int loopDepth) 
	{
															#line 7458 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WaitStorageMetricsActor*>(this)->SAV<std::pair<Optional<StorageMetrics>, int>>::futures) { (void)(std::make_pair(x, -1)); this->~WaitStorageMetricsActorState(); static_cast<WaitStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 35328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WaitStorageMetricsActor*>(this)->SAV< std::pair<Optional<StorageMetrics>, int> >::value()) std::pair<Optional<StorageMetrics>, int>(std::make_pair(x, -1));
		this->~WaitStorageMetricsActorState();
		static_cast<WaitStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(StorageMetrics const& x,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(x, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(StorageMetrics && x,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(std::move(x), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<WaitStorageMetricsActor*>(this)->ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >::remove();

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >*,StorageMetrics const& value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >*,StorageMetrics && value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >*,Error err) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<WaitStorageMetricsActor*>(this)->ActorCallback< WaitStorageMetricsActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WaitStorageMetricsActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont9(Void const& _,int loopDepth) 
	{
															#line 7474 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(Key(), keys);
															#line 35478 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont9(Void && _,int loopDepth) 
	{
															#line 7474 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(Key(), keys);
															#line 35487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<WaitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<WaitStorageMetricsActor*>(this)->ActorCallback< WaitStorageMetricsActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WaitStorageMetricsActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WaitStorageMetricsActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics min;
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics max;
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics permittedError;
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int shardLimit;
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int expectedShardCount;
															#line 7427 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 35571 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via waitStorageMetrics()
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitStorageMetricsActor final : public Actor<std::pair<Optional<StorageMetrics>, int>>, public ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >, public ActorCallback< WaitStorageMetricsActor, 2, Void >, public ActorCallback< WaitStorageMetricsActor, 3, Void >, public FastAllocated<WaitStorageMetricsActor>, public WaitStorageMetricsActorState<WaitStorageMetricsActor> {
															#line 35576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WaitStorageMetricsActor>::operator new;
	using FastAllocated<WaitStorageMetricsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<std::pair<Optional<StorageMetrics>, int>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >;
friend struct ActorCallback< WaitStorageMetricsActor, 2, Void >;
friend struct ActorCallback< WaitStorageMetricsActor, 3, Void >;
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitStorageMetricsActor(Database const& cx,KeyRange const& keys,StorageMetrics const& min,StorageMetrics const& max,StorageMetrics const& permittedError,int const& shardLimit,int const& expectedShardCount) 
															#line 35590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<std::pair<Optional<StorageMetrics>, int>>(),
		   WaitStorageMetricsActorState<WaitStorageMetricsActor>(cx, keys, min, max, permittedError, shardLimit, expectedShardCount)
	{
		fdb_probe_actor_enter("waitStorageMetrics", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitStorageMetrics");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitStorageMetrics", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WaitStorageMetricsActor, 1, StorageMetrics >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WaitStorageMetricsActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< WaitStorageMetricsActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<std::pair<Optional<StorageMetrics>, int>> waitStorageMetrics( Database const& cx, KeyRange const& keys, StorageMetrics const& min, StorageMetrics const& max, StorageMetrics const& permittedError, int const& shardLimit, int const& expectedShardCount ) {
															#line 7420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<std::pair<Optional<StorageMetrics>, int>>(new WaitStorageMetricsActor(cx, keys, min, max, permittedError, shardLimit, expectedShardCount));
															#line 35621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7478 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<std::pair<Optional<StorageMetrics>, int>> DatabaseContext::waitStorageMetrics(
    KeyRange const& keys,
    StorageMetrics const& min,
    StorageMetrics const& max,
    StorageMetrics const& permittedError,
    int shardLimit,
    int expectedShardCount) {
	return ::waitStorageMetrics(Database(Reference<DatabaseContext>::addRef(this)),
	                            keys,
	                            min,
	                            max,
	                            permittedError,
	                            shardLimit,
	                            expectedShardCount);
}

Future<StorageMetrics> DatabaseContext::getStorageMetrics(KeyRange const& keys, int shardLimit) {
	if (shardLimit > 0) {
		StorageMetrics m;
		m.bytes = -1;
		return extractMetrics(::waitStorageMetrics(Database(Reference<DatabaseContext>::addRef(this)),
		                                           keys,
		                                           StorageMetrics(),
		                                           m,
		                                           StorageMetrics(),
		                                           shardLimit,
		                                           -1));
	} else {
		return ::getStorageMetricsLargeKeyRange(Database(Reference<DatabaseContext>::addRef(this)), keys);
	}
}

															#line 35658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via waitDataDistributionMetricsList()
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WaitDataDistributionMetricsListActor>
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitDataDistributionMetricsListActorState {
															#line 35665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitDataDistributionMetricsListActorState(Database const& cx,KeyRange const& keys,int const& shardLimit) 
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   shardLimit(shardLimit)
															#line 35676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this));

	}
	~WaitDataDistributionMetricsListActorState() 
	{
		fdb_probe_actor_destroy("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7514 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 35691 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitDataDistributionMetricsListActorState();
		static_cast<WaitDataDistributionMetricsListActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7516 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = cx->onProxiesChanged();
															#line 7515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitDataDistributionMetricsListActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 35723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 7517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<ErrorOr<GetDDMetricsReply>> __when_expr_1 = errorOr(basicLoadBalance(cx->getCommitProxies(UseProvisionalProxies::False), &CommitProxyInterface::getDDMetrics, GetDDMetricsRequest(keys, shardLimit)));
															#line 35727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
		static_cast<WaitDataDistributionMetricsListActor*>(this)->actor_wait_state = 1;
															#line 7516 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >*>(static_cast<WaitDataDistributionMetricsListActor*>(this)));
															#line 7517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitDataDistributionMetricsListActor, 1, ErrorOr<GetDDMetricsReply> >*>(static_cast<WaitDataDistributionMetricsListActor*>(this)));
															#line 35734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(ErrorOr<GetDDMetricsReply> const& rep,int loopDepth) 
	{
															#line 7521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.isError())
															#line 35761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(rep.getError(), std::max(0, loopDepth - 1));
															#line 35765 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7524 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WaitDataDistributionMetricsListActor*>(this)->SAV<Standalone<VectorRef<DDMetricsRef>>>::futures) { (void)(rep.get().storageMetricsList); this->~WaitDataDistributionMetricsListActorState(); static_cast<WaitDataDistributionMetricsListActor*>(this)->destroy(); return 0; }
															#line 35769 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WaitDataDistributionMetricsListActor*>(this)->SAV< Standalone<VectorRef<DDMetricsRef>> >::value()) Standalone<VectorRef<DDMetricsRef>>(rep.get().storageMetricsList);
		this->~WaitDataDistributionMetricsListActorState();
		static_cast<WaitDataDistributionMetricsListActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when2(ErrorOr<GetDDMetricsReply> && rep,int loopDepth) 
	{
															#line 7521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.isError())
															#line 35781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(rep.getError(), std::max(0, loopDepth - 1));
															#line 35785 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7524 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<WaitDataDistributionMetricsListActor*>(this)->SAV<Standalone<VectorRef<DDMetricsRef>>>::futures) { (void)(rep.get().storageMetricsList); this->~WaitDataDistributionMetricsListActorState(); static_cast<WaitDataDistributionMetricsListActor*>(this)->destroy(); return 0; }
															#line 35789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<WaitDataDistributionMetricsListActor*>(this)->SAV< Standalone<VectorRef<DDMetricsRef>> >::value()) Standalone<VectorRef<DDMetricsRef>>(rep.get().storageMetricsList);
		this->~WaitDataDistributionMetricsListActorState();
		static_cast<WaitDataDistributionMetricsListActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitDataDistributionMetricsListActor*>(this)->actor_wait_state > 0) static_cast<WaitDataDistributionMetricsListActor*>(this)->actor_wait_state = 0;
		static_cast<WaitDataDistributionMetricsListActor*>(this)->ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >::remove();
		static_cast<WaitDataDistributionMetricsListActor*>(this)->ActorCallback< WaitDataDistributionMetricsListActor, 1, ErrorOr<GetDDMetricsReply> >::remove();

	}
	void a_callback_fire(ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitDataDistributionMetricsListActor, 1, ErrorOr<GetDDMetricsReply> >*,ErrorOr<GetDDMetricsReply> const& value) 
	{
		fdb_probe_actor_enter("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitDataDistributionMetricsListActor, 1, ErrorOr<GetDDMetricsReply> >*,ErrorOr<GetDDMetricsReply> && value) 
	{
		fdb_probe_actor_enter("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitDataDistributionMetricsListActor, 1, ErrorOr<GetDDMetricsReply> >*,Error err) 
	{
		fdb_probe_actor_enter("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int shardLimit;
															#line 35900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via waitDataDistributionMetricsList()
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitDataDistributionMetricsListActor final : public Actor<Standalone<VectorRef<DDMetricsRef>>>, public ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >, public ActorCallback< WaitDataDistributionMetricsListActor, 1, ErrorOr<GetDDMetricsReply> >, public FastAllocated<WaitDataDistributionMetricsListActor>, public WaitDataDistributionMetricsListActorState<WaitDataDistributionMetricsListActor> {
															#line 35905 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WaitDataDistributionMetricsListActor>::operator new;
	using FastAllocated<WaitDataDistributionMetricsListActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<DDMetricsRef>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >;
friend struct ActorCallback< WaitDataDistributionMetricsListActor, 1, ErrorOr<GetDDMetricsReply> >;
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitDataDistributionMetricsListActor(Database const& cx,KeyRange const& keys,int const& shardLimit) 
															#line 35917 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Standalone<VectorRef<DDMetricsRef>>>(),
		   WaitDataDistributionMetricsListActorState<WaitDataDistributionMetricsListActor>(cx, keys, shardLimit)
	{
		fdb_probe_actor_enter("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitDataDistributionMetricsList");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitDataDistributionMetricsList", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitDataDistributionMetricsListActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Standalone<VectorRef<DDMetricsRef>>> waitDataDistributionMetricsList( Database const& cx, KeyRange const& keys, int const& shardLimit ) {
															#line 7511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Standalone<VectorRef<DDMetricsRef>>>(new WaitDataDistributionMetricsListActor(cx, keys, shardLimit));
															#line 35945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7529 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Standalone<VectorRef<ReadHotRangeWithMetrics>>> DatabaseContext::getReadHotRanges(KeyRange const& keys) {
	return ::getReadHotRanges(Database(Reference<DatabaseContext>::addRef(this)), keys);
}

															#line 35954 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getRangeSplitPoints()
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetRangeSplitPointsActor>
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeSplitPointsActorState {
															#line 35961 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeSplitPointsActorState(Reference<TransactionState> const& trState,KeyRange const& keys,int64_t const& chunkSize,Version const& version) 
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : trState(trState),
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   chunkSize(chunkSize),
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 7538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:GetRangeSplitPoints"_loc, trState->spanID)
															#line 35976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getRangeSplitPoints", reinterpret_cast<unsigned long>(this));

	}
	~GetRangeSplitPointsActorState() 
	{
		fdb_probe_actor_destroy("getRangeSplitPoints", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 35991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetRangeSplitPointsActorState();
		static_cast<GetRangeSplitPointsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(trState, keys, CLIENT_KNOBS->TOO_MANY, Reverse::False, &StorageServerInterface::getRangeSplitPoints, UseTenant::True, version);
															#line 7541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 36023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 1;
															#line 7541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetRangeSplitPointsActor*>(this)));
															#line 36028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		try {
															#line 7550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			nLocs = locations.size();
															#line 7551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fReplies = std::vector<Future<SplitRangeReply>>(nLocs);
															#line 7552 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			KeyRef partBegin, partEnd;
															#line 7553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < nLocs;i++) {
															#line 7554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				partBegin = (i == 0) ? keys.begin : locations[i].range.begin;
															#line 7555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				partEnd = (i == nLocs - 1) ? keys.end : locations[i].range.end;
															#line 7556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				SplitRangeRequest req(trState->getTenantInfo(), KeyRangeRef(partBegin, partEnd), chunkSize);
															#line 7557 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fReplies[i] = loadBalance(locations[i].locations->locations(), &StorageServerInterface::getRangeSplitPoints, req, TaskPriority::DataDistribution);
															#line 36052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = waitForAll(fReplies);
															#line 7563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), loopDepth);
															#line 36058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 2;
															#line 7563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetRangeSplitPointsActor, 1, Void >*>(static_cast<GetRangeSplitPointsActor*>(this)));
															#line 36063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 7541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 36078 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state > 0) static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeSplitPointsActor*>(this)->ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7584 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed)
															#line 36152 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				trState->cx->invalidateCache(locations[0].tenantEntry.prefix, keys);
															#line 7586 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, TaskPriority::DataDistribution);
															#line 7586 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 36160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_2.get(), loopDepth); };
				static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 3;
															#line 7586 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetRangeSplitPointsActor, 2, Void >*>(static_cast<GetRangeSplitPointsActor*>(this)));
															#line 36165 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 7587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_unknown_tenant)
															#line 36172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 7588 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					ASSERT(trState->tenant().present());
															#line 7589 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					trState->cx->invalidateCachedTenant(trState->tenant().get());
															#line 7590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_3 = delay(CLIENT_KNOBS->UNKNOWN_TENANT_RETRY_DELAY, trState->taskID);
															#line 7590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 36182 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when2(__when_expr_3.get(), loopDepth); };
					static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 4;
															#line 7590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetRangeSplitPointsActor, 3, Void >*>(static_cast<GetRangeSplitPointsActor*>(this)));
															#line 36187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 7592 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TraceEvent(SevError, "GetRangeSplitPoints").error(e);
															#line 7593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 36196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 7564 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Standalone<VectorRef<KeyRef>> results;
															#line 7566 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.push_back_deep(results.arena(), keys.begin);
															#line 7567 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (i > 0)
															#line 36218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.push_back_deep(results.arena(), locations[i].range.begin);
															#line 36222 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7572 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (fReplies[i].get().splitPoints.size() > 0)
															#line 36226 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7573 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.append( results.arena(), fReplies[i].get().splitPoints.begin(), fReplies[i].get().splitPoints.size());
															#line 7575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.arena().dependsOn(fReplies[i].get().splitPoints.arena());
															#line 36232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 7578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (results.back() != keys.end)
															#line 36237 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7579 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.push_back_deep(results.arena(), keys.end);
															#line 36241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeSplitPointsActor*>(this)->SAV<Standalone<VectorRef<KeyRef>>>::futures) { (void)(results); this->~GetRangeSplitPointsActorState(); static_cast<GetRangeSplitPointsActor*>(this)->destroy(); return 0; }
															#line 36245 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeSplitPointsActor*>(this)->SAV< Standalone<VectorRef<KeyRef>> >::value()) Standalone<VectorRef<KeyRef>>(results);
		this->~GetRangeSplitPointsActorState();
		static_cast<GetRangeSplitPointsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 7564 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Standalone<VectorRef<KeyRef>> results;
															#line 7566 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.push_back_deep(results.arena(), keys.begin);
															#line 7567 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < nLocs;i++) {
															#line 7568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (i > 0)
															#line 36263 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.push_back_deep(results.arena(), locations[i].range.begin);
															#line 36267 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7572 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (fReplies[i].get().splitPoints.size() > 0)
															#line 36271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7573 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.append( results.arena(), fReplies[i].get().splitPoints.begin(), fReplies[i].get().splitPoints.size());
															#line 7575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.arena().dependsOn(fReplies[i].get().splitPoints.arena());
															#line 36277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 7578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (results.back() != keys.end)
															#line 36282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7579 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.push_back_deep(results.arena(), keys.end);
															#line 36286 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetRangeSplitPointsActor*>(this)->SAV<Standalone<VectorRef<KeyRef>>>::futures) { (void)(results); this->~GetRangeSplitPointsActorState(); static_cast<GetRangeSplitPointsActor*>(this)->destroy(); return 0; }
															#line 36290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetRangeSplitPointsActor*>(this)->SAV< Standalone<VectorRef<KeyRef>> >::value()) Standalone<VectorRef<KeyRef>>(results);
		this->~GetRangeSplitPointsActorState();
		static_cast<GetRangeSplitPointsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state > 0) static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeSplitPointsActor*>(this)->ActorCallback< GetRangeSplitPointsActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetRangeSplitPointsActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state > 0) static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeSplitPointsActor*>(this)->ActorCallback< GetRangeSplitPointsActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetRangeSplitPointsActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont1Catch1cont3(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state > 0) static_cast<GetRangeSplitPointsActor*>(this)->actor_wait_state = 0;
		static_cast<GetRangeSplitPointsActor*>(this)->ActorCallback< GetRangeSplitPointsActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1Catch1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetRangeSplitPointsActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1Catch1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetRangeSplitPointsActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<TransactionState> trState;
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int64_t chunkSize;
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 7538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 7541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 7550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int nLocs;
															#line 7551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<SplitRangeReply>> fReplies;
															#line 36539 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getRangeSplitPoints()
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetRangeSplitPointsActor final : public Actor<Standalone<VectorRef<KeyRef>>>, public ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetRangeSplitPointsActor, 1, Void >, public ActorCallback< GetRangeSplitPointsActor, 2, Void >, public ActorCallback< GetRangeSplitPointsActor, 3, Void >, public FastAllocated<GetRangeSplitPointsActor>, public GetRangeSplitPointsActorState<GetRangeSplitPointsActor> {
															#line 36544 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetRangeSplitPointsActor>::operator new;
	using FastAllocated<GetRangeSplitPointsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<KeyRef>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetRangeSplitPointsActor, 1, Void >;
friend struct ActorCallback< GetRangeSplitPointsActor, 2, Void >;
friend struct ActorCallback< GetRangeSplitPointsActor, 3, Void >;
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetRangeSplitPointsActor(Reference<TransactionState> const& trState,KeyRange const& keys,int64_t const& chunkSize,Version const& version) 
															#line 36558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Standalone<VectorRef<KeyRef>>>(),
		   GetRangeSplitPointsActorState<GetRangeSplitPointsActor>(trState, keys, chunkSize, version)
	{
		fdb_probe_actor_enter("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getRangeSplitPoints");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getRangeSplitPoints", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetRangeSplitPointsActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetRangeSplitPointsActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetRangeSplitPointsActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetRangeSplitPointsActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Standalone<VectorRef<KeyRef>>> getRangeSplitPoints( Reference<TransactionState> const& trState, KeyRange const& keys, int64_t const& chunkSize, Version const& version ) {
															#line 7534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Standalone<VectorRef<KeyRef>>>(new GetRangeSplitPointsActor(trState, keys, chunkSize, version));
															#line 36589 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7598 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Standalone<VectorRef<KeyRef>>> Transaction::getRangeSplitPoints(KeyRange const& keys, int64_t chunkSize) {
	return ::getRangeSplitPoints(
	    trState, keys, chunkSize, readVersion.isValid() && readVersion.isReady() ? readVersion.get() : latestVersion);
}

#define BG_REQUEST_DEBUG false

// the blob granule requests are a bit funky because they piggyback off the existing transaction to read from the system
// keyspace
															#line 36603 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getBlobGranuleRangesActor()
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetBlobGranuleRangesActorActor>
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetBlobGranuleRangesActorActorState {
															#line 36610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetBlobGranuleRangesActorActorState(Transaction* const& self,KeyRange const& keyRange) 
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self),
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keyRange(keyRange),
															#line 7610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   currentRange(keyRange),
															#line 7611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results()
															#line 36623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this));

	}
	~GetBlobGranuleRangesActorActorState() 
	{
		fdb_probe_actor_destroy("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7612 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 36638 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("Getting Blob Granules for [{0} - {1})\n", keyRange.begin.printable(), keyRange.end.printable());
															#line 36642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7615 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 7616 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 36648 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetBlobGranuleRangesActorActorState();
		static_cast<GetBlobGranuleRangesActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResult> __when_expr_0 = krmGetRanges(self, blobGranuleMappingKeys.begin, currentRange, 1000, GetRangeLimits::BYTE_LIMIT_UNLIMITED);
															#line 7617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetBlobGranuleRangesActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 36680 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<GetBlobGranuleRangesActorActor*>(this)->actor_wait_state = 1;
															#line 7617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >*>(static_cast<GetBlobGranuleRangesActorActor*>(this)));
															#line 36685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 7620 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < blobGranuleMapping.size() - 1;i++) {
															#line 7621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (blobGranuleMapping[i].value.size())
															#line 36696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7622 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results.push_back(results.arena(), KeyRangeRef(blobGranuleMapping[i].key, blobGranuleMapping[i + 1].key));
															#line 36700 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 7626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.arena().dependsOn(blobGranuleMapping.arena());
															#line 7627 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (blobGranuleMapping.more)
															#line 36707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			currentRange = KeyRangeRef(blobGranuleMapping.back().key, currentRange.end);
															#line 36711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		else
		{
															#line 7630 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<GetBlobGranuleRangesActorActor*>(this)->SAV<Standalone<VectorRef<KeyRangeRef>>>::futures) { (void)(results); this->~GetBlobGranuleRangesActorActorState(); static_cast<GetBlobGranuleRangesActorActor*>(this)->destroy(); return 0; }
															#line 36717 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<GetBlobGranuleRangesActorActor*>(this)->SAV< Standalone<VectorRef<KeyRangeRef>> >::value()) Standalone<VectorRef<KeyRangeRef>>(std::move(results)); // state_var_RVO
			this->~GetBlobGranuleRangesActorActorState();
			static_cast<GetBlobGranuleRangesActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(RangeResult const& __blobGranuleMapping,int loopDepth) 
	{
															#line 7617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		blobGranuleMapping = __blobGranuleMapping;
															#line 36731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(RangeResult && __blobGranuleMapping,int loopDepth) 
	{
		blobGranuleMapping = std::move(__blobGranuleMapping);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetBlobGranuleRangesActorActor*>(this)->actor_wait_state > 0) static_cast<GetBlobGranuleRangesActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetBlobGranuleRangesActorActor*>(this)->ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction* self;
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keyRange;
															#line 7610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange currentRange;
															#line 7611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> results;
															#line 7617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RangeResult blobGranuleMapping;
															#line 36804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getBlobGranuleRangesActor()
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetBlobGranuleRangesActorActor final : public Actor<Standalone<VectorRef<KeyRangeRef>>>, public ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >, public FastAllocated<GetBlobGranuleRangesActorActor>, public GetBlobGranuleRangesActorActorState<GetBlobGranuleRangesActorActor> {
															#line 36809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetBlobGranuleRangesActorActor>::operator new;
	using FastAllocated<GetBlobGranuleRangesActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<KeyRangeRef>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >;
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetBlobGranuleRangesActorActor(Transaction* const& self,KeyRange const& keyRange) 
															#line 36820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Standalone<VectorRef<KeyRangeRef>>>(),
		   GetBlobGranuleRangesActorActorState<GetBlobGranuleRangesActorActor>(self, keyRange)
	{
		fdb_probe_actor_enter("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getBlobGranuleRangesActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getBlobGranuleRangesActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetBlobGranuleRangesActorActor, 0, RangeResult >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Standalone<VectorRef<KeyRangeRef>>> getBlobGranuleRangesActor( Transaction* const& self, KeyRange const& keyRange ) {
															#line 7608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Standalone<VectorRef<KeyRangeRef>>>(new GetBlobGranuleRangesActorActor(self, keyRange));
															#line 36848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7634 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Standalone<VectorRef<KeyRangeRef>>> Transaction::getBlobGranuleRanges(const KeyRange& range) {
	return ::getBlobGranuleRangesActor(this, range);
}

// hack (for now) to get blob worker interface into load balance
struct BWLocationInfo : MultiInterface<ReferencedInterface<BlobWorkerInterface>> {
	using Locations = MultiInterface<ReferencedInterface<BlobWorkerInterface>>;
	explicit BWLocationInfo(const std::vector<Reference<ReferencedInterface<BlobWorkerInterface>>>& v) : Locations(v) {}
};

															#line 36863 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via readBlobGranulesActor()
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ReadBlobGranulesActorActor>
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ReadBlobGranulesActorActorState {
															#line 36870 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadBlobGranulesActorActorState(Transaction* const& self,KeyRange const& range,Version const& begin,Optional<Version> const& read,Version* const& readVersionOut) 
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self),
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   read(read),
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   readVersionOut(readVersionOut),
															#line 7652 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   blobGranuleMapping(),
															#line 7653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   granuleStartKey(),
															#line 7654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   granuleEndKey(),
															#line 7655 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keyRange(range),
															#line 7656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   workerId(),
															#line 7657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   i(),
															#line 7658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rv(),
															#line 7660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(),
															#line 7661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   startTime(now())
															#line 36903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("readBlobGranulesActor", reinterpret_cast<unsigned long>(this));

	}
	~ReadBlobGranulesActorActorState() 
	{
		fdb_probe_actor_destroy("readBlobGranulesActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7663 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (read.present())
															#line 36918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7664 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				rv = read.get();
															#line 36922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1cont1(loopDepth);
			}
			else
			{
															#line 7666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Version> __when_expr_0 = self->getReadVersion();
															#line 7666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 36931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 1;
															#line 7666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ReadBlobGranulesActorActor, 0, Version >*>(static_cast<ReadBlobGranulesActorActor*>(this)));
															#line 36936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ReadBlobGranulesActorActorState();
		static_cast<ReadBlobGranulesActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 7669 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 7674 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResult> __when_expr_1 = krmGetRanges(self, blobGranuleMappingKeys.begin, keyRange, 1000, GetRangeLimits::BYTE_LIMIT_UNLIMITED);
															#line 7674 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 36964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 2;
															#line 7674 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >*>(static_cast<ReadBlobGranulesActorActor*>(this)));
															#line 36969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3(Version const& _end,int loopDepth) 
	{
															#line 7667 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rv = _end;
															#line 36978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(Version && _end,int loopDepth) 
	{
															#line 7667 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rv = _end;
															#line 36987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version const& _end,int loopDepth) 
	{
		loopDepth = a_body1cont3(_end, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Version && _end,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_end), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state > 0) static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 0;
		static_cast<ReadBlobGranulesActorActor*>(this)->ActorCallback< ReadBlobGranulesActorActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ReadBlobGranulesActorActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont5(RangeResult const& _bgMapping,int loopDepth) 
	{
															#line 7676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		blobGranuleMapping = _bgMapping;
															#line 7677 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (blobGranuleMapping.more)
															#line 37061 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print( "BG Mapping for [{0} - %{1}) too large!\n", keyRange.begin.printable(), keyRange.end.printable());
															#line 37069 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarn, "BGMappingTooLarge").detail("Range", range).detail("Max", 1000);
															#line 7683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(unsupported_operation(), loopDepth);
															#line 37075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!blobGranuleMapping.more && blobGranuleMapping.size() < CLIENT_KNOBS->TOO_MANY);
															#line 7687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (blobGranuleMapping.size() == 0)
															#line 37081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37085 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7689 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				printf("no blob worker assignments yet\n");
															#line 37089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7691 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(blob_granule_transaction_too_old(), loopDepth);
															#line 37093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37097 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("Doing blob granule request @ {}\n", rv);
															#line 7696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("blob worker assignments:\n");
															#line 37103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i = 0;
															#line 37107 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont5loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont5(RangeResult && _bgMapping,int loopDepth) 
	{
															#line 7676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		blobGranuleMapping = _bgMapping;
															#line 7677 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (blobGranuleMapping.more)
															#line 37118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print( "BG Mapping for [{0} - %{1}) too large!\n", keyRange.begin.printable(), keyRange.end.printable());
															#line 37126 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevWarn, "BGMappingTooLarge").detail("Range", range).detail("Max", 1000);
															#line 7683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(unsupported_operation(), loopDepth);
															#line 37132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!blobGranuleMapping.more && blobGranuleMapping.size() < CLIENT_KNOBS->TOO_MANY);
															#line 7687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (blobGranuleMapping.size() == 0)
															#line 37138 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7689 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				printf("no blob worker assignments yet\n");
															#line 37146 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7691 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(blob_granule_transaction_too_old(), loopDepth);
															#line 37150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("Doing blob granule request @ {}\n", rv);
															#line 7696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("blob worker assignments:\n");
															#line 37160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i = 0;
															#line 37164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont5loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(RangeResult const& _bgMapping,int loopDepth) 
	{
		loopDepth = a_body1cont5(_bgMapping, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(RangeResult && _bgMapping,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_bgMapping), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state > 0) static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 0;
		static_cast<ReadBlobGranulesActorActor*>(this)->ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont6(int loopDepth) 
	{
															#line 7745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i = 0;
															#line 37236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont6loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont5loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1(int loopDepth) 
	{
															#line 7699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(i < blobGranuleMapping.size() - 1))
															#line 37252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont5break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 7700 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		granuleStartKey = blobGranuleMapping[i].key;
															#line 7701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		granuleEndKey = blobGranuleMapping[i + 1].key;
															#line 7702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!blobGranuleMapping[i].value.size())
															#line 37262 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7703 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("Key range [{0} - {1}) missing worker assignment!\n", granuleStartKey.printable(), granuleEndKey.printable());
															#line 37270 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(blob_granule_transaction_too_old(), std::max(0, loopDepth - 1));
															#line 37274 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		workerId = decodeBlobGranuleMappingValue(blobGranuleMapping[i].value);
															#line 7713 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (workerId == UID())
															#line 37280 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37284 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7715 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("Key range [{0} - {1}) has no assigned worker yet!\n", granuleStartKey.printable(), granuleEndKey.printable());
															#line 37288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7719 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(blob_granule_transaction_too_old(), std::max(0, loopDepth - 1));
															#line 37292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7721 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37296 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print( "  [{0} - {1}): {2}\n", granuleStartKey.printable(), granuleEndKey.printable(), workerId.toString());
															#line 37300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!self->trState->cx->blobWorker_interf.count(workerId))
															#line 37304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_2 = self->get(blobWorkerListKeyFor(workerId));
															#line 7727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 37310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1cont5loopBody1when1(__when_expr_2.get(), loopDepth); };
			static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 3;
															#line 7727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >*>(static_cast<ReadBlobGranulesActorActor*>(this)));
															#line 37315 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont5loopBody1cont1(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5break1(int loopDepth) 
	{
		try {
			return a_body1cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont5loopBody1cont1(int loopDepth) 
	{
															#line 7699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i++;
															#line 37342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont5loopHead1(0);

		return loopDepth;
	}
	int a_body1cont5loopBody1cont8(Optional<Value> const& workerInterface,int loopDepth) 
	{
															#line 7731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!workerInterface.present())
															#line 37351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(transaction_too_old(), std::max(0, loopDepth - 1));
															#line 37355 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->trState->cx->blobWorker_interf[workerId] = decodeBlobWorkerListValue(workerInterface.get());
															#line 7738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37361 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("    decoded worker interface for {0}\n", workerId.toString());
															#line 37365 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1cont5loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1cont8(Optional<Value> && workerInterface,int loopDepth) 
	{
															#line 7731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!workerInterface.present())
															#line 37375 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7734 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(transaction_too_old(), std::max(0, loopDepth - 1));
															#line 37379 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->trState->cx->blobWorker_interf[workerId] = decodeBlobWorkerListValue(workerInterface.get());
															#line 7738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37385 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("    decoded worker interface for {0}\n", workerId.toString());
															#line 37389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1cont5loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1when1(Optional<Value> const& workerInterface,int loopDepth) 
	{
		loopDepth = a_body1cont5loopBody1cont8(workerInterface, loopDepth);

		return loopDepth;
	}
	int a_body1cont5loopBody1when1(Optional<Value> && workerInterface,int loopDepth) 
	{
		loopDepth = a_body1cont5loopBody1cont8(std::move(workerInterface), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state > 0) static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 0;
		static_cast<ReadBlobGranulesActorActor*>(this)->ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont5loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont5loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont12(int loopDepth) 
	{
															#line 7839 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->trState->cx->anyBlobGranuleRequests = true;
															#line 7840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->trState->cx->bgGranulesPerRequest.addSample(results.size());
															#line 7841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		self->trState->cx->bgLatencies.addSample(now() - startTime);
															#line 7843 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (readVersionOut != nullptr)
															#line 37468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7844 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			*readVersionOut = rv;
															#line 37472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ReadBlobGranulesActorActor*>(this)->SAV<Standalone<VectorRef<BlobGranuleChunkRef>>>::futures) { (void)(results); this->~ReadBlobGranulesActorActorState(); static_cast<ReadBlobGranulesActorActor*>(this)->destroy(); return 0; }
															#line 37476 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ReadBlobGranulesActorActor*>(this)->SAV< Standalone<VectorRef<BlobGranuleChunkRef>> >::value()) Standalone<VectorRef<BlobGranuleChunkRef>>(std::move(results)); // state_var_RVO
		this->~ReadBlobGranulesActorActorState();
		static_cast<ReadBlobGranulesActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont6loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont6loopBody1(int loopDepth) 
	{
															#line 7745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(i < blobGranuleMapping.size() - 1))
															#line 37495 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont6break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 7746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		granuleStartKey = blobGranuleMapping[i].key;
															#line 7747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		granuleEndKey = blobGranuleMapping[i + 1].key;
															#line 7749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (granuleEndKey <= keyRange.begin)
															#line 37505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont6continue1(loopDepth); // continue
		}
															#line 7752 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		workerId = decodeBlobGranuleMappingValue(blobGranuleMapping[i].value);
															#line 7754 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (keyRange.begin > granuleStartKey)
															#line 37513 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7755 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			granuleStartKey = keyRange.begin;
															#line 37517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (keyRange.end < granuleEndKey)
															#line 37521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			granuleEndKey = keyRange.end;
															#line 37525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req = BlobGranuleFileRequest();
															#line 7762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.keyRange = KeyRangeRef(StringRef(req.arena, granuleStartKey), StringRef(req.arena, granuleEndKey));
															#line 7763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.beginVersion = begin;
															#line 7764 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.readVersion = rv;
															#line 7765 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		req.canCollapseBegin = true;
															#line 7767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<Reference<ReferencedInterface<BlobWorkerInterface>>> v;
															#line 7768 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		v.push_back( makeReference<ReferencedInterface<BlobWorkerInterface>>(self->trState->cx->blobWorker_interf[workerId]));
															#line 7770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		location = makeReference<BWLocationInfo>(v);
															#line 37543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 7775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<BlobGranuleFileReply> __when_expr_3 = loadBalance(location, &BlobWorkerInterface::blobGranuleFileRequest, req, TaskPriority::DefaultPromiseEndpoint, AtMostOnce::False, nullptr);
															#line 7774 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1cont6loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 37549 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont6loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont6loopBody1when1(__when_expr_3.get(), loopDepth); };
															#line 7816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = IFailureMonitor::failureMonitor().onStateEqual( location->get(0, &BlobWorkerInterface::blobGranuleFileRequest).getEndpoint(), FailureStatus(true));
															#line 37553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1cont6loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont6loopBody1when2(__when_expr_4.get(), loopDepth); };
			static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 4;
															#line 7775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >*>(static_cast<ReadBlobGranulesActorActor*>(this)));
															#line 7816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< ReadBlobGranulesActorActor, 4, Void >*>(static_cast<ReadBlobGranulesActorActor*>(this)));
															#line 37560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont6loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont6loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont6break1(int loopDepth) 
	{
		try {
			return a_body1cont12(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont6continue1(int loopDepth) 
	{
															#line 7745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i++;
															#line 37588 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont6loopHead1(0);

		return loopDepth;
	}
	int a_body1cont6loopBody1cont1(int loopDepth) 
	{
															#line 7745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i++;
															#line 37597 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont6loopHead1(0);

		return loopDepth;
	}
	int a_body1cont6loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7827 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37607 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("BGReq got error {}\n", e.name());
															#line 37611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_connection_failed)
															#line 37615 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7833 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(transaction_too_old(), std::max(0, loopDepth - 1));
															#line 37619 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 37623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont6loopBody1cont6(int loopDepth) 
	{
		loopDepth = a_body1cont6loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont6loopBody1when1(BlobGranuleFileReply const& rep,int loopDepth) 
	{
															#line 7781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37643 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("Blob granule request for [{0} - {1}) @ {2} - {3} got reply from {4}:\n", granuleStartKey.printable(), granuleEndKey.printable(), begin, rv, workerId.toString());
															#line 37647 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.arena().dependsOn(rep.arena);
															#line 7790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& chunk : rep.chunks ) {
															#line 7791 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37655 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print( "[{0} - {1})\n", chunk.keyRange.begin.printable(), chunk.keyRange.end.printable());
															#line 7795 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("  SnapshotFile: {0}\n    \n  DeltaFiles:\n", chunk.snapshotFile.present() ? chunk.snapshotFile.get().toString().c_str() : "<none>");
															#line 7798 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for( auto& df : chunk.deltaFiles ) {
															#line 7799 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fmt::print("    {0}\n", df.toString());
															#line 37665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 7801 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("  Deltas: ({0})", chunk.newDeltas.size());
															#line 7802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (chunk.newDeltas.size() > 0)
															#line 37671 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 7803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fmt::print(" with version [{0} - {1}]", chunk.newDeltas[0].version, chunk.newDeltas[chunk.newDeltas.size() - 1].version);
															#line 37675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 7807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("  IncludedVersion: {0}\n\n\n", chunk.includedVersion);
															#line 37679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.push_back(results.arena(), chunk);
															#line 7811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			keyRange = KeyRangeRef(std::min(chunk.keyRange.end, keyRange.end), keyRange.end);
															#line 37685 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1cont6loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont6loopBody1when1(BlobGranuleFileReply && rep,int loopDepth) 
	{
															#line 7781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("Blob granule request for [{0} - {1}) @ {2} - {3} got reply from {4}:\n", granuleStartKey.printable(), granuleEndKey.printable(), begin, rv, workerId.toString());
															#line 37699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.arena().dependsOn(rep.arena);
															#line 7790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& chunk : rep.chunks ) {
															#line 7791 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 37707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print( "[{0} - {1})\n", chunk.keyRange.begin.printable(), chunk.keyRange.end.printable());
															#line 7795 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("  SnapshotFile: {0}\n    \n  DeltaFiles:\n", chunk.snapshotFile.present() ? chunk.snapshotFile.get().toString().c_str() : "<none>");
															#line 7798 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for( auto& df : chunk.deltaFiles ) {
															#line 7799 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fmt::print("    {0}\n", df.toString());
															#line 37717 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 7801 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("  Deltas: ({0})", chunk.newDeltas.size());
															#line 7802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (chunk.newDeltas.size() > 0)
															#line 37723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 7803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					fmt::print(" with version [{0} - {1}]", chunk.newDeltas[0].version, chunk.newDeltas[chunk.newDeltas.size() - 1].version);
															#line 37727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 7807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("  IncludedVersion: {0}\n\n\n", chunk.includedVersion);
															#line 37731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7810 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.push_back(results.arena(), chunk);
															#line 7811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			keyRange = KeyRangeRef(std::min(chunk.keyRange.end, keyRange.end), keyRange.end);
															#line 37737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1cont6loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont6loopBody1when2(Void const& _,int loopDepth) 
	{
															#line 7819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37747 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("readBlobGranules got BW {0} failed\n", workerId.toString());
															#line 37751 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1cont6loopBody1Catch1(connection_failed(), loopDepth);
															#line 37755 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont6loopBody1when2(Void && _,int loopDepth) 
	{
															#line 7819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 37763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("readBlobGranules got BW {0} failed\n", workerId.toString());
															#line 37767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1cont6loopBody1Catch1(connection_failed(), loopDepth);
															#line 37771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state > 0) static_cast<ReadBlobGranulesActorActor*>(this)->actor_wait_state = 0;
		static_cast<ReadBlobGranulesActorActor*>(this)->ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >::remove();
		static_cast<ReadBlobGranulesActorActor*>(this)->ActorCallback< ReadBlobGranulesActorActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >*,BlobGranuleFileReply const& value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont6loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont6loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont6loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >*,BlobGranuleFileReply && value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont6loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont6loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont6loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >*,Error err) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont6loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont6loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont6loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont6loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1cont6loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont6loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< ReadBlobGranulesActorActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont6loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont6loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont6loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< ReadBlobGranulesActorActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose4();
		try {
			a_body1cont6loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont6loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont6loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont6loopBody1cont7(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont6loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction* self;
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange range;
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version begin;
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<Version> read;
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version* readVersionOut;
															#line 7652 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RangeResult blobGranuleMapping;
															#line 7653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key granuleStartKey;
															#line 7654 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key granuleEndKey;
															#line 7655 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keyRange;
															#line 7656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID workerId;
															#line 7657 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int i;
															#line 7658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version rv;
															#line 7660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Standalone<VectorRef<BlobGranuleChunkRef>> results;
															#line 7661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double startTime;
															#line 7761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	BlobGranuleFileRequest req;
															#line 7770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<MultiInterface<ReferencedInterface<BlobWorkerInterface>>> location;
															#line 37917 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via readBlobGranulesActor()
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ReadBlobGranulesActorActor final : public Actor<Standalone<VectorRef<BlobGranuleChunkRef>>>, public ActorCallback< ReadBlobGranulesActorActor, 0, Version >, public ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >, public ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >, public ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >, public ActorCallback< ReadBlobGranulesActorActor, 4, Void >, public FastAllocated<ReadBlobGranulesActorActor>, public ReadBlobGranulesActorActorState<ReadBlobGranulesActorActor> {
															#line 37922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ReadBlobGranulesActorActor>::operator new;
	using FastAllocated<ReadBlobGranulesActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<BlobGranuleChunkRef>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< ReadBlobGranulesActorActor, 0, Version >;
friend struct ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >;
friend struct ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >;
friend struct ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >;
friend struct ActorCallback< ReadBlobGranulesActorActor, 4, Void >;
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadBlobGranulesActorActor(Transaction* const& self,KeyRange const& range,Version const& begin,Optional<Version> const& read,Version* const& readVersionOut) 
															#line 37937 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Standalone<VectorRef<BlobGranuleChunkRef>>>(),
		   ReadBlobGranulesActorActorState<ReadBlobGranulesActorActor>(self, range, begin, read, readVersionOut)
	{
		fdb_probe_actor_enter("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("readBlobGranulesActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("readBlobGranulesActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ReadBlobGranulesActorActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< ReadBlobGranulesActorActor, 1, RangeResult >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< ReadBlobGranulesActorActor, 2, Optional<Value> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< ReadBlobGranulesActorActor, 3, BlobGranuleFileReply >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Standalone<VectorRef<BlobGranuleChunkRef>>> readBlobGranulesActor( Transaction* const& self, KeyRange const& range, Version const& begin, Optional<Version> const& read, Version* const& readVersionOut ) {
															#line 7645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Standalone<VectorRef<BlobGranuleChunkRef>>>(new ReadBlobGranulesActorActor(self, range, begin, read, readVersionOut));
															#line 37968 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Standalone<VectorRef<BlobGranuleChunkRef>>> Transaction::readBlobGranules(const KeyRange& range,
                                                                                 Version begin,
                                                                                 Optional<Version> readVersion,
                                                                                 Version* readVersionOut) {
	return readBlobGranulesActor(this, range, begin, readVersion, readVersionOut);
}

															#line 37980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via setPerpetualStorageWiggle()
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SetPerpetualStorageWiggleActor>
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SetPerpetualStorageWiggleActorState {
															#line 37987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SetPerpetualStorageWiggleActorState(Database const& cx,bool const& enable,LockAware const& lockAware) 
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   enable(enable),
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   lockAware(lockAware),
															#line 7857 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(cx)
															#line 38000 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this));

	}
	~SetPerpetualStorageWiggleActorState() 
	{
		fdb_probe_actor_destroy("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 38015 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SetPerpetualStorageWiggleActorState();
		static_cast<SetPerpetualStorageWiggleActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 7872 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SetPerpetualStorageWiggleActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SetPerpetualStorageWiggleActorState(); static_cast<SetPerpetualStorageWiggleActor*>(this)->destroy(); return 0; }
															#line 38038 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SetPerpetualStorageWiggleActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SetPerpetualStorageWiggleActorState();
		static_cast<SetPerpetualStorageWiggleActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 7860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 7861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (lockAware)
															#line 38060 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7862 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 38064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7865 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.set(perpetualStorageWiggleKey, enable ? "1"_sr : "0"_sr);
															#line 7866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = tr.commit();
															#line 7866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 38072 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state = 1;
															#line 7866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >*>(static_cast<SetPerpetualStorageWiggleActor*>(this)));
															#line 38077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = tr.onError(e);
															#line 7869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 38114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_1.get(), loopDepth); };
			static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state = 2;
															#line 7869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >*>(static_cast<SetPerpetualStorageWiggleActor*>(this)));
															#line 38119 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state > 0) static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state = 0;
		static_cast<SetPerpetualStorageWiggleActor*>(this)->ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state > 0) static_cast<SetPerpetualStorageWiggleActor*>(this)->actor_wait_state = 0;
		static_cast<SetPerpetualStorageWiggleActor*>(this)->ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool enable;
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	LockAware lockAware;
															#line 7857 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadYourWritesTransaction tr;
															#line 38288 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via setPerpetualStorageWiggle()
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SetPerpetualStorageWiggleActor final : public Actor<Void>, public ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >, public ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >, public FastAllocated<SetPerpetualStorageWiggleActor>, public SetPerpetualStorageWiggleActorState<SetPerpetualStorageWiggleActor> {
															#line 38293 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SetPerpetualStorageWiggleActor>::operator new;
	using FastAllocated<SetPerpetualStorageWiggleActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >;
friend struct ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >;
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SetPerpetualStorageWiggleActor(Database const& cx,bool const& enable,LockAware const& lockAware) 
															#line 38305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   SetPerpetualStorageWiggleActorState<SetPerpetualStorageWiggleActor>(cx, enable, lockAware)
	{
		fdb_probe_actor_enter("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("setPerpetualStorageWiggle");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("setPerpetualStorageWiggle", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SetPerpetualStorageWiggleActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SetPerpetualStorageWiggleActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> setPerpetualStorageWiggle( Database const& cx, bool const& enable, LockAware const& lockAware ) {
															#line 7856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new SetPerpetualStorageWiggleActor(cx, enable, lockAware));
															#line 38334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7874 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 38339 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via readStorageWiggleValues()
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ReadStorageWiggleValuesActor>
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ReadStorageWiggleValuesActorState {
															#line 38346 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadStorageWiggleValuesActorState(Database const& cx,bool const& primary,bool const& use_system_priority) 
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   primary(primary),
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   use_system_priority(use_system_priority),
															#line 7878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   readKey(perpetualStorageWiggleIDPrefix.withSuffix(primary ? "primary/"_sr : "remote/"_sr)),
															#line 7879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   metadataMap(readKey, IncludeVersion()),
															#line 7881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(new ReadYourWritesTransaction(cx)),
															#line 7882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   res()
															#line 38365 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("readStorageWiggleValues", reinterpret_cast<unsigned long>(this));

	}
	~ReadStorageWiggleValuesActorState() 
	{
		fdb_probe_actor_destroy("readStorageWiggleValues", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7884 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 38380 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ReadStorageWiggleValuesActorState();
		static_cast<ReadStorageWiggleValuesActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 7898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ReadStorageWiggleValuesActor*>(this)->SAV<std::vector<std::pair<UID, StorageWiggleValue>>>::futures) { (void)(res); this->~ReadStorageWiggleValuesActorState(); static_cast<ReadStorageWiggleValuesActor*>(this)->destroy(); return 0; }
															#line 38403 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ReadStorageWiggleValuesActor*>(this)->SAV< std::vector<std::pair<UID, StorageWiggleValue>> >::value()) std::vector<std::pair<UID, StorageWiggleValue>>(std::move(res)); // state_var_RVO
		this->~ReadStorageWiggleValuesActorState();
		static_cast<ReadStorageWiggleValuesActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 7886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::READ_SYSTEM_KEYS);
															#line 7887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::READ_LOCK_AWARE);
															#line 7888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (use_system_priority)
															#line 38427 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr->setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE);
															#line 38431 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = store(res, metadataMap.getRange(tr, UID(0, 0), Optional<UID>(), CLIENT_KNOBS->TOO_MANY));
															#line 7891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 38437 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state = 1;
															#line 7891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ReadStorageWiggleValuesActor, 0, Void >*>(static_cast<ReadStorageWiggleValuesActor*>(this)));
															#line 38442 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr->onError(e);
															#line 7895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 38479 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state = 3;
															#line 7895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< ReadStorageWiggleValuesActor, 2, Void >*>(static_cast<ReadStorageWiggleValuesActor*>(this)));
															#line 38484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 7892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = tr->commit();
															#line 7892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 38501 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state = 2;
															#line 7892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ReadStorageWiggleValuesActor, 1, Void >*>(static_cast<ReadStorageWiggleValuesActor*>(this)));
															#line 38506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 7892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = tr->commit();
															#line 7892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 38517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state = 2;
															#line 7892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ReadStorageWiggleValuesActor, 1, Void >*>(static_cast<ReadStorageWiggleValuesActor*>(this)));
															#line 38522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state > 0) static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state = 0;
		static_cast<ReadStorageWiggleValuesActor*>(this)->ActorCallback< ReadStorageWiggleValuesActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ReadStorageWiggleValuesActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ReadStorageWiggleValuesActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ReadStorageWiggleValuesActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont4(Void const& _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void && _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state > 0) static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state = 0;
		static_cast<ReadStorageWiggleValuesActor*>(this)->ActorCallback< ReadStorageWiggleValuesActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ReadStorageWiggleValuesActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ReadStorageWiggleValuesActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ReadStorageWiggleValuesActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state > 0) static_cast<ReadStorageWiggleValuesActor*>(this)->actor_wait_state = 0;
		static_cast<ReadStorageWiggleValuesActor*>(this)->ActorCallback< ReadStorageWiggleValuesActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ReadStorageWiggleValuesActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< ReadStorageWiggleValuesActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< ReadStorageWiggleValuesActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool primary;
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool use_system_priority;
															#line 7878 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	const Key readKey;
															#line 7879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyBackedObjectMap<UID, StorageWiggleValue, decltype(IncludeVersion())> metadataMap;
															#line 7881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 7882 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<std::pair<UID, StorageWiggleValue>> res;
															#line 38754 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via readStorageWiggleValues()
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ReadStorageWiggleValuesActor final : public Actor<std::vector<std::pair<UID, StorageWiggleValue>>>, public ActorCallback< ReadStorageWiggleValuesActor, 0, Void >, public ActorCallback< ReadStorageWiggleValuesActor, 1, Void >, public ActorCallback< ReadStorageWiggleValuesActor, 2, Void >, public FastAllocated<ReadStorageWiggleValuesActor>, public ReadStorageWiggleValuesActorState<ReadStorageWiggleValuesActor> {
															#line 38759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ReadStorageWiggleValuesActor>::operator new;
	using FastAllocated<ReadStorageWiggleValuesActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<std::vector<std::pair<UID, StorageWiggleValue>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< ReadStorageWiggleValuesActor, 0, Void >;
friend struct ActorCallback< ReadStorageWiggleValuesActor, 1, Void >;
friend struct ActorCallback< ReadStorageWiggleValuesActor, 2, Void >;
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReadStorageWiggleValuesActor(Database const& cx,bool const& primary,bool const& use_system_priority) 
															#line 38772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<std::vector<std::pair<UID, StorageWiggleValue>>>(),
		   ReadStorageWiggleValuesActorState<ReadStorageWiggleValuesActor>(cx, primary, use_system_priority)
	{
		fdb_probe_actor_enter("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("readStorageWiggleValues");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("readStorageWiggleValues", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ReadStorageWiggleValuesActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< ReadStorageWiggleValuesActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< ReadStorageWiggleValuesActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<std::vector<std::pair<UID, StorageWiggleValue>>> readStorageWiggleValues( Database const& cx, bool const& primary, bool const& use_system_priority ) {
															#line 7875 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<std::vector<std::pair<UID, StorageWiggleValue>>>(new ReadStorageWiggleValuesActor(cx, primary, use_system_priority));
															#line 38802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 38807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via splitStorageMetricsStream()
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SplitStorageMetricsStreamActor>
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SplitStorageMetricsStreamActorState {
															#line 38814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SplitStorageMetricsStreamActorState(PromiseStream<Key> const& resultStream,Database const& cx,KeyRange const& keys,StorageMetrics const& limit,StorageMetrics const& estimated) 
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : resultStream(resultStream),
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(cx),
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limit(limit),
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   estimated(estimated),
															#line 7906 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:SplitStorageMetricsStream"_loc),
															#line 7907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   beginKey(keys.begin),
															#line 7908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   globalLastKey(beginKey)
															#line 38835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this));

	}
	~SplitStorageMetricsStreamActorState() 
	{
		fdb_probe_actor_destroy("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 7909 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			resultStream.send(beginKey);
															#line 7911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			globalUsed = StorageMetrics();
															#line 7912 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 38854 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SplitStorageMetricsStreamActorState();
		static_cast<SplitStorageMetricsStreamActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 7993 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SplitStorageMetricsStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SplitStorageMetricsStreamActorState(); static_cast<SplitStorageMetricsStreamActor*>(this)->destroy(); return 0; }
															#line 38877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SplitStorageMetricsStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SplitStorageMetricsStreamActorState();
		static_cast<SplitStorageMetricsStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 7913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(cx, Optional<TenantName>(), KeyRangeRef(beginKey, keys.end), CLIENT_KNOBS->STORAGE_METRICS_SHARD_LIMIT, Reverse::False, &StorageServerInterface::splitMetrics, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 7913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 38898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state = 1;
															#line 7913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<SplitStorageMetricsStreamActor*>(this)));
															#line 38903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		try {
															#line 7927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			localUsed = globalUsed;
															#line 7928 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			localLastKey = globalLastKey;
															#line 7929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results = Standalone<VectorRef<KeyRef>>();
															#line 7930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			i = 0;
															#line 7931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 38934 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 7913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 38949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state > 0) static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state = 0;
		static_cast<SplitStorageMetricsStreamActor*>(this)->ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 7981 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_operation_cancelled)
															#line 39023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7982 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 39027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7984 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_wrong_shard_server && e.code() != error_code_all_alternatives_failed)
															#line 39031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 7985 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "SplitStorageMetricsStreamError").error(e);
															#line 7986 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				resultStream.sendError(e);
															#line 7987 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 39039 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 7989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->invalidateCache(Key(), keys);
															#line 7990 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, TaskPriority::DataDistribution);
															#line 7990 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 39047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state = 3;
															#line 7990 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< SplitStorageMetricsStreamActor, 2, Void >*>(static_cast<SplitStorageMetricsStreamActor*>(this)));
															#line 39052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
															#line 7958 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		globalUsed = localUsed;
															#line 7961 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (keys.end <= locations.back().range.end && globalUsed.allLessOrEqual(limit * CLIENT_KNOBS->STORAGE_METRICS_UNFAIR_SPLIT_LIMIT) && results.size() > 1)
															#line 39069 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.resize(results.arena(), results.size() - 1);
															#line 7965 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			localLastKey = results.back();
															#line 39075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7967 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		globalLastKey = localLastKey;
															#line 7969 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& splitKey : results ) {
															#line 7970 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			resultStream.send(splitKey);
															#line 39083 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7973 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (keys.end <= locations.back().range.end)
															#line 39087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7974 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			resultStream.send(keys.end);
															#line 7975 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			resultStream.sendError(end_of_stream());
															#line 39093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return a_body1break1(loopDepth==0?0:loopDepth-1); // break
		}
		else
		{
															#line 7978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			beginKey = locations.back().range.end;
															#line 39100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1(int loopDepth) 
	{
															#line 7931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(i < locations.size()))
															#line 39117 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 7932 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		SplitMetricsRequest req(locations[i].range, limit, localUsed, estimated, i == locations.size() - 1 && keys.end <= locations.back().range.end);
															#line 7937 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<SplitMetricsReply> __when_expr_1 = loadBalance(locations[i].locations->locations(), &StorageServerInterface::splitMetrics, req, TaskPriority::DataDistribution);
															#line 7937 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 39127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state = 2;
															#line 7937 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >*>(static_cast<SplitStorageMetricsStreamActor*>(this)));
															#line 39132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(SplitMetricsReply const& res,int loopDepth) 
	{
															#line 7941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size() && res.splits[0] <= localLastKey)
															#line 39154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT_WE_THINK(false);
															#line 7945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1cont1Catch1(all_alternatives_failed(), std::max(0, loopDepth - 1));
															#line 39160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size())
															#line 39164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.append(results.arena(), res.splits.begin(), res.splits.size());
															#line 7950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.arena().dependsOn(res.splits.arena());
															#line 7951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			localLastKey = res.splits.back();
															#line 39172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		localUsed = res.used;
															#line 7931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i++;
															#line 39178 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(SplitMetricsReply && res,int loopDepth) 
	{
															#line 7941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size() && res.splits[0] <= localLastKey)
															#line 39187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT_WE_THINK(false);
															#line 7945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1cont1Catch1(all_alternatives_failed(), std::max(0, loopDepth - 1));
															#line 39193 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size())
															#line 39197 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 7949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.append(results.arena(), res.splits.begin(), res.splits.size());
															#line 7950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.arena().dependsOn(res.splits.arena());
															#line 7951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			localLastKey = res.splits.back();
															#line 39205 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 7953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		localUsed = res.used;
															#line 7931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i++;
															#line 39211 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(SplitMetricsReply const& res,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont1(res, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(SplitMetricsReply && res,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont1(std::move(res), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state > 0) static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state = 0;
		static_cast<SplitStorageMetricsStreamActor*>(this)->ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >::remove();

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >*,SplitMetricsReply const& value) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >*,SplitMetricsReply && value) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >*,Error err) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont9(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state > 0) static_cast<SplitStorageMetricsStreamActor*>(this)->actor_wait_state = 0;
		static_cast<SplitStorageMetricsStreamActor*>(this)->ActorCallback< SplitStorageMetricsStreamActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsStreamActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsStreamActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< SplitStorageMetricsStreamActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<Key> resultStream;
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics limit;
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics estimated;
															#line 7906 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 7907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key beginKey;
															#line 7908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key globalLastKey;
															#line 7911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics globalUsed;
															#line 7913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 7927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics localUsed;
															#line 7928 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key localLastKey;
															#line 7929 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Standalone<VectorRef<KeyRef>> results;
															#line 7930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int i;
															#line 39395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via splitStorageMetricsStream()
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SplitStorageMetricsStreamActor final : public Actor<Void>, public ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >, public ActorCallback< SplitStorageMetricsStreamActor, 2, Void >, public FastAllocated<SplitStorageMetricsStreamActor>, public SplitStorageMetricsStreamActorState<SplitStorageMetricsStreamActor> {
															#line 39400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SplitStorageMetricsStreamActor>::operator new;
	using FastAllocated<SplitStorageMetricsStreamActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >;
friend struct ActorCallback< SplitStorageMetricsStreamActor, 2, Void >;
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SplitStorageMetricsStreamActor(PromiseStream<Key> const& resultStream,Database const& cx,KeyRange const& keys,StorageMetrics const& limit,StorageMetrics const& estimated) 
															#line 39413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   SplitStorageMetricsStreamActorState<SplitStorageMetricsStreamActor>(resultStream, cx, keys, limit, estimated)
	{
		fdb_probe_actor_enter("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("splitStorageMetricsStream");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("splitStorageMetricsStream", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SplitStorageMetricsStreamActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SplitStorageMetricsStreamActor, 1, SplitMetricsReply >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< SplitStorageMetricsStreamActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> splitStorageMetricsStream( PromiseStream<Key> const& resultStream, Database const& cx, KeyRange const& keys, StorageMetrics const& limit, StorageMetrics const& estimated ) {
															#line 7901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new SplitStorageMetricsStreamActor(resultStream, cx, keys, limit, estimated));
															#line 39443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 7995 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> DatabaseContext::splitStorageMetricsStream(const PromiseStream<Key>& resultStream,
                                                        KeyRange const& keys,
                                                        StorageMetrics const& limit,
                                                        StorageMetrics const& estimated) {
	return ::splitStorageMetricsStream(
	    resultStream, Database(Reference<DatabaseContext>::addRef(this)), keys, limit, estimated);
}

															#line 39456 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via splitStorageMetrics()
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SplitStorageMetricsActor>
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SplitStorageMetricsActorState {
															#line 39463 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SplitStorageMetricsActorState(Database const& cx,KeyRange const& keys,StorageMetrics const& limit,StorageMetrics const& estimated) 
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   limit(limit),
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   estimated(estimated),
															#line 8008 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:SplitStorageMetrics"_loc)
															#line 39478 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("splitStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	~SplitStorageMetricsActorState() 
	{
		fdb_probe_actor_destroy("splitStorageMetrics", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8009 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 39493 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SplitStorageMetricsActorState();
		static_cast<SplitStorageMetricsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 8010 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, CLIENT_KNOBS->STORAGE_METRICS_SHARD_LIMIT, Reverse::False, &StorageServerInterface::splitMetrics, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 8010 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 39525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 1;
															#line 8010 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<SplitStorageMetricsActor*>(this)));
															#line 39530 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
															#line 8021 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		used = StorageMetrics();
															#line 8022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results = Standalone<VectorRef<KeyRef>>();
															#line 8026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() == CLIENT_KNOBS->STORAGE_METRICS_SHARD_LIMIT)
															#line 39543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = delay(CLIENT_KNOBS->STORAGE_METRICS_TOO_MANY_SHARDS_DELAY, TaskPriority::DataDistribution);
															#line 8027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 39549 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 2;
															#line 8027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SplitStorageMetricsActor, 1, Void >*>(static_cast<SplitStorageMetricsActor*>(this)));
															#line 39554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 8030 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.push_back_deep(results.arena(), keys.begin);
															#line 39561 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			try {
															#line 8034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				i = 0;
															#line 8035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				;
															#line 39567 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopBody1cont1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
			}
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 8010 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 39583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<SplitStorageMetricsActor*>(this)->ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 8028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(Key(), keys);
															#line 39656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 8028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(Key(), keys);
															#line 39665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<SplitStorageMetricsActor*>(this)->ActorCallback< SplitStorageMetricsActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SplitStorageMetricsActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 8067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_wrong_shard_server && e.code() != error_code_all_alternatives_failed)
															#line 39744 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8068 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevError, "SplitStorageMetricsError").error(e);
															#line 8069 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 39750 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8071 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->invalidateCache(Key(), keys);
															#line 8072 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY, TaskPriority::DataDistribution);
															#line 8072 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 39758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 4;
															#line 8072 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< SplitStorageMetricsActor, 3, Void >*>(static_cast<SplitStorageMetricsActor*>(this)));
															#line 39763 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
															#line 8057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (used.allLessOrEqual(limit * CLIENT_KNOBS->STORAGE_METRICS_UNFAIR_SPLIT_LIMIT) && results.size() > 1)
															#line 39778 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8059 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.resize(results.arena(), results.size() - 1);
															#line 39782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (keys.end <= locations.back().range.end)
															#line 39786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.push_back_deep(results.arena(), keys.end);
															#line 39790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SplitStorageMetricsActor*>(this)->SAV<Standalone<VectorRef<KeyRef>>>::futures) { (void)(results); this->~SplitStorageMetricsActorState(); static_cast<SplitStorageMetricsActor*>(this)->destroy(); return 0; }
															#line 39794 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SplitStorageMetricsActor*>(this)->SAV< Standalone<VectorRef<KeyRef>> >::value()) Standalone<VectorRef<KeyRef>>(std::move(results)); // state_var_RVO
		this->~SplitStorageMetricsActorState();
		static_cast<SplitStorageMetricsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1(int loopDepth) 
	{
															#line 8035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(i < locations.size()))
															#line 39813 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 8036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		SplitMetricsRequest req(locations[i].range, limit, used, estimated, i == locations.size() - 1);
															#line 8037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<SplitMetricsReply> __when_expr_2 = loadBalance(locations[i].locations->locations(), &StorageServerInterface::splitMetrics, req, TaskPriority::DataDistribution);
															#line 8037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 39823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont1loopBody1when1(__when_expr_2.get(), loopDepth); };
		static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 3;
															#line 8037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >*>(static_cast<SplitStorageMetricsActor*>(this)));
															#line 39828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(SplitMetricsReply const& res,int loopDepth) 
	{
															#line 8041 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size() && res.splits[0] <= results.back())
															#line 39850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT_WE_THINK( false);
															#line 8046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1cont1Catch1(all_alternatives_failed(), std::max(0, loopDepth - 1));
															#line 39856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size())
															#line 39860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.append(results.arena(), res.splits.begin(), res.splits.size());
															#line 8050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.arena().dependsOn(res.splits.arena());
															#line 39866 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		used = res.used;
															#line 8035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i++;
															#line 39872 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1cont1(SplitMetricsReply && res,int loopDepth) 
	{
															#line 8041 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size() && res.splits[0] <= results.back())
															#line 39881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT_WE_THINK( false);
															#line 8046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1cont1Catch1(all_alternatives_failed(), std::max(0, loopDepth - 1));
															#line 39887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (res.splits.size())
															#line 39891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8049 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.append(results.arena(), res.splits.begin(), res.splits.size());
															#line 8050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.arena().dependsOn(res.splits.arena());
															#line 39897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8052 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		used = res.used;
															#line 8035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		i++;
															#line 39903 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(SplitMetricsReply const& res,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont1(res, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1loopBody1when1(SplitMetricsReply && res,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1loopBody1cont1(std::move(res), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<SplitStorageMetricsActor*>(this)->ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >::remove();

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >*,SplitMetricsReply const& value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >*,SplitMetricsReply && value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >*,Error err) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state > 0) static_cast<SplitStorageMetricsActor*>(this)->actor_wait_state = 0;
		static_cast<SplitStorageMetricsActor*>(this)->ActorCallback< SplitStorageMetricsActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< SplitStorageMetricsActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< SplitStorageMetricsActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics limit;
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics estimated;
															#line 8008 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 8010 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 8021 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageMetrics used;
															#line 8022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Standalone<VectorRef<KeyRef>> results;
															#line 8034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int i;
															#line 40064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via splitStorageMetrics()
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SplitStorageMetricsActor final : public Actor<Standalone<VectorRef<KeyRef>>>, public ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< SplitStorageMetricsActor, 1, Void >, public ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >, public ActorCallback< SplitStorageMetricsActor, 3, Void >, public FastAllocated<SplitStorageMetricsActor>, public SplitStorageMetricsActorState<SplitStorageMetricsActor> {
															#line 40069 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SplitStorageMetricsActor>::operator new;
	using FastAllocated<SplitStorageMetricsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<KeyRef>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< SplitStorageMetricsActor, 1, Void >;
friend struct ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >;
friend struct ActorCallback< SplitStorageMetricsActor, 3, Void >;
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SplitStorageMetricsActor(Database const& cx,KeyRange const& keys,StorageMetrics const& limit,StorageMetrics const& estimated) 
															#line 40083 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Standalone<VectorRef<KeyRef>>>(),
		   SplitStorageMetricsActorState<SplitStorageMetricsActor>(cx, keys, limit, estimated)
	{
		fdb_probe_actor_enter("splitStorageMetrics", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("splitStorageMetrics");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("splitStorageMetrics", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SplitStorageMetricsActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SplitStorageMetricsActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< SplitStorageMetricsActor, 2, SplitMetricsReply >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< SplitStorageMetricsActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Standalone<VectorRef<KeyRef>>> splitStorageMetrics( Database const& cx, KeyRange const& keys, StorageMetrics const& limit, StorageMetrics const& estimated ) {
															#line 8004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Standalone<VectorRef<KeyRef>>>(new SplitStorageMetricsActor(cx, keys, limit, estimated));
															#line 40114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Standalone<VectorRef<KeyRef>>> DatabaseContext::splitStorageMetrics(KeyRange const& keys,
                                                                           StorageMetrics const& limit,
                                                                           StorageMetrics const& estimated) {
	return ::splitStorageMetrics(Database(Reference<DatabaseContext>::addRef(this)), keys, limit, estimated);
}

void Transaction::checkDeferredError() const {
	trState->cx->checkDeferredError();
}

Reference<TransactionLogInfo> Transaction::createTrLogInfoProbabilistically(const Database& cx) {
	if (!cx->isError()) {
		double clientSamplingProbability =
		    cx->globalConfig->get<double>(fdbClientInfoTxnSampleRate, CLIENT_KNOBS->CSI_SAMPLING_PROBABILITY);
		if (((networkOptions.logClientInfo.present() && networkOptions.logClientInfo.get()) || BUGGIFY) &&
		    deterministicRandom()->random01() < clientSamplingProbability &&
		    (!g_network->isSimulated() || !g_simulator.speedUpSimulation)) {
			return makeReference<TransactionLogInfo>(TransactionLogInfo::DATABASE);
		}
	}

	return Reference<TransactionLogInfo>();
}

void Transaction::setTransactionID(uint64_t id) {
	ASSERT(getSize() == 0);
	trState->spanID = SpanID(id, trState->spanID.second());
}

void Transaction::setToken(uint64_t token) {
	ASSERT(getSize() == 0);
	trState->spanID = SpanID(trState->spanID.first(), token);
}

void enableClientInfoLogging() {
	ASSERT(networkOptions.logClientInfo.present() == false);
	networkOptions.logClientInfo = true;
	TraceEvent(SevInfo, "ClientInfoLoggingEnabled").log();
}

															#line 40159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via snapCreate()
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SnapCreateActor>
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SnapCreateActorState {
															#line 40166 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SnapCreateActorState(Database const& cx,Standalone<StringRef> const& snapCmd,UID const& snapUID) 
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   snapCmd(snapCmd),
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   snapUID(snapUID)
															#line 40177 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("snapCreate", reinterpret_cast<unsigned long>(this));

	}
	~SnapCreateActorState() 
	{
		fdb_probe_actor_destroy("snapCreate", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8119 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("SnapCreateEnter").detail("SnapCmd", snapCmd).detail("UID", snapUID);
															#line 40192 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			try {
															#line 8121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				;
															#line 40196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SnapCreateActorState();
		static_cast<SnapCreateActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 8135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("SnapCreateError").error(e).detail("SnapCmd", snapCmd.toString()).detail("UID", snapUID);
															#line 8136 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 40228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 8123 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = cx->onProxiesChanged();
															#line 8122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SnapCreateActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 40251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 8124 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = basicLoadBalance(cx->getCommitProxies(UseProvisionalProxies::False), &CommitProxyInterface::proxySnapReq, ProxySnapRequest(snapCmd, snapUID, snapUID), cx->taskID, AtMostOnce::True);
															#line 40255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
		static_cast<SnapCreateActor*>(this)->actor_wait_state = 1;
															#line 8123 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SnapCreateActor, 0, Void >*>(static_cast<SnapCreateActor*>(this)));
															#line 8124 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SnapCreateActor, 1, Void >*>(static_cast<SnapCreateActor*>(this)));
															#line 40262 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
															#line 8129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("SnapCreateExit").detail("SnapCmd", snapCmd).detail("UID", snapUID);
															#line 8130 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SnapCreateActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SnapCreateActorState(); static_cast<SnapCreateActor*>(this)->destroy(); return 0; }
															#line 40291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SnapCreateActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SnapCreateActorState();
		static_cast<SnapCreateActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
															#line 8129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("SnapCreateExit").detail("SnapCmd", snapCmd).detail("UID", snapUID);
															#line 8130 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SnapCreateActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SnapCreateActorState(); static_cast<SnapCreateActor*>(this)->destroy(); return 0; }
															#line 40305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SnapCreateActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SnapCreateActorState();
		static_cast<SnapCreateActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SnapCreateActor*>(this)->actor_wait_state > 0) static_cast<SnapCreateActor*>(this)->actor_wait_state = 0;
		static_cast<SnapCreateActor*>(this)->ActorCallback< SnapCreateActor, 0, Void >::remove();
		static_cast<SnapCreateActor*>(this)->ActorCallback< SnapCreateActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SnapCreateActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("snapCreate", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("snapCreate", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SnapCreateActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("snapCreate", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("snapCreate", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SnapCreateActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("snapCreate", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("snapCreate", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SnapCreateActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("snapCreate", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("snapCreate", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SnapCreateActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("snapCreate", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("snapCreate", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SnapCreateActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("snapCreate", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("snapCreate", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Standalone<StringRef> snapCmd;
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID snapUID;
															#line 40416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via snapCreate()
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SnapCreateActor final : public Actor<Void>, public ActorCallback< SnapCreateActor, 0, Void >, public ActorCallback< SnapCreateActor, 1, Void >, public FastAllocated<SnapCreateActor>, public SnapCreateActorState<SnapCreateActor> {
															#line 40421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SnapCreateActor>::operator new;
	using FastAllocated<SnapCreateActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SnapCreateActor, 0, Void >;
friend struct ActorCallback< SnapCreateActor, 1, Void >;
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SnapCreateActor(Database const& cx,Standalone<StringRef> const& snapCmd,UID const& snapUID) 
															#line 40433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   SnapCreateActorState<SnapCreateActor>(cx, snapCmd, snapUID)
	{
		fdb_probe_actor_enter("snapCreate", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("snapCreate");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("snapCreate", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SnapCreateActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> snapCreate( Database const& cx, Standalone<StringRef> const& snapCmd, UID const& snapUID ) {
															#line 8118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new SnapCreateActor(cx, snapCmd, snapUID));
															#line 40461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 40466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via createCheckpointImpl()
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class T, class CreateCheckpointImplActor>
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CreateCheckpointImplActorState {
															#line 40473 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CreateCheckpointImplActorState(T const& tr,KeyRangeRef const& range,CheckpointFormat const& format) 
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : tr(tr),
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   format(format)
															#line 40484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("createCheckpointImpl", reinterpret_cast<unsigned long>(this));

	}
	~CreateCheckpointImplActorState() 
	{
		fdb_probe_actor_destroy("createCheckpointImpl", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(!tr->getTenant().present());
															#line 8143 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("CreateCheckpointTransactionBegin").detail("Range", range);
															#line 8145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<RangeResult> __when_expr_0 = krmGetRanges(tr, keyServersPrefix, range);
															#line 8145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 40505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state = 1;
															#line 8145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CreateCheckpointImplActor, 0, RangeResult >*>(static_cast<CreateCheckpointImplActor*>(this)));
															#line 40510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~CreateCheckpointImplActorState();
		static_cast<CreateCheckpointImplActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 8146 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!keyServers.more);
															#line 8148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<RangeResult> __when_expr_1 = tr->getRange(serverTagKeys, CLIENT_KNOBS->TOO_MANY);
															#line 8148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 40537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state = 2;
															#line 8148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< CreateCheckpointImplActor, 1, RangeResult >*>(static_cast<CreateCheckpointImplActor*>(this)));
															#line 40542 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(RangeResult const& __keyServers,int loopDepth) 
	{
															#line 8145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		keyServers = __keyServers;
															#line 40551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(RangeResult && __keyServers,int loopDepth) 
	{
		keyServers = std::move(__keyServers);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state > 0) static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state = 0;
		static_cast<CreateCheckpointImplActor*>(this)->ActorCallback< CreateCheckpointImplActor, 0, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< CreateCheckpointImplActor, 0, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CreateCheckpointImplActor, 0, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CreateCheckpointImplActor, 0, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 8149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!UIDtoTagMap.more && UIDtoTagMap.size() < CLIENT_KNOBS->TOO_MANY);
															#line 8151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < keyServers.size() - 1;++i) {
															#line 8152 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			KeyRangeRef shard(keyServers[i].key, keyServers[i + 1].key);
															#line 8153 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::vector<UID> src;
															#line 8154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::vector<UID> dest;
															#line 8155 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			decodeKeyServersValue(UIDtoTagMap, keyServers[i].value, src, dest);
															#line 8159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			const UID checkpointID = deterministicRandom()->randomUniqueID();
															#line 8160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int idx = 0;idx < src.size();++idx) {
															#line 8161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				CheckpointMetaData checkpoint(shard & range, format, src[idx], checkpointID);
															#line 8162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				checkpoint.setState(CheckpointMetaData::Pending);
															#line 8163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr->set(checkpointKeyFor(checkpointID), checkpointValue(checkpoint));
															#line 40638 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8166 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("CreateCheckpointTransactionShard") .detail("Shard", shard) .detail("SrcServers", describe(src)) .detail("ServerSelected", describe(src)) .detail("CheckpointKey", checkpointKeyFor(checkpointID)) .detail("ReadVersion", tr->getReadVersion().get());
															#line 40642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CreateCheckpointImplActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CreateCheckpointImplActorState(); static_cast<CreateCheckpointImplActor*>(this)->destroy(); return 0; }
															#line 40646 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CreateCheckpointImplActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CreateCheckpointImplActorState();
		static_cast<CreateCheckpointImplActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(RangeResult const& __UIDtoTagMap,int loopDepth) 
	{
															#line 8148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		UIDtoTagMap = __UIDtoTagMap;
															#line 40658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(RangeResult && __UIDtoTagMap,int loopDepth) 
	{
		UIDtoTagMap = std::move(__UIDtoTagMap);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state > 0) static_cast<CreateCheckpointImplActor*>(this)->actor_wait_state = 0;
		static_cast<CreateCheckpointImplActor*>(this)->ActorCallback< CreateCheckpointImplActor, 1, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< CreateCheckpointImplActor, 1, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< CreateCheckpointImplActor, 1, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< CreateCheckpointImplActor, 1, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createCheckpointImpl", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	T tr;
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeRef range;
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CheckpointFormat format;
															#line 8145 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RangeResult keyServers;
															#line 8148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RangeResult UIDtoTagMap;
															#line 40731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via createCheckpointImpl()
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class T>
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CreateCheckpointImplActor final : public Actor<Void>, public ActorCallback< CreateCheckpointImplActor<T>, 0, RangeResult >, public ActorCallback< CreateCheckpointImplActor<T>, 1, RangeResult >, public FastAllocated<CreateCheckpointImplActor<T>>, public CreateCheckpointImplActorState<T, CreateCheckpointImplActor<T>> {
															#line 40738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<CreateCheckpointImplActor<T>>::operator new;
	using FastAllocated<CreateCheckpointImplActor<T>>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< CreateCheckpointImplActor<T>, 0, RangeResult >;
friend struct ActorCallback< CreateCheckpointImplActor<T>, 1, RangeResult >;
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CreateCheckpointImplActor(T const& tr,KeyRangeRef const& range,CheckpointFormat const& format) 
															#line 40750 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   CreateCheckpointImplActorState<T, CreateCheckpointImplActor<T>>(tr, range, format)
	{
		fdb_probe_actor_enter("createCheckpointImpl", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("createCheckpointImpl");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("createCheckpointImpl", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< CreateCheckpointImplActor<T>, 0, RangeResult >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< CreateCheckpointImplActor<T>, 1, RangeResult >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class T>
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> createCheckpointImpl( T const& tr, KeyRangeRef const& range, CheckpointFormat const& format ) {
															#line 8140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new CreateCheckpointImplActor<T>(tr, range, format));
															#line 40781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8176 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> createCheckpoint(Reference<ReadYourWritesTransaction> tr, KeyRangeRef range, CheckpointFormat format) {
	return holdWhile(tr, createCheckpointImpl(tr, range, format));
}

Future<Void> createCheckpoint(Transaction* tr, KeyRangeRef range, CheckpointFormat format) {
	return createCheckpointImpl(tr, range, format);
}

// Gets CheckpointMetaData of the specific keyrange, version and format from one of the storage servers, if none of the
// servers have the checkpoint, a checkpoint_not_found error is returned.
															#line 40796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getCheckpointMetaDataInternal()
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetCheckpointMetaDataInternalActor>
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCheckpointMetaDataInternalActorState {
															#line 40803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCheckpointMetaDataInternalActorState(GetCheckpointRequest const& req,Reference<LocationInfo> const& alternatives,double const& timeout) 
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : req(req),
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   alternatives(alternatives),
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   timeout(timeout)
															#line 40814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this));

	}
	~GetCheckpointMetaDataInternalActorState() 
	{
		fdb_probe_actor_destroy("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8190 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("GetCheckpointMetaDataInternalBegin") .detail("Range", req.range) .detail("Version", req.version) .detail("Format", static_cast<int>(req.format)) .detail("Locations", alternatives->description());
															#line 8196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			futures = std::vector<Future<ErrorOr<CheckpointMetaData>>>();
															#line 8197 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			index = 0;
															#line 8198 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(index = 0;index < alternatives->size();++index) {
															#line 8200 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				futures.push_back(errorOr(timeoutError(alternatives->getInterface(index).checkpoint.getReply(req), timeout)));
															#line 40837 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8203 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			error = Optional<Error>();
															#line 8204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = waitForAll(futures);
															#line 8204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetCheckpointMetaDataInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 40845 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetCheckpointMetaDataInternalActor*>(this)->actor_wait_state = 1;
															#line 8204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >*>(static_cast<GetCheckpointMetaDataInternalActor*>(this)));
															#line 40850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetCheckpointMetaDataInternalActorState();
		static_cast<GetCheckpointMetaDataInternalActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 8205 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("GetCheckpointMetaDataInternalWaitEnd").detail("Range", req.range).detail("Version", req.version);
															#line 8207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(index = 0;index < futures.size();++index) {
															#line 8208 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!futures[index].isReady())
															#line 40877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8209 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				error = timed_out();
															#line 8210 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent("GetCheckpointMetaDataInternalSSTimeout") .detail("Range", req.range) .detail("Version", req.version) .detail("StorageServer", alternatives->getInterface(index).uniqueID);
															#line 40883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				continue;
			}
															#line 8217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (futures[index].get().isError())
															#line 40888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				const Error& e = futures[index].get().getError();
															#line 8219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent("GetCheckpointMetaDataInternalError") .errorUnsuppressed(e) .detail("Range", req.range) .detail("Version", req.version) .detail("StorageServer", alternatives->getInterface(index).uniqueID);
															#line 8224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() != error_code_checkpoint_not_found || !error.present())
															#line 40896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					error = e;
															#line 40900 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
			else
			{
															#line 8228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<GetCheckpointMetaDataInternalActor*>(this)->SAV<CheckpointMetaData>::futures) { (void)(futures[index].get().get()); this->~GetCheckpointMetaDataInternalActorState(); static_cast<GetCheckpointMetaDataInternalActor*>(this)->destroy(); return 0; }
															#line 40907 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<GetCheckpointMetaDataInternalActor*>(this)->SAV< CheckpointMetaData >::value()) CheckpointMetaData(futures[index].get().get());
				this->~GetCheckpointMetaDataInternalActorState();
				static_cast<GetCheckpointMetaDataInternalActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
		}
															#line 8232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(error.present());
															#line 8233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1Catch1(error.get(), loopDepth);
															#line 40918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 8205 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("GetCheckpointMetaDataInternalWaitEnd").detail("Range", req.range).detail("Version", req.version);
															#line 8207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(index = 0;index < futures.size();++index) {
															#line 8208 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!futures[index].isReady())
															#line 40930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8209 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				error = timed_out();
															#line 8210 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent("GetCheckpointMetaDataInternalSSTimeout") .detail("Range", req.range) .detail("Version", req.version) .detail("StorageServer", alternatives->getInterface(index).uniqueID);
															#line 40936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				continue;
			}
															#line 8217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (futures[index].get().isError())
															#line 40941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				const Error& e = futures[index].get().getError();
															#line 8219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent("GetCheckpointMetaDataInternalError") .errorUnsuppressed(e) .detail("Range", req.range) .detail("Version", req.version) .detail("StorageServer", alternatives->getInterface(index).uniqueID);
															#line 8224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() != error_code_checkpoint_not_found || !error.present())
															#line 40949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					error = e;
															#line 40953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
			else
			{
															#line 8228 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<GetCheckpointMetaDataInternalActor*>(this)->SAV<CheckpointMetaData>::futures) { (void)(futures[index].get().get()); this->~GetCheckpointMetaDataInternalActorState(); static_cast<GetCheckpointMetaDataInternalActor*>(this)->destroy(); return 0; }
															#line 40960 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<GetCheckpointMetaDataInternalActor*>(this)->SAV< CheckpointMetaData >::value()) CheckpointMetaData(futures[index].get().get());
				this->~GetCheckpointMetaDataInternalActorState();
				static_cast<GetCheckpointMetaDataInternalActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
		}
															#line 8232 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(error.present());
															#line 8233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1Catch1(error.get(), loopDepth);
															#line 40971 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetCheckpointMetaDataInternalActor*>(this)->actor_wait_state > 0) static_cast<GetCheckpointMetaDataInternalActor*>(this)->actor_wait_state = 0;
		static_cast<GetCheckpointMetaDataInternalActor*>(this)->ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCheckpointRequest req;
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<LocationInfo> alternatives;
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double timeout;
															#line 8196 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<ErrorOr<CheckpointMetaData>>> futures;
															#line 8197 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int index;
															#line 8203 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Optional<Error> error;
															#line 41050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getCheckpointMetaDataInternal()
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCheckpointMetaDataInternalActor final : public Actor<CheckpointMetaData>, public ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >, public FastAllocated<GetCheckpointMetaDataInternalActor>, public GetCheckpointMetaDataInternalActorState<GetCheckpointMetaDataInternalActor> {
															#line 41055 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetCheckpointMetaDataInternalActor>::operator new;
	using FastAllocated<GetCheckpointMetaDataInternalActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<CheckpointMetaData>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >;
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCheckpointMetaDataInternalActor(GetCheckpointRequest const& req,Reference<LocationInfo> const& alternatives,double const& timeout) 
															#line 41066 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<CheckpointMetaData>(),
		   GetCheckpointMetaDataInternalActorState<GetCheckpointMetaDataInternalActor>(req, alternatives, timeout)
	{
		fdb_probe_actor_enter("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getCheckpointMetaDataInternal");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getCheckpointMetaDataInternal", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetCheckpointMetaDataInternalActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<CheckpointMetaData> getCheckpointMetaDataInternal( GetCheckpointRequest const& req, Reference<LocationInfo> const& alternatives, double const& timeout ) {
															#line 8187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<CheckpointMetaData>(new GetCheckpointMetaDataInternalActor(req, alternatives, timeout));
															#line 41094 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 41099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getCheckpointMetaData()
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetCheckpointMetaDataActor>
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCheckpointMetaDataActorState {
															#line 41106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCheckpointMetaDataActorState(Database const& cx,KeyRange const& keys,Version const& version,CheckpointFormat const& format,double const& timeout) 
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   keys(keys),
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   format(format),
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   timeout(timeout),
															#line 8241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:GetCheckpoint"_loc),
															#line 8242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   index(0),
															#line 8243 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   futures()
															#line 41127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getCheckpointMetaData", reinterpret_cast<unsigned long>(this));

	}
	~GetCheckpointMetaDataActorState() 
	{
		fdb_probe_actor_destroy("getCheckpointMetaData", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8245 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 41142 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetCheckpointMetaDataActorState();
		static_cast<GetCheckpointMetaDataActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 8297 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<CheckpointMetaData> res;
															#line 8298 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(index = 0;index < futures.size();++index) {
															#line 8299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("GetCheckpointShardEnd").detail("Checkpoint", futures[index].get().toString());
															#line 8300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			res.push_back(futures[index].get());
															#line 41171 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8302 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetCheckpointMetaDataActor*>(this)->SAV<std::vector<CheckpointMetaData>>::futures) { (void)(res); this->~GetCheckpointMetaDataActorState(); static_cast<GetCheckpointMetaDataActor*>(this)->destroy(); return 0; }
															#line 41175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetCheckpointMetaDataActor*>(this)->SAV< std::vector<CheckpointMetaData> >::value()) std::vector<CheckpointMetaData>(res);
		this->~GetCheckpointMetaDataActorState();
		static_cast<GetCheckpointMetaDataActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 8246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("GetCheckpointBegin") .detail("Range", keys.toString()) .detail("Version", version) .detail("Format", static_cast<int>(format));
															#line 41194 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 8252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, CLIENT_KNOBS->TOO_MANY, Reverse::False, &StorageServerInterface::checkpoint, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 8252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 41200 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state = 1;
															#line 8252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetCheckpointMetaDataActor*>(this)));
															#line 41205 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 8286 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("GetCheckpointError").errorUnsuppressed(e).detail("Range", keys.toString());
															#line 8287 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed || e.code() == error_code_connection_failed || e.code() == error_code_broken_promise)
															#line 41242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->invalidateCache(KeyRef(), keys);
															#line 8290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_4 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY);
															#line 8290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 41250 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
				static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state = 3;
															#line 8290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetCheckpointMetaDataActor, 4, Void >*>(static_cast<GetCheckpointMetaDataActor*>(this)));
															#line 41255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 8292 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 41262 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
															#line 8264 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		futures.clear();
															#line 8265 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(index = 0;index < locations.size();++index) {
															#line 8266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			futures.push_back(getCheckpointMetaDataInternal( GetCheckpointRequest(version, keys, format), locations[index].locations, timeout));
															#line 8268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("GetCheckpointShardBegin") .detail("Range", locations[index].range) .detail("Version", version) .detail("StorageServers", locations[index].locations->description());
															#line 41283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = cx->connectionFileChanged();
															#line 8274 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 41289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
															#line 8278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = waitForAll(futures);
															#line 41293 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when2(__when_expr_2.get(), loopDepth); };
															#line 8281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = delay(timeout);
															#line 41297 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont2when3(__when_expr_3.get(), loopDepth); };
		static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state = 2;
															#line 8275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetCheckpointMetaDataActor, 1, Void >*>(static_cast<GetCheckpointMetaDataActor*>(this)));
															#line 8278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetCheckpointMetaDataActor, 2, Void >*>(static_cast<GetCheckpointMetaDataActor*>(this)));
															#line 8281 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetCheckpointMetaDataActor, 3, Void >*>(static_cast<GetCheckpointMetaDataActor*>(this)));
															#line 41306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 8252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 41315 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state > 0) static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state = 0;
		static_cast<GetCheckpointMetaDataActor*>(this)->ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
															#line 8276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(KeyRef(), keys);
															#line 41388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
															#line 8276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		cx->invalidateCache(KeyRef(), keys);
															#line 41397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(Void const& _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(Void && _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2when3(Void const& _,int loopDepth) 
	{
															#line 8282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("GetCheckpointTimeout").detail("Range", keys).detail("Version", version);
															#line 41418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when3(Void && _,int loopDepth) 
	{
															#line 8282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("GetCheckpointTimeout").detail("Range", keys).detail("Version", version);
															#line 41427 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state > 0) static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state = 0;
		static_cast<GetCheckpointMetaDataActor*>(this)->ActorCallback< GetCheckpointMetaDataActor, 1, Void >::remove();
		static_cast<GetCheckpointMetaDataActor*>(this)->ActorCallback< GetCheckpointMetaDataActor, 2, Void >::remove();
		static_cast<GetCheckpointMetaDataActor*>(this)->ActorCallback< GetCheckpointMetaDataActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetCheckpointMetaDataActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetCheckpointMetaDataActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when3(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetCheckpointMetaDataActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state > 0) static_cast<GetCheckpointMetaDataActor*>(this)->actor_wait_state = 0;
		static_cast<GetCheckpointMetaDataActor*>(this)->ActorCallback< GetCheckpointMetaDataActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetCheckpointMetaDataActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetCheckpointMetaDataActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CheckpointFormat format;
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double timeout;
															#line 8241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 8242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int index;
															#line 8243 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<CheckpointMetaData>> futures;
															#line 8252 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 41687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getCheckpointMetaData()
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetCheckpointMetaDataActor final : public Actor<std::vector<CheckpointMetaData>>, public ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetCheckpointMetaDataActor, 1, Void >, public ActorCallback< GetCheckpointMetaDataActor, 2, Void >, public ActorCallback< GetCheckpointMetaDataActor, 3, Void >, public ActorCallback< GetCheckpointMetaDataActor, 4, Void >, public FastAllocated<GetCheckpointMetaDataActor>, public GetCheckpointMetaDataActorState<GetCheckpointMetaDataActor> {
															#line 41692 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetCheckpointMetaDataActor>::operator new;
	using FastAllocated<GetCheckpointMetaDataActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<std::vector<CheckpointMetaData>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetCheckpointMetaDataActor, 1, Void >;
friend struct ActorCallback< GetCheckpointMetaDataActor, 2, Void >;
friend struct ActorCallback< GetCheckpointMetaDataActor, 3, Void >;
friend struct ActorCallback< GetCheckpointMetaDataActor, 4, Void >;
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetCheckpointMetaDataActor(Database const& cx,KeyRange const& keys,Version const& version,CheckpointFormat const& format,double const& timeout) 
															#line 41707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<std::vector<CheckpointMetaData>>(),
		   GetCheckpointMetaDataActorState<GetCheckpointMetaDataActor>(cx, keys, version, format, timeout)
	{
		fdb_probe_actor_enter("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getCheckpointMetaData");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getCheckpointMetaData", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetCheckpointMetaDataActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetCheckpointMetaDataActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetCheckpointMetaDataActor, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<std::vector<CheckpointMetaData>> getCheckpointMetaData( Database const& cx, KeyRange const& keys, Version const& version, CheckpointFormat const& format, double const& timeout ) {
															#line 8236 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<std::vector<CheckpointMetaData>>(new GetCheckpointMetaDataActor(cx, keys, version, format, timeout));
															#line 41737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 41742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via checkSafeExclusions()
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class CheckSafeExclusionsActor>
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CheckSafeExclusionsActorState {
															#line 41749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CheckSafeExclusionsActorState(Database const& cx,std::vector<AddressExclusion> const& exclusions) 
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   exclusions(exclusions)
															#line 41758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("checkSafeExclusions", reinterpret_cast<unsigned long>(this));

	}
	~CheckSafeExclusionsActorState() 
	{
		fdb_probe_actor_destroy("checkSafeExclusions", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("ExclusionSafetyCheckBegin") .detail("NumExclusion", exclusions.size()) .detail("Exclusions", describe(exclusions));
															#line 8309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ddCheck = bool();
															#line 41775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			try {
															#line 8311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				;
															#line 41779 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~CheckSafeExclusionsActorState();
		static_cast<CheckSafeExclusionsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 8333 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("ExclusionSafetyCheckCoordinators").log();
															#line 8334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		coordinatorList = ClientCoordinators(cx->getConnectionRecord());
															#line 8335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		leaderServers = std::vector<Future<Optional<LeaderInfo>>>();
															#line 8336 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		leaderServers.reserve(coordinatorList.clientLeaderServers.size());
															#line 8337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < coordinatorList.clientLeaderServers.size();i++) {
															#line 8338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (coordinatorList.clientLeaderServers[i].hostname.present())
															#line 41818 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8339 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				leaderServers.push_back(retryGetReplyFromHostname(GetLeaderRequest(coordinatorList.clusterKey, UID()), coordinatorList.clientLeaderServers[i].hostname.get(), WLTOKEN_CLIENTLEADERREG_GETLEADER, TaskPriority::CoordinationReply));
															#line 41822 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			else
			{
															#line 8344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				leaderServers.push_back(retryBrokenPromise(coordinatorList.clientLeaderServers[i].getLeader, GetLeaderRequest(coordinatorList.clusterKey, UID()), TaskPriority::CoordinationReply));
															#line 41828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 8351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = smartQuorum(leaderServers, leaderServers.size() / 2 + 1, 1.0);
															#line 8350 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 41835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when1(__when_expr_2.get(), loopDepth); };
															#line 8352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = delay(3.0);
															#line 41839 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1when2(__when_expr_3.get(), loopDepth); };
		static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state = 2;
															#line 8351 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< CheckSafeExclusionsActor, 2, Void >*>(static_cast<CheckSafeExclusionsActor*>(this)));
															#line 8352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< CheckSafeExclusionsActor, 3, Void >*>(static_cast<CheckSafeExclusionsActor*>(this)));
															#line 41846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 8325 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_actor_cancelled)
															#line 41856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8326 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent("ExclusionSafetyCheckError") .error(e) .detail("NumExclusion", exclusions.size()) .detail("Exclusions", describe(exclusions));
															#line 41860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, loopDepth);
															#line 41864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 8313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = cx->onProxiesChanged();
															#line 8312 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 41893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 8314 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<ExclusionSafetyCheckReply> __when_expr_1 = basicLoadBalance(cx->getCommitProxies(UseProvisionalProxies::False), &CommitProxyInterface::exclusionSafetyCheckReq, ExclusionSafetyCheckRequest(exclusions), cx->taskID);
															#line 41897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
		static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state = 1;
															#line 8313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CheckSafeExclusionsActor, 0, Void >*>(static_cast<CheckSafeExclusionsActor*>(this)));
															#line 8314 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< CheckSafeExclusionsActor, 1, ExclusionSafetyCheckReply >*>(static_cast<CheckSafeExclusionsActor*>(this)));
															#line 41904 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(ExclusionSafetyCheckReply const& _ddCheck,int loopDepth) 
	{
															#line 8319 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ddCheck = _ddCheck.safe;
															#line 41944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1when2(ExclusionSafetyCheckReply && _ddCheck,int loopDepth) 
	{
															#line 8319 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ddCheck = _ddCheck.safe;
															#line 41953 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state > 0) static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state = 0;
		static_cast<CheckSafeExclusionsActor*>(this)->ActorCallback< CheckSafeExclusionsActor, 0, Void >::remove();
		static_cast<CheckSafeExclusionsActor*>(this)->ActorCallback< CheckSafeExclusionsActor, 1, ExclusionSafetyCheckReply >::remove();

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CheckSafeExclusionsActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 1, ExclusionSafetyCheckReply >*,ExclusionSafetyCheckReply const& value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 1, ExclusionSafetyCheckReply >*,ExclusionSafetyCheckReply && value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< CheckSafeExclusionsActor, 1, ExclusionSafetyCheckReply >*,Error err) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont4(int loopDepth) 
	{
															#line 8357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int attemptCoordinatorExclude = 0;
															#line 8358 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int coordinatorsUnavailable = 0;
															#line 8359 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < leaderServers.size();i++) {
															#line 8360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			NetworkAddress leaderAddress = coordinatorList.clientLeaderServers[i].getLeader.getEndpoint().getPrimaryAddress();
															#line 8362 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (leaderServers[i].isReady())
															#line 42080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8363 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if ((std::count( exclusions.begin(), exclusions.end(), AddressExclusion(leaderAddress.ip, leaderAddress.port)) || std::count(exclusions.begin(), exclusions.end(), AddressExclusion(leaderAddress.ip))))
															#line 42084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8366 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					attemptCoordinatorExclude++;
															#line 42088 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
			else
			{
															#line 8369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				coordinatorsUnavailable++;
															#line 42095 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 8372 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int faultTolerance = (leaderServers.size() - 1) / 2 - coordinatorsUnavailable;
															#line 8373 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool coordinatorCheck = (attemptCoordinatorExclude <= faultTolerance);
															#line 8374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("ExclusionSafetyCheckFinish") .detail("CoordinatorListSize", leaderServers.size()) .detail("NumExclusions", exclusions.size()) .detail("FaultTolerance", faultTolerance) .detail("AttemptCoordinatorExclude", attemptCoordinatorExclude) .detail("CoordinatorCheck", coordinatorCheck) .detail("DataDistributorCheck", ddCheck);
															#line 8382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CheckSafeExclusionsActor*>(this)->SAV<bool>::futures) { (void)((ddCheck && coordinatorCheck)); this->~CheckSafeExclusionsActorState(); static_cast<CheckSafeExclusionsActor*>(this)->destroy(); return 0; }
															#line 42106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CheckSafeExclusionsActor*>(this)->SAV< bool >::value()) bool((ddCheck && coordinatorCheck));
		this->~CheckSafeExclusionsActorState();
		static_cast<CheckSafeExclusionsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when2(Void const& _,int loopDepth) 
	{
															#line 8353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("ExclusionSafetyCheckNoCoordinatorQuorum").log();
															#line 8354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CheckSafeExclusionsActor*>(this)->SAV<bool>::futures) { (void)(false); this->~CheckSafeExclusionsActorState(); static_cast<CheckSafeExclusionsActor*>(this)->destroy(); return 0; }
															#line 42132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CheckSafeExclusionsActor*>(this)->SAV< bool >::value()) bool(false);
		this->~CheckSafeExclusionsActorState();
		static_cast<CheckSafeExclusionsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when2(Void && _,int loopDepth) 
	{
															#line 8353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		TraceEvent("ExclusionSafetyCheckNoCoordinatorQuorum").log();
															#line 8354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CheckSafeExclusionsActor*>(this)->SAV<bool>::futures) { (void)(false); this->~CheckSafeExclusionsActorState(); static_cast<CheckSafeExclusionsActor*>(this)->destroy(); return 0; }
															#line 42146 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CheckSafeExclusionsActor*>(this)->SAV< bool >::value()) bool(false);
		this->~CheckSafeExclusionsActorState();
		static_cast<CheckSafeExclusionsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state > 0) static_cast<CheckSafeExclusionsActor*>(this)->actor_wait_state = 0;
		static_cast<CheckSafeExclusionsActor*>(this)->ActorCallback< CheckSafeExclusionsActor, 2, Void >::remove();
		static_cast<CheckSafeExclusionsActor*>(this)->ActorCallback< CheckSafeExclusionsActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< CheckSafeExclusionsActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< CheckSafeExclusionsActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< CheckSafeExclusionsActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<AddressExclusion> exclusions;
															#line 8309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool ddCheck;
															#line 8334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ClientCoordinators coordinatorList;
															#line 8335 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<Optional<LeaderInfo>>> leaderServers;
															#line 42261 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via checkSafeExclusions()
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CheckSafeExclusionsActor final : public Actor<bool>, public ActorCallback< CheckSafeExclusionsActor, 0, Void >, public ActorCallback< CheckSafeExclusionsActor, 1, ExclusionSafetyCheckReply >, public ActorCallback< CheckSafeExclusionsActor, 2, Void >, public ActorCallback< CheckSafeExclusionsActor, 3, Void >, public FastAllocated<CheckSafeExclusionsActor>, public CheckSafeExclusionsActorState<CheckSafeExclusionsActor> {
															#line 42266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<CheckSafeExclusionsActor>::operator new;
	using FastAllocated<CheckSafeExclusionsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<bool>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< CheckSafeExclusionsActor, 0, Void >;
friend struct ActorCallback< CheckSafeExclusionsActor, 1, ExclusionSafetyCheckReply >;
friend struct ActorCallback< CheckSafeExclusionsActor, 2, Void >;
friend struct ActorCallback< CheckSafeExclusionsActor, 3, Void >;
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CheckSafeExclusionsActor(Database const& cx,std::vector<AddressExclusion> const& exclusions) 
															#line 42280 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<bool>(),
		   CheckSafeExclusionsActorState<CheckSafeExclusionsActor>(cx, exclusions)
	{
		fdb_probe_actor_enter("checkSafeExclusions", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("checkSafeExclusions");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("checkSafeExclusions", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< CheckSafeExclusionsActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< CheckSafeExclusionsActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<bool> checkSafeExclusions( Database const& cx, std::vector<AddressExclusion> const& exclusions ) {
															#line 8305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<bool>(new CheckSafeExclusionsActor(cx, exclusions));
															#line 42309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

// returns true if we can connect to the given worker interface
															#line 42315 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via verifyInterfaceActor()
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class VerifyInterfaceActorActor>
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class VerifyInterfaceActorActorState {
															#line 42322 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	VerifyInterfaceActorActorState(Reference<FlowLock> const& connectLock,ClientWorkerInterface const& workerInterf) 
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : connectLock(connectLock),
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   workerInterf(workerInterf)
															#line 42331 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("verifyInterfaceActor", reinterpret_cast<unsigned long>(this));

	}
	~VerifyInterfaceActorActorState() 
	{
		fdb_probe_actor_destroy("verifyInterfaceActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8387 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = connectLock->take();
															#line 8387 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 42348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state = 1;
															#line 8387 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< VerifyInterfaceActorActor, 0, Void >*>(static_cast<VerifyInterfaceActorActor*>(this)));
															#line 42353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~VerifyInterfaceActorActorState();
		static_cast<VerifyInterfaceActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 8388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		releaser = FlowLock::Releaser(*connectLock);
															#line 8389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		leaderInterf = ClientLeaderRegInterface(workerInterf.address());
															#line 8391 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Optional<LeaderInfo>> __when_expr_1 = brokenPromiseToNever(leaderInterf.getLeader.getReply(GetLeaderRequest()));
															#line 8390 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 42382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
															#line 8395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->CLI_CONNECT_TIMEOUT);
															#line 42386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when2(__when_expr_2.get(), loopDepth); };
		static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state = 2;
															#line 8391 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >*>(static_cast<VerifyInterfaceActorActor*>(this)));
															#line 8395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< VerifyInterfaceActorActor, 2, Void >*>(static_cast<VerifyInterfaceActorActor*>(this)));
															#line 42393 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 8388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		releaser = FlowLock::Releaser(*connectLock);
															#line 8389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		leaderInterf = ClientLeaderRegInterface(workerInterf.address());
															#line 8391 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Optional<LeaderInfo>> __when_expr_1 = brokenPromiseToNever(leaderInterf.getLeader.getReply(GetLeaderRequest()));
															#line 8390 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 42408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
															#line 8395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = delay(CLIENT_KNOBS->CLI_CONNECT_TIMEOUT);
															#line 42412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when2(__when_expr_2.get(), loopDepth); };
		static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state = 2;
															#line 8391 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >*>(static_cast<VerifyInterfaceActorActor*>(this)));
															#line 8395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< VerifyInterfaceActorActor, 2, Void >*>(static_cast<VerifyInterfaceActorActor*>(this)));
															#line 42419 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state > 0) static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state = 0;
		static_cast<VerifyInterfaceActorActor*>(this)->ActorCallback< VerifyInterfaceActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< VerifyInterfaceActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< VerifyInterfaceActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< VerifyInterfaceActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1when1(Optional<LeaderInfo> const& rep,int loopDepth) 
	{
															#line 8393 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<VerifyInterfaceActorActor*>(this)->SAV<bool>::futures) { (void)(true); this->~VerifyInterfaceActorActorState(); static_cast<VerifyInterfaceActorActor*>(this)->destroy(); return 0; }
															#line 42491 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<VerifyInterfaceActorActor*>(this)->SAV< bool >::value()) bool(true);
		this->~VerifyInterfaceActorActorState();
		static_cast<VerifyInterfaceActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Optional<LeaderInfo> && rep,int loopDepth) 
	{
															#line 8393 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<VerifyInterfaceActorActor*>(this)->SAV<bool>::futures) { (void)(true); this->~VerifyInterfaceActorActorState(); static_cast<VerifyInterfaceActorActor*>(this)->destroy(); return 0; }
															#line 42503 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<VerifyInterfaceActorActor*>(this)->SAV< bool >::value()) bool(true);
		this->~VerifyInterfaceActorActorState();
		static_cast<VerifyInterfaceActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when2(Void const& _,int loopDepth) 
	{
															#line 8397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<VerifyInterfaceActorActor*>(this)->SAV<bool>::futures) { (void)(false); this->~VerifyInterfaceActorActorState(); static_cast<VerifyInterfaceActorActor*>(this)->destroy(); return 0; }
															#line 42515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<VerifyInterfaceActorActor*>(this)->SAV< bool >::value()) bool(false);
		this->~VerifyInterfaceActorActorState();
		static_cast<VerifyInterfaceActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when2(Void && _,int loopDepth) 
	{
															#line 8397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<VerifyInterfaceActorActor*>(this)->SAV<bool>::futures) { (void)(false); this->~VerifyInterfaceActorActorState(); static_cast<VerifyInterfaceActorActor*>(this)->destroy(); return 0; }
															#line 42527 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<VerifyInterfaceActorActor*>(this)->SAV< bool >::value()) bool(false);
		this->~VerifyInterfaceActorActorState();
		static_cast<VerifyInterfaceActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state > 0) static_cast<VerifyInterfaceActorActor*>(this)->actor_wait_state = 0;
		static_cast<VerifyInterfaceActorActor*>(this)->ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >::remove();
		static_cast<VerifyInterfaceActorActor*>(this)->ActorCallback< VerifyInterfaceActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >*,Optional<LeaderInfo> const& value) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >*,Optional<LeaderInfo> && value) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< VerifyInterfaceActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< VerifyInterfaceActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< VerifyInterfaceActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<FlowLock> connectLock;
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ClientWorkerInterface workerInterf;
															#line 8388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	FlowLock::Releaser releaser;
															#line 8389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ClientLeaderRegInterface leaderInterf;
															#line 42640 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via verifyInterfaceActor()
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class VerifyInterfaceActorActor final : public Actor<bool>, public ActorCallback< VerifyInterfaceActorActor, 0, Void >, public ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >, public ActorCallback< VerifyInterfaceActorActor, 2, Void >, public FastAllocated<VerifyInterfaceActorActor>, public VerifyInterfaceActorActorState<VerifyInterfaceActorActor> {
															#line 42645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<VerifyInterfaceActorActor>::operator new;
	using FastAllocated<VerifyInterfaceActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<bool>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< VerifyInterfaceActorActor, 0, Void >;
friend struct ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >;
friend struct ActorCallback< VerifyInterfaceActorActor, 2, Void >;
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	VerifyInterfaceActorActor(Reference<FlowLock> const& connectLock,ClientWorkerInterface const& workerInterf) 
															#line 42658 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<bool>(),
		   VerifyInterfaceActorActorState<VerifyInterfaceActorActor>(connectLock, workerInterf)
	{
		fdb_probe_actor_enter("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("verifyInterfaceActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("verifyInterfaceActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< VerifyInterfaceActorActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< VerifyInterfaceActorActor, 1, Optional<LeaderInfo> >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<bool> verifyInterfaceActor( Reference<FlowLock> const& connectLock, ClientWorkerInterface const& workerInterf ) {
															#line 8386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<bool>(new VerifyInterfaceActorActor(connectLock, workerInterf));
															#line 42687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 42692 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via rebootWorkerActor()
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class RebootWorkerActorActor>
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class RebootWorkerActorActorState {
															#line 42699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RebootWorkerActorActorState(DatabaseContext* const& cx,ValueRef const& addr,bool const& check,int const& duration) 
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   addr(addr),
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   check(check),
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   duration(duration)
															#line 42712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("rebootWorkerActor", reinterpret_cast<unsigned long>(this));

	}
	~RebootWorkerActorActorState() 
	{
		fdb_probe_actor_destroy("rebootWorkerActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8404 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (duration < 0)
															#line 42727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8405 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				duration = 0;
															#line 42731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8406 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!cx->getConnectionRecord())
															#line 42735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<RebootWorkerActorActor*>(this)->SAV<int64_t>::futures) { (void)(0); this->~RebootWorkerActorActorState(); static_cast<RebootWorkerActorActor*>(this)->destroy(); return 0; }
															#line 42739 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<RebootWorkerActorActor*>(this)->SAV< int64_t >::value()) int64_t(0);
				this->~RebootWorkerActorActorState();
				static_cast<RebootWorkerActorActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 8409 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<RangeResult> __when_expr_0 = getWorkerInterfaces(cx->getConnectionRecord());
															#line 8409 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<RebootWorkerActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 42749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<RebootWorkerActorActor*>(this)->actor_wait_state = 1;
															#line 8409 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< RebootWorkerActorActor, 0, RangeResult >*>(static_cast<RebootWorkerActorActor*>(this)));
															#line 42754 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~RebootWorkerActorActorState();
		static_cast<RebootWorkerActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(RangeResult const& kvs,int loopDepth) 
	{
															#line 8410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!kvs.more);
															#line 8412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		workerInterfaces = std::map<Key, ClientWorkerInterface>();
															#line 8413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& it : kvs ) {
															#line 8414 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ClientWorkerInterface workerInterf = BinaryReader::fromStringRef<ClientWorkerInterface>(it.value, IncludeVersion());
															#line 8416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Key primaryAddress = it.key.endsWith(LiteralStringRef(":tls")) ? it.key.removeSuffix(LiteralStringRef(":tls")) : it.key;
															#line 8418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			workerInterfaces[primaryAddress] = workerInterf;
															#line 8420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (workerInterf.reboot.getEndpoint().addresses.secondaryAddress.present())
															#line 42789 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				Key secondAddress = StringRef(workerInterf.reboot.getEndpoint().addresses.secondaryAddress.get().toString());
															#line 8423 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				secondAddress = secondAddress.endsWith(LiteralStringRef(":tls")) ? secondAddress.removeSuffix(LiteralStringRef(":tls")) : secondAddress;
															#line 8426 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				workerInterfaces[secondAddress] = workerInterf;
															#line 42797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 8430 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		addressesVec = std::vector<std::string>();
															#line 8431 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		boost::algorithm::split(addressesVec, addr.toString(), boost::is_any_of(","));
															#line 8433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Reference<FlowLock> connectLock(new FlowLock(CLIENT_KNOBS->CLI_CONNECT_PARALLELISM));
															#line 8434 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		verifyInterfs = std::vector<Future<bool>>();
															#line 8435 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& requestedAddress : addressesVec ) {
															#line 8437 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!workerInterfaces.count(Key(requestedAddress)))
															#line 42812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<RebootWorkerActorActor*>(this)->SAV<int64_t>::futures) { (void)(0); this->~RebootWorkerActorActorState(); static_cast<RebootWorkerActorActor*>(this)->destroy(); return 0; }
															#line 42816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<RebootWorkerActorActor*>(this)->SAV< int64_t >::value()) int64_t(0);
				this->~RebootWorkerActorActorState();
				static_cast<RebootWorkerActorActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 8440 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			verifyInterfs.push_back(verifyInterfaceActor(connectLock, workerInterfaces[Key(requestedAddress)]));
															#line 42824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitForAll(verifyInterfs);
															#line 8443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<RebootWorkerActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 42830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<RebootWorkerActorActor*>(this)->actor_wait_state = 2;
															#line 8443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< RebootWorkerActorActor, 1, Void >*>(static_cast<RebootWorkerActorActor*>(this)));
															#line 42835 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(RangeResult && kvs,int loopDepth) 
	{
															#line 8410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(!kvs.more);
															#line 8412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		workerInterfaces = std::map<Key, ClientWorkerInterface>();
															#line 8413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& it : kvs ) {
															#line 8414 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ClientWorkerInterface workerInterf = BinaryReader::fromStringRef<ClientWorkerInterface>(it.value, IncludeVersion());
															#line 8416 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Key primaryAddress = it.key.endsWith(LiteralStringRef(":tls")) ? it.key.removeSuffix(LiteralStringRef(":tls")) : it.key;
															#line 8418 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			workerInterfaces[primaryAddress] = workerInterf;
															#line 8420 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (workerInterf.reboot.getEndpoint().addresses.secondaryAddress.present())
															#line 42856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				Key secondAddress = StringRef(workerInterf.reboot.getEndpoint().addresses.secondaryAddress.get().toString());
															#line 8423 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				secondAddress = secondAddress.endsWith(LiteralStringRef(":tls")) ? secondAddress.removeSuffix(LiteralStringRef(":tls")) : secondAddress;
															#line 8426 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				workerInterfaces[secondAddress] = workerInterf;
															#line 42864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 8430 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		addressesVec = std::vector<std::string>();
															#line 8431 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		boost::algorithm::split(addressesVec, addr.toString(), boost::is_any_of(","));
															#line 8433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Reference<FlowLock> connectLock(new FlowLock(CLIENT_KNOBS->CLI_CONNECT_PARALLELISM));
															#line 8434 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		verifyInterfs = std::vector<Future<bool>>();
															#line 8435 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& requestedAddress : addressesVec ) {
															#line 8437 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!workerInterfaces.count(Key(requestedAddress)))
															#line 42879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<RebootWorkerActorActor*>(this)->SAV<int64_t>::futures) { (void)(0); this->~RebootWorkerActorActorState(); static_cast<RebootWorkerActorActor*>(this)->destroy(); return 0; }
															#line 42883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<RebootWorkerActorActor*>(this)->SAV< int64_t >::value()) int64_t(0);
				this->~RebootWorkerActorActorState();
				static_cast<RebootWorkerActorActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 8440 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			verifyInterfs.push_back(verifyInterfaceActor(connectLock, workerInterfaces[Key(requestedAddress)]));
															#line 42891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitForAll(verifyInterfs);
															#line 8443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<RebootWorkerActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 42897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<RebootWorkerActorActor*>(this)->actor_wait_state = 2;
															#line 8443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< RebootWorkerActorActor, 1, Void >*>(static_cast<RebootWorkerActorActor*>(this)));
															#line 42902 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(RangeResult const& kvs,int loopDepth) 
	{
		loopDepth = a_body1cont1(kvs, loopDepth);

		return loopDepth;
	}
	int a_body1when1(RangeResult && kvs,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(kvs), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<RebootWorkerActorActor*>(this)->actor_wait_state > 0) static_cast<RebootWorkerActorActor*>(this)->actor_wait_state = 0;
		static_cast<RebootWorkerActorActor*>(this)->ActorCallback< RebootWorkerActorActor, 0, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< RebootWorkerActorActor, 0, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< RebootWorkerActorActor, 0, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< RebootWorkerActorActor, 0, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(Void const& _,int loopDepth) 
	{
															#line 8444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& f : verifyInterfs ) {
															#line 8445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!f.get())
															#line 42976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<RebootWorkerActorActor*>(this)->SAV<int64_t>::futures) { (void)(0); this->~RebootWorkerActorActorState(); static_cast<RebootWorkerActorActor*>(this)->destroy(); return 0; }
															#line 42980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<RebootWorkerActorActor*>(this)->SAV< int64_t >::value()) int64_t(0);
				this->~RebootWorkerActorActorState();
				static_cast<RebootWorkerActorActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
		}
															#line 8449 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& address : addressesVec ) {
															#line 8451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			workerInterfaces[Key(address)].reboot.send(RebootRequest(false, check, duration));
															#line 42991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8453 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<RebootWorkerActorActor*>(this)->SAV<int64_t>::futures) { (void)(1); this->~RebootWorkerActorActorState(); static_cast<RebootWorkerActorActor*>(this)->destroy(); return 0; }
															#line 42995 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<RebootWorkerActorActor*>(this)->SAV< int64_t >::value()) int64_t(1);
		this->~RebootWorkerActorActorState();
		static_cast<RebootWorkerActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont4(Void && _,int loopDepth) 
	{
															#line 8444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& f : verifyInterfs ) {
															#line 8445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!f.get())
															#line 43009 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8446 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<RebootWorkerActorActor*>(this)->SAV<int64_t>::futures) { (void)(0); this->~RebootWorkerActorActorState(); static_cast<RebootWorkerActorActor*>(this)->destroy(); return 0; }
															#line 43013 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<RebootWorkerActorActor*>(this)->SAV< int64_t >::value()) int64_t(0);
				this->~RebootWorkerActorActorState();
				static_cast<RebootWorkerActorActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
		}
															#line 8449 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( const auto& address : addressesVec ) {
															#line 8451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			workerInterfaces[Key(address)].reboot.send(RebootRequest(false, check, duration));
															#line 43024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8453 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<RebootWorkerActorActor*>(this)->SAV<int64_t>::futures) { (void)(1); this->~RebootWorkerActorActorState(); static_cast<RebootWorkerActorActor*>(this)->destroy(); return 0; }
															#line 43028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<RebootWorkerActorActor*>(this)->SAV< int64_t >::value()) int64_t(1);
		this->~RebootWorkerActorActorState();
		static_cast<RebootWorkerActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<RebootWorkerActorActor*>(this)->actor_wait_state > 0) static_cast<RebootWorkerActorActor*>(this)->actor_wait_state = 0;
		static_cast<RebootWorkerActorActor*>(this)->ActorCallback< RebootWorkerActorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< RebootWorkerActorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< RebootWorkerActorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< RebootWorkerActorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("rebootWorkerActor", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ValueRef addr;
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool check;
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int duration;
															#line 8412 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::map<Key, ClientWorkerInterface> workerInterfaces;
															#line 8430 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<std::string> addressesVec;
															#line 8434 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<bool>> verifyInterfs;
															#line 43113 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via rebootWorkerActor()
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class RebootWorkerActorActor final : public Actor<int64_t>, public ActorCallback< RebootWorkerActorActor, 0, RangeResult >, public ActorCallback< RebootWorkerActorActor, 1, Void >, public FastAllocated<RebootWorkerActorActor>, public RebootWorkerActorActorState<RebootWorkerActorActor> {
															#line 43118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<RebootWorkerActorActor>::operator new;
	using FastAllocated<RebootWorkerActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<int64_t>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< RebootWorkerActorActor, 0, RangeResult >;
friend struct ActorCallback< RebootWorkerActorActor, 1, Void >;
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	RebootWorkerActorActor(DatabaseContext* const& cx,ValueRef const& addr,bool const& check,int const& duration) 
															#line 43130 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<int64_t>(),
		   RebootWorkerActorActorState<RebootWorkerActorActor>(cx, addr, check, duration)
	{
		fdb_probe_actor_enter("rebootWorkerActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("rebootWorkerActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("rebootWorkerActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< RebootWorkerActorActor, 0, RangeResult >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< RebootWorkerActorActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<int64_t> rebootWorkerActor( DatabaseContext* const& cx, ValueRef const& addr, bool const& check, int const& duration ) {
															#line 8402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<int64_t>(new RebootWorkerActorActor(cx, addr, check, duration));
															#line 43159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<int64_t> DatabaseContext::rebootWorker(StringRef addr, bool check, int duration) {
	return rebootWorkerActor(this, addr, check, duration);
}

Future<Void> DatabaseContext::forceRecoveryWithDataLoss(StringRef dcId) {
	return forceRecovery(getConnectionRecord(), dcId);
}

															#line 43172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via createSnapshotActor()
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class CreateSnapshotActorActor>
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CreateSnapshotActorActorState {
															#line 43179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CreateSnapshotActorActorState(DatabaseContext* const& cx,UID const& snapUID,StringRef const& snapCmd) 
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   snapUID(snapUID),
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   snapCmd(snapCmd)
															#line 43190 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("createSnapshotActor", reinterpret_cast<unsigned long>(this));

	}
	~CreateSnapshotActorActorState() 
	{
		fdb_probe_actor_destroy("createSnapshotActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = mgmtSnapCreate(cx->clone(), snapCmd, snapUID);
															#line 8465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<CreateSnapshotActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 43207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<CreateSnapshotActorActor*>(this)->actor_wait_state = 1;
															#line 8465 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CreateSnapshotActorActor, 0, Void >*>(static_cast<CreateSnapshotActorActor*>(this)));
															#line 43212 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~CreateSnapshotActorActorState();
		static_cast<CreateSnapshotActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 8466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CreateSnapshotActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CreateSnapshotActorActorState(); static_cast<CreateSnapshotActorActor*>(this)->destroy(); return 0; }
															#line 43235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CreateSnapshotActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CreateSnapshotActorActorState();
		static_cast<CreateSnapshotActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 8466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<CreateSnapshotActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CreateSnapshotActorActorState(); static_cast<CreateSnapshotActorActor*>(this)->destroy(); return 0; }
															#line 43247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<CreateSnapshotActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CreateSnapshotActorActorState();
		static_cast<CreateSnapshotActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CreateSnapshotActorActor*>(this)->actor_wait_state > 0) static_cast<CreateSnapshotActorActor*>(this)->actor_wait_state = 0;
		static_cast<CreateSnapshotActorActor*>(this)->ActorCallback< CreateSnapshotActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CreateSnapshotActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("createSnapshotActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createSnapshotActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CreateSnapshotActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("createSnapshotActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createSnapshotActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CreateSnapshotActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("createSnapshotActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("createSnapshotActor", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	DatabaseContext* cx;
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID snapUID;
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StringRef snapCmd;
															#line 43324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via createSnapshotActor()
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class CreateSnapshotActorActor final : public Actor<Void>, public ActorCallback< CreateSnapshotActorActor, 0, Void >, public FastAllocated<CreateSnapshotActorActor>, public CreateSnapshotActorActorState<CreateSnapshotActorActor> {
															#line 43329 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<CreateSnapshotActorActor>::operator new;
	using FastAllocated<CreateSnapshotActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< CreateSnapshotActorActor, 0, Void >;
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	CreateSnapshotActorActor(DatabaseContext* const& cx,UID const& snapUID,StringRef const& snapCmd) 
															#line 43340 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   CreateSnapshotActorActorState<CreateSnapshotActorActor>(cx, snapUID, snapCmd)
	{
		fdb_probe_actor_enter("createSnapshotActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("createSnapshotActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("createSnapshotActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< CreateSnapshotActorActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> createSnapshotActor( DatabaseContext* const& cx, UID const& snapUID, StringRef const& snapCmd ) {
															#line 8464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new CreateSnapshotActorActor(cx, snapUID, snapCmd));
															#line 43368 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8468 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> DatabaseContext::createSnapshot(StringRef uid, StringRef snapshot_command) {
	std::string uid_str = uid.toString();
	if (!std::all_of(uid_str.begin(), uid_str.end(), [](unsigned char c) { return std::isxdigit(c); }) ||
	    uid_str.size() != 32) {
		// only 32-length hex string is considered as a valid UID
		throw snap_invalid_uid_string();
	}
	return createSnapshotActor(this, UID::fromString(uid_str), snapshot_command);
}

void sharedStateDelRef(DatabaseSharedState* ssPtr) {
	if (--ssPtr->refCount == 0) {
		delete ssPtr;
	}
}

Future<DatabaseSharedState*> DatabaseContext::initSharedState() {
	ASSERT(!sharedStatePtr); // Don't re-initialize shared state if a pointer already exists
	DatabaseSharedState* newState = new DatabaseSharedState();
	// Increment refcount by 1 on creation to account for the one held in MultiVersionApi map
	// Therefore, on initialization, refCount should be 2 (after also going to setSharedState)
	newState->refCount++;
	newState->delRef = &sharedStateDelRef;
	setSharedState(newState);
	return newState;
}

void DatabaseContext::setSharedState(DatabaseSharedState* p) {
	ASSERT(p->protocolVersion == currentProtocolVersion);
	sharedStatePtr = p;
	sharedStatePtr->refCount++;
}

															#line 43406 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via storageFeedVersionUpdater()
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class StorageFeedVersionUpdaterActor>
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class StorageFeedVersionUpdaterActorState {
															#line 43413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageFeedVersionUpdaterActorState(StorageServerInterface const& interf,ChangeFeedStorageData* const& self) 
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : interf(interf),
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   self(self),
															#line 8503 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   destroyed(self->destroyed)
															#line 43424 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this));

	}
	~StorageFeedVersionUpdaterActorState() 
	{
		fdb_probe_actor_destroy("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8504 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 43439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~StorageFeedVersionUpdaterActorState();
		static_cast<StorageFeedVersionUpdaterActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 8505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (destroyed.isSet())
															#line 43469 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<StorageFeedVersionUpdaterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~StorageFeedVersionUpdaterActorState(); static_cast<StorageFeedVersionUpdaterActor*>(this)->destroy(); return 0; }
															#line 43473 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<StorageFeedVersionUpdaterActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~StorageFeedVersionUpdaterActorState();
			static_cast<StorageFeedVersionUpdaterActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 8508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (self->version.get() < self->desired.get())
															#line 43481 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = delay(CLIENT_KNOBS->CHANGE_FEED_EMPTY_BATCH_TIME) || self->version.whenAtLeast(self->desired.get());
															#line 8509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 43487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 1;
															#line 8509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >*>(static_cast<StorageFeedVersionUpdaterActor*>(this)));
															#line 43492 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 8533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = self->desired.whenAtLeast(self->version.get() + 1);
															#line 8533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 43501 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_3.get(), loopDepth); };
			static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 4;
															#line 8533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >*>(static_cast<StorageFeedVersionUpdaterActor*>(this)));
															#line 43506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 8510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (destroyed.isSet())
															#line 43522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<StorageFeedVersionUpdaterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~StorageFeedVersionUpdaterActorState(); static_cast<StorageFeedVersionUpdaterActor*>(this)->destroy(); return 0; }
															#line 43526 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<StorageFeedVersionUpdaterActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~StorageFeedVersionUpdaterActorState();
			static_cast<StorageFeedVersionUpdaterActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 8513 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (self->version.get() < self->desired.get())
															#line 43534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			try {
															#line 8515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<ChangeFeedVersionUpdateReply> __when_expr_1 = brokenPromiseToNever( interf.changeFeedVersionUpdate.getReply(ChangeFeedVersionUpdateRequest(self->desired.get())));
															#line 8515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont3Catch1(actor_cancelled(), loopDepth);
															#line 43541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont3Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_1.get(), loopDepth); };
				static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 2;
															#line 8515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >*>(static_cast<StorageFeedVersionUpdaterActor*>(this)));
															#line 43546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont3Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont3Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
			loopDepth = a_body1loopBody1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 8510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (destroyed.isSet())
															#line 43566 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<StorageFeedVersionUpdaterActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~StorageFeedVersionUpdaterActorState(); static_cast<StorageFeedVersionUpdaterActor*>(this)->destroy(); return 0; }
															#line 43570 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<StorageFeedVersionUpdaterActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~StorageFeedVersionUpdaterActorState();
			static_cast<StorageFeedVersionUpdaterActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 8513 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (self->version.get() < self->desired.get())
															#line 43578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			try {
															#line 8515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<ChangeFeedVersionUpdateReply> __when_expr_1 = brokenPromiseToNever( interf.changeFeedVersionUpdate.getReply(ChangeFeedVersionUpdateRequest(self->desired.get())));
															#line 8515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont3Catch1(actor_cancelled(), loopDepth);
															#line 43585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont3Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_1.get(), loopDepth); };
				static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 2;
															#line 8515 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >*>(static_cast<StorageFeedVersionUpdaterActor*>(this)));
															#line 43590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1loopBody1cont3Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1loopBody1cont3Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
			loopDepth = a_body1loopBody1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state > 0) static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<StorageFeedVersionUpdaterActor*>(this)->ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 8522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_server_overloaded)
															#line 43686 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY > CLIENT_KNOBS->CHANGE_FEED_EMPTY_BATCH_TIME)
															#line 43690 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8524 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					StrictFuture<Void> __when_expr_2 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY - CLIENT_KNOBS->CHANGE_FEED_EMPTY_BATCH_TIME);
															#line 8524 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 43696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont3Catch1when1(__when_expr_2.get(), loopDepth); };
					static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 3;
															#line 8524 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >*>(static_cast<StorageFeedVersionUpdaterActor*>(this)));
															#line 43701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
					loopDepth = a_body1loopBody1cont3Catch1cont2(loopDepth);
				}
			}
			else
			{
															#line 8528 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 43713 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont7(ChangeFeedVersionUpdateReply const& rep,int loopDepth) 
	{
															#line 8518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.version > self->version.get())
															#line 43728 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8519 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->version.set(rep.version);
															#line 43732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont7(ChangeFeedVersionUpdateReply && rep,int loopDepth) 
	{
															#line 8518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.version > self->version.get())
															#line 43742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8519 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->version.set(rep.version);
															#line 43746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(ChangeFeedVersionUpdateReply const& rep,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(rep, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(ChangeFeedVersionUpdateReply && rep,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(std::move(rep), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state > 0) static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<StorageFeedVersionUpdaterActor*>(this)->ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >::remove();

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >*,ChangeFeedVersionUpdateReply const& value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont3Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont3Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >*,ChangeFeedVersionUpdateReply && value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont3Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont3Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >*,Error err) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont3Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont3Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont3Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont10(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3Catch1cont2(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3Catch1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3Catch1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3Catch1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3Catch1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3Catch1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3Catch1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state > 0) static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<StorageFeedVersionUpdaterActor*>(this)->ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont11(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state > 0) static_cast<StorageFeedVersionUpdaterActor*>(this)->actor_wait_state = 0;
		static_cast<StorageFeedVersionUpdaterActor*>(this)->ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageServerInterface interf;
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedStorageData* self;
															#line 8503 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<Void> destroyed;
															#line 43996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via storageFeedVersionUpdater()
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class StorageFeedVersionUpdaterActor final : public Actor<Void>, public ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >, public ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >, public ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >, public ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >, public FastAllocated<StorageFeedVersionUpdaterActor>, public StorageFeedVersionUpdaterActorState<StorageFeedVersionUpdaterActor> {
															#line 44001 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<StorageFeedVersionUpdaterActor>::operator new;
	using FastAllocated<StorageFeedVersionUpdaterActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >;
friend struct ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >;
friend struct ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >;
friend struct ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >;
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageFeedVersionUpdaterActor(StorageServerInterface const& interf,ChangeFeedStorageData* const& self) 
															#line 44015 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   StorageFeedVersionUpdaterActorState<StorageFeedVersionUpdaterActor>(interf, self)
	{
		fdb_probe_actor_enter("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("storageFeedVersionUpdater");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("storageFeedVersionUpdater", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< StorageFeedVersionUpdaterActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< StorageFeedVersionUpdaterActor, 1, ChangeFeedVersionUpdateReply >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< StorageFeedVersionUpdaterActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< StorageFeedVersionUpdaterActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> storageFeedVersionUpdater( StorageServerInterface const& interf, ChangeFeedStorageData* const& self ) {
															#line 8502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new StorageFeedVersionUpdaterActor(interf, self));
															#line 44046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Reference<ChangeFeedStorageData> DatabaseContext::getStorageData(StorageServerInterface interf) {
	// use token from interface since that changes on SS restart
	UID token = interf.waitFailure.getEndpoint().token;
	auto it = changeFeedUpdaters.find(token);
	if (it == changeFeedUpdaters.end()) {
		Reference<ChangeFeedStorageData> newStorageUpdater = makeReference<ChangeFeedStorageData>();
		newStorageUpdater->id = interf.id();
		newStorageUpdater->interfToken = token;
		newStorageUpdater->updater = storageFeedVersionUpdater(interf, newStorageUpdater.getPtr());
		changeFeedUpdaters[token] = newStorageUpdater;
		return newStorageUpdater;
	}
	return it->second;
}

Version ChangeFeedData::getVersion() {
	return lastReturnedVersion.get();
}

// This function is essentially bubbling the information about what has been processed from the server through the
// change feed client. First it makes sure the server has returned all mutations up through the target version, the
// native api has consumed and processed, them, and then the fdb client has consumed all of the mutations.
															#line 44073 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via changeFeedWaitLatest()
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ChangeFeedWaitLatestActor>
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ChangeFeedWaitLatestActorState {
															#line 44080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedWaitLatestActorState(Reference<ChangeFeedData> const& self,Version const& version) 
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self),
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version)
															#line 44089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this));

	}
	~ChangeFeedWaitLatestActorState() 
	{
		fdb_probe_actor_destroy("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8562 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::vector<Future<Void>> allAtLeast;
															#line 8563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : self->storageData ) {
															#line 8564 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (it->version.get() < version)
															#line 44108 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8565 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (version > it->desired.get())
															#line 44112 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 8566 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						it->desired.set(version);
															#line 44116 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
															#line 8568 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					allAtLeast.push_back(it->version.whenAtLeast(version));
															#line 44120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 8572 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = waitForAll(allAtLeast);
															#line 8572 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 44127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 1;
															#line 8572 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 0, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ChangeFeedWaitLatestActorState();
		static_cast<ChangeFeedWaitLatestActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 8575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<Future<Void>> onEmpty;
															#line 8576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& it : self->streams ) {
															#line 8577 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!it.isEmpty())
															#line 44159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				onEmpty.push_back(it.onEmpty());
															#line 44163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 8582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (onEmpty.size())
															#line 44168 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = waitForAll(onEmpty);
															#line 8583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 44174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 2;
															#line 8583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 1, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont5(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 8575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<Future<Void>> onEmpty;
															#line 8576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& it : self->streams ) {
															#line 8577 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!it.isEmpty())
															#line 44197 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				onEmpty.push_back(it.onEmpty());
															#line 44201 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
															#line 8582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (onEmpty.size())
															#line 44206 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = waitForAll(onEmpty);
															#line 8583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 44212 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 2;
															#line 8583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 1, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont5(loopDepth);
		}

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWaitLatestActor*>(this)->ActorCallback< ChangeFeedWaitLatestActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ChangeFeedWaitLatestActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont5(int loopDepth) 
	{
															#line 8586 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (self->mutations.isEmpty())
															#line 44294 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = delay(0);
															#line 8587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 44300 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont5when1(__when_expr_2.get(), loopDepth); };
			static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 3;
															#line 8587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 2, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44305 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont9(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont8(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont8(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWaitLatestActor*>(this)->ActorCallback< ChangeFeedWaitLatestActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ChangeFeedWaitLatestActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont9(int loopDepth) 
	{
															#line 8592 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 44394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont9loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont10(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont10(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont10(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont10(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWaitLatestActor*>(this)->ActorCallback< ChangeFeedWaitLatestActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< ChangeFeedWaitLatestActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont11(int loopDepth) 
	{
															#line 8598 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (self->maxSeenVersion >= version)
															#line 44478 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8601 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = self->lastReturnedVersion.whenAtLeast(version);
															#line 8601 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 44484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont11when1(__when_expr_4.get(), loopDepth); };
			static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 5;
															#line 8601 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 4, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44489 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 8604 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 44496 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont11loopHead1(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont9loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont9loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1(int loopDepth) 
	{
															#line 8592 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(self->lastReturnedVersion.get() < self->maxSeenVersion && self->lastReturnedVersion.get() < version))
															#line 44513 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont9break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 8593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Version target = std::min(self->maxSeenVersion, version);
															#line 8594 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = self->lastReturnedVersion.whenAtLeast(target);
															#line 8594 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 44523 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont9loopBody1when1(__when_expr_3.get(), loopDepth); };
		static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 4;
															#line 8594 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 3, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44528 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont9break1(int loopDepth) 
	{
		try {
			return a_body1cont11(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont9loopBody1cont1(Void const& _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont9loopHead1(0);

		return loopDepth;
	}
	int a_body1cont9loopBody1cont1(Void && _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont9loopHead1(0);

		return loopDepth;
	}
	int a_body1cont9loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWaitLatestActor*>(this)->ActorCallback< ChangeFeedWaitLatestActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont9loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont9loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< ChangeFeedWaitLatestActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont11cont1(int loopDepth) 
	{
															#line 8610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ChangeFeedWaitLatestActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~ChangeFeedWaitLatestActorState(); static_cast<ChangeFeedWaitLatestActor*>(this)->destroy(); return 0; }
															#line 44625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ChangeFeedWaitLatestActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~ChangeFeedWaitLatestActorState();
		static_cast<ChangeFeedWaitLatestActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont11cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWaitLatestActor*>(this)->ActorCallback< ChangeFeedWaitLatestActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont11when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont11when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< ChangeFeedWaitLatestActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont11cont3(int loopDepth) 
	{
		loopDepth = a_body1cont11cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont11loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11loopBody1(int loopDepth) 
	{
															#line 8604 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(!self->mutations.isEmpty()))
															#line 44725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont11break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 8605 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_5 = self->mutations.onEmpty();
															#line 8605 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 44733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont11loopBody1when1(__when_expr_5.get(), loopDepth); };
		static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 6;
															#line 8605 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 5, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont11break1(int loopDepth) 
	{
		try {
			return a_body1cont11cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 8606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_6 = delay(0);
															#line 8606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 44762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), std::max(0, loopDepth - 1)); else return a_body1cont11loopBody1cont1when1(__when_expr_6.get(), loopDepth); };
		static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 7;
															#line 8606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 6, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44767 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont11loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 8606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_6 = delay(0);
															#line 8606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 44778 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), std::max(0, loopDepth - 1)); else return a_body1cont11loopBody1cont1when1(__when_expr_6.get(), loopDepth); };
		static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 7;
															#line 8606 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWaitLatestActor, 6, Void >*>(static_cast<ChangeFeedWaitLatestActor*>(this)));
															#line 44783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont11loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWaitLatestActor*>(this)->ActorCallback< ChangeFeedWaitLatestActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont11loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont11loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< ChangeFeedWaitLatestActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont11loopBody1cont3(Void const& _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont11loopHead1(0);

		return loopDepth;
	}
	int a_body1cont11loopBody1cont3(Void && _,int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont11loopHead1(0);

		return loopDepth;
	}
	int a_body1cont11loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWaitLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWaitLatestActor*>(this)->ActorCallback< ChangeFeedWaitLatestActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont11loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWaitLatestActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont11loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< ChangeFeedWaitLatestActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), 6);

	}
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> self;
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 44930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via changeFeedWaitLatest()
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ChangeFeedWaitLatestActor final : public Actor<Void>, public ActorCallback< ChangeFeedWaitLatestActor, 0, Void >, public ActorCallback< ChangeFeedWaitLatestActor, 1, Void >, public ActorCallback< ChangeFeedWaitLatestActor, 2, Void >, public ActorCallback< ChangeFeedWaitLatestActor, 3, Void >, public ActorCallback< ChangeFeedWaitLatestActor, 4, Void >, public ActorCallback< ChangeFeedWaitLatestActor, 5, Void >, public ActorCallback< ChangeFeedWaitLatestActor, 6, Void >, public FastAllocated<ChangeFeedWaitLatestActor>, public ChangeFeedWaitLatestActorState<ChangeFeedWaitLatestActor> {
															#line 44935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ChangeFeedWaitLatestActor>::operator new;
	using FastAllocated<ChangeFeedWaitLatestActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< ChangeFeedWaitLatestActor, 0, Void >;
friend struct ActorCallback< ChangeFeedWaitLatestActor, 1, Void >;
friend struct ActorCallback< ChangeFeedWaitLatestActor, 2, Void >;
friend struct ActorCallback< ChangeFeedWaitLatestActor, 3, Void >;
friend struct ActorCallback< ChangeFeedWaitLatestActor, 4, Void >;
friend struct ActorCallback< ChangeFeedWaitLatestActor, 5, Void >;
friend struct ActorCallback< ChangeFeedWaitLatestActor, 6, Void >;
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedWaitLatestActor(Reference<ChangeFeedData> const& self,Version const& version) 
															#line 44952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   ChangeFeedWaitLatestActorState<ChangeFeedWaitLatestActor>(self, version)
	{
		fdb_probe_actor_enter("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("changeFeedWaitLatest");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("changeFeedWaitLatest", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ChangeFeedWaitLatestActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< ChangeFeedWaitLatestActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< ChangeFeedWaitLatestActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< ChangeFeedWaitLatestActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< ChangeFeedWaitLatestActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< ChangeFeedWaitLatestActor, 5, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< ChangeFeedWaitLatestActor, 6, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> changeFeedWaitLatest( Reference<ChangeFeedData> const& self, Version const& version ) {
															#line 8560 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new ChangeFeedWaitLatestActor(self, version));
															#line 44986 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8612 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 44991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via changeFeedWhenAtLatest()
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class ChangeFeedWhenAtLatestActor>
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ChangeFeedWhenAtLatestActorState {
															#line 44998 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedWhenAtLatestActorState(Reference<ChangeFeedData> const& self,Version const& version) 
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : self(self),
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version)
															#line 45007 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this));

	}
	~ChangeFeedWhenAtLatestActorState() 
	{
		fdb_probe_actor_destroy("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8614 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (version >= self->endVersion)
															#line 45022 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8615 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				this->~ChangeFeedWhenAtLatestActorState();
															#line 45026 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				static_cast<ChangeFeedWhenAtLatestActor*>(this)->sendAndDelPromiseRef(Never());
				return 0;
			}
															#line 8617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (version <= self->getVersion())
															#line 45032 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8618 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<ChangeFeedWhenAtLatestActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~ChangeFeedWhenAtLatestActorState(); static_cast<ChangeFeedWhenAtLatestActor*>(this)->destroy(); return 0; }
															#line 45036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<ChangeFeedWhenAtLatestActor*>(this)->SAV< Void >::value()) Void(Void());
				this->~ChangeFeedWhenAtLatestActorState();
				static_cast<ChangeFeedWhenAtLatestActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 8620 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			lastReturned = self->lastReturnedVersion.whenAtLeast(version);
															#line 8621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 45046 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~ChangeFeedWhenAtLatestActorState();
		static_cast<ChangeFeedWhenAtLatestActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 8636 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (self->lastReturnedVersion.get() < version)
															#line 45069 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8637 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			self->lastReturnedVersion.set(version);
															#line 45073 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(self->getVersion() >= version);
															#line 8640 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<ChangeFeedWhenAtLatestActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~ChangeFeedWhenAtLatestActorState(); static_cast<ChangeFeedWhenAtLatestActor*>(this)->destroy(); return 0; }
															#line 45079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<ChangeFeedWhenAtLatestActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~ChangeFeedWhenAtLatestActorState();
		static_cast<ChangeFeedWhenAtLatestActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 8623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Future<Void> waitEmptyVersion = (self->notAtLatest.get() == 0) ? changeFeedWaitLatest(self, version) : Never();
															#line 8625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_0 = waitEmptyVersion;
															#line 8624 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<ChangeFeedWhenAtLatestActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 45102 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
															#line 8628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = lastReturned;
															#line 45106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
															#line 8631 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = self->refresh.getFuture();
															#line 45110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when3(__when_expr_2.get(), loopDepth); };
															#line 8632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = self->notAtLatest.onChange();
															#line 45114 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when4(__when_expr_3.get(), loopDepth); };
		static_cast<ChangeFeedWhenAtLatestActor*>(this)->actor_wait_state = 1;
															#line 8625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >*>(static_cast<ChangeFeedWhenAtLatestActor*>(this)));
															#line 8628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWhenAtLatestActor, 1, Void >*>(static_cast<ChangeFeedWhenAtLatestActor*>(this)));
															#line 8631 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWhenAtLatestActor, 2, Void >*>(static_cast<ChangeFeedWhenAtLatestActor*>(this)));
															#line 8632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< ChangeFeedWhenAtLatestActor, 3, Void >*>(static_cast<ChangeFeedWhenAtLatestActor*>(this)));
															#line 45125 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1when3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<ChangeFeedWhenAtLatestActor*>(this)->actor_wait_state > 0) static_cast<ChangeFeedWhenAtLatestActor*>(this)->actor_wait_state = 0;
		static_cast<ChangeFeedWhenAtLatestActor*>(this)->ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >::remove();
		static_cast<ChangeFeedWhenAtLatestActor*>(this)->ActorCallback< ChangeFeedWhenAtLatestActor, 1, Void >::remove();
		static_cast<ChangeFeedWhenAtLatestActor*>(this)->ActorCallback< ChangeFeedWhenAtLatestActor, 2, Void >::remove();
		static_cast<ChangeFeedWhenAtLatestActor*>(this)->ActorCallback< ChangeFeedWhenAtLatestActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< ChangeFeedWhenAtLatestActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1loopBody1when3(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1loopBody1when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< ChangeFeedWhenAtLatestActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose1();
		try {
			a_body1loopBody1when4(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< ChangeFeedWhenAtLatestActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose1();
		try {
			a_body1loopBody1when4(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< ChangeFeedWhenAtLatestActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> self;
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 8620 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> lastReturned;
															#line 45392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via changeFeedWhenAtLatest()
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class ChangeFeedWhenAtLatestActor final : public Actor<Void>, public ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >, public ActorCallback< ChangeFeedWhenAtLatestActor, 1, Void >, public ActorCallback< ChangeFeedWhenAtLatestActor, 2, Void >, public ActorCallback< ChangeFeedWhenAtLatestActor, 3, Void >, public FastAllocated<ChangeFeedWhenAtLatestActor>, public ChangeFeedWhenAtLatestActorState<ChangeFeedWhenAtLatestActor> {
															#line 45397 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<ChangeFeedWhenAtLatestActor>::operator new;
	using FastAllocated<ChangeFeedWhenAtLatestActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >;
friend struct ActorCallback< ChangeFeedWhenAtLatestActor, 1, Void >;
friend struct ActorCallback< ChangeFeedWhenAtLatestActor, 2, Void >;
friend struct ActorCallback< ChangeFeedWhenAtLatestActor, 3, Void >;
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedWhenAtLatestActor(Reference<ChangeFeedData> const& self,Version const& version) 
															#line 45411 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   ChangeFeedWhenAtLatestActorState<ChangeFeedWhenAtLatestActor>(self, version)
	{
		fdb_probe_actor_enter("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("changeFeedWhenAtLatest");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("changeFeedWhenAtLatest", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< ChangeFeedWhenAtLatestActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> changeFeedWhenAtLatest( Reference<ChangeFeedData> const& self, Version const& version ) {
															#line 8613 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new ChangeFeedWhenAtLatestActor(self, version));
															#line 45439 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8642 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> ChangeFeedData::whenAtLeast(Version version) {
	return changeFeedWhenAtLatest(Reference<ChangeFeedData>::addRef(this), version);
}

#define DEBUG_CF_CLIENT_TRACE false

															#line 45450 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via partialChangeFeedStream()
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class PartialChangeFeedStreamActor>
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PartialChangeFeedStreamActorState {
															#line 45457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PartialChangeFeedStreamActorState(StorageServerInterface const& interf,PromiseStream<Standalone<MutationsAndVersionRef>> const& results,ReplyPromiseStream<ChangeFeedStreamReply> const& replyStream,Version const& begin,Version const& end,Reference<ChangeFeedData> const& feedData,Reference<ChangeFeedStorageData> const& storageData,UID const& debugUID) 
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : interf(interf),
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(results),
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   replyStream(replyStream),
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   feedData(feedData),
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   storageData(storageData),
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   debugUID(debugUID),
															#line 8659 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   refresh(feedData->refresh),
															#line 8660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   atLatestVersion(false),
															#line 8661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   nextVersion(begin),
															#line 8667 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   lastEmpty(invalidVersion)
															#line 45486 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("partialChangeFeedStream", reinterpret_cast<unsigned long>(this));

	}
	~PartialChangeFeedStreamActorState() 
	{
		fdb_probe_actor_destroy("partialChangeFeedStream", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
			try {
															#line 8669 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				;
															#line 45502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			catch (Error& error) {
				loopDepth = a_body1Catch2(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1Catch2(unknown_error(), loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~PartialChangeFeedStreamActorState();
		static_cast<PartialChangeFeedStreamActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1Catch2(const Error& e,int loopDepth=0) 
	{
		try {
															#line 8771 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (DEBUG_CF_CLIENT_TRACE)
															#line 45532 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorError", debugUID).errorUnsuppressed(e);
															#line 45536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8774 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_actor_cancelled)
															#line 45540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, loopDepth);
															#line 45544 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8777 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.sendError(e);
															#line 8778 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<PartialChangeFeedStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PartialChangeFeedStreamActorState(); static_cast<PartialChangeFeedStreamActor*>(this)->destroy(); return 0; }
															#line 45550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<PartialChangeFeedStreamActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~PartialChangeFeedStreamActorState();
			static_cast<PartialChangeFeedStreamActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 8670 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nextVersion >= end)
															#line 45575 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8671 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.sendError(end_of_stream());
															#line 8672 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<PartialChangeFeedStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PartialChangeFeedStreamActorState(); static_cast<PartialChangeFeedStreamActor*>(this)->destroy(); return 0; }
															#line 45581 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<PartialChangeFeedStreamActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~PartialChangeFeedStreamActorState();
			static_cast<PartialChangeFeedStreamActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 8675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		FutureStream<ChangeFeedStreamReply> __when_expr_0 = replyStream.getFuture();
															#line 8674 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 45591 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch2(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.pop(), loopDepth); };
															#line 8753 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = atLatestVersion && replyStream.isEmpty() && results.isEmpty() ? storageData->version.whenAtLeast(nextVersion) : Future<Void>(Never());
															#line 45595 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch2(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when2(__when_expr_1.get(), loopDepth); };
															#line 8766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = atLatestVersion && replyStream.isEmpty() && !results.isEmpty() ? results.onEmpty() : Future<Void>(Never());
															#line 45599 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch2(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when3(__when_expr_2.get(), loopDepth); };
		static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state = 1;
															#line 8675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >*>(static_cast<PartialChangeFeedStreamActor*>(this)));
															#line 8753 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< PartialChangeFeedStreamActor, 1, Void >*>(static_cast<PartialChangeFeedStreamActor*>(this)));
															#line 8766 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< PartialChangeFeedStreamActor, 2, Void >*>(static_cast<PartialChangeFeedStreamActor*>(this)));
															#line 45608 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(ChangeFeedStreamReply const& __rep,int loopDepth) 
	{
															#line 8675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		rep = __rep;
															#line 8677 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nextVersion == begin && rep.mutations.size() == 1 && rep.mutations[0].mutations.size() == 0 && rep.mutations[0].version == begin - 1)
															#line 45625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopHead1(loopDepth); // continue
		}
															#line 8682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 45631 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorReply", debugUID) .detail("SSID", storageData->id) .detail("AtLatest", atLatestVersion) .detail("FirstVersion", rep.mutations.front().version) .detail("LastVersion", rep.mutations.back().version) .detail("Count", rep.mutations.size()) .detail("MinStreamVersion", rep.minStreamVersion) .detail("PopVersion", rep.popVersion) .detail("RepAtLatest", rep.atLatestVersion);
															#line 45635 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.mutations.back().version > feedData->maxSeenVersion)
															#line 45639 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			feedData->maxSeenVersion = rep.mutations.back().version;
															#line 45643 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.popVersion > feedData->popVersion)
															#line 45647 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8698 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			feedData->popVersion = rep.popVersion;
															#line 45651 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (lastEmpty != invalidVersion && !results.isEmpty())
															#line 45655 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : feedData->storageData ) {
															#line 8703 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (refresh.canBeSet() && lastEmpty > it->desired.get())
															#line 45661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					it->desired.set(lastEmpty);
															#line 45665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 8707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			lastEmpty = invalidVersion;
															#line 45670 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resultLoc = 0;
															#line 8711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 45676 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1when1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(ChangeFeedStreamReply && __rep,int loopDepth) 
	{
		rep = std::move(__rep);
															#line 8677 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nextVersion == begin && rep.mutations.size() == 1 && rep.mutations[0].mutations.size() == 0 && rep.mutations[0].version == begin - 1)
															#line 45686 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopHead1(loopDepth); // continue
		}
															#line 8682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 45692 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorReply", debugUID) .detail("SSID", storageData->id) .detail("AtLatest", atLatestVersion) .detail("FirstVersion", rep.mutations.front().version) .detail("LastVersion", rep.mutations.back().version) .detail("Count", rep.mutations.size()) .detail("MinStreamVersion", rep.minStreamVersion) .detail("PopVersion", rep.popVersion) .detail("RepAtLatest", rep.atLatestVersion);
															#line 45696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.mutations.back().version > feedData->maxSeenVersion)
															#line 45700 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8695 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			feedData->maxSeenVersion = rep.mutations.back().version;
															#line 45704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.popVersion > feedData->popVersion)
															#line 45708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8698 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			feedData->popVersion = rep.popVersion;
															#line 45712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (lastEmpty != invalidVersion && !results.isEmpty())
															#line 45716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8702 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : feedData->storageData ) {
															#line 8703 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (refresh.canBeSet() && lastEmpty > it->desired.get())
															#line 45722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					it->desired.set(lastEmpty);
															#line 45726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 8707 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			lastEmpty = invalidVersion;
															#line 45731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resultLoc = 0;
															#line 8711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 45737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1when1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void const& _,int loopDepth) 
	{
															#line 8756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		MutationsAndVersionRef empty;
															#line 8757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		empty.version = storageData->version.get();
															#line 8758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.send(empty);
															#line 8759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextVersion = storageData->version.get() + 1;
															#line 8760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 45754 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorSendEmpty", debugUID) .detail("Version", empty.version);
															#line 45758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8764 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastEmpty = empty.version;
															#line 45762 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when2(Void && _,int loopDepth) 
	{
															#line 8756 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		MutationsAndVersionRef empty;
															#line 8757 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		empty.version = storageData->version.get();
															#line 8758 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		results.send(empty);
															#line 8759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextVersion = storageData->version.get() + 1;
															#line 8760 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 45779 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8761 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorSendEmpty", debugUID) .detail("Version", empty.version);
															#line 45783 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8764 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		lastEmpty = empty.version;
															#line 45787 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state > 0) static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state = 0;
		static_cast<PartialChangeFeedStreamActor*>(this)->ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >::remove();
		static_cast<PartialChangeFeedStreamActor*>(this)->ActorCallback< PartialChangeFeedStreamActor, 1, Void >::remove();
		static_cast<PartialChangeFeedStreamActor*>(this)->ActorCallback< PartialChangeFeedStreamActor, 2, Void >::remove();

	}
	int a_body1loopBody1when1cont1(int loopDepth) 
	{
															#line 8737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.mutations.back().version + 1 > nextVersion)
															#line 45816 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8738 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			nextVersion = rep.mutations.back().version + 1;
															#line 45820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8741 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (refresh.canBeSet() && !atLatestVersion && rep.atLatestVersion)
															#line 45824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8742 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			atLatestVersion = true;
															#line 8743 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			feedData->notAtLatest.set(feedData->notAtLatest.get() - 1);
															#line 45830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8745 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (refresh.canBeSet() && rep.minStreamVersion > storageData->version.get())
															#line 45834 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8746 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			storageData->version.set(rep.minStreamVersion);
															#line 45838 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8748 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 45842 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorReplyDone", debugUID) .detail("AtLatestNow", atLatestVersion);
															#line 45846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1when1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1loopBody1(int loopDepth) 
	{
															#line 8711 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(resultLoc < rep.mutations.size()))
															#line 45863 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1when1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 8712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = results.onEmpty();
															#line 8712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch2(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 45871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch2(__when_expr_3.getError(), std::max(0, loopDepth - 2)); else return a_body1loopBody1when1loopBody1when1(__when_expr_3.get(), loopDepth); };
		static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state = 2;
															#line 8712 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< PartialChangeFeedStreamActor, 3, Void >*>(static_cast<PartialChangeFeedStreamActor*>(this)));
															#line 45876 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1when1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch2(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch2(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1when1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 8713 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.mutations[resultLoc].version >= nextVersion)
															#line 45898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.send(rep.mutations[resultLoc]);
															#line 8716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (DEBUG_CF_CLIENT_TRACE)
															#line 45904 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8717 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorSend", debugUID) .detail("Version", rep.mutations[resultLoc].version) .detail("Size", rep.mutations[resultLoc].mutations.size());
															#line 45908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : feedData->storageData ) {
															#line 8726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (refresh.canBeSet() && rep.mutations[resultLoc].version > it->desired.get())
															#line 45914 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					it->desired.set(rep.mutations[resultLoc].version);
															#line 45918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		else
		{
															#line 8731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(rep.mutations[resultLoc].mutations.empty());
															#line 45926 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resultLoc++;
															#line 45930 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1when1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 8713 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (rep.mutations[resultLoc].version >= nextVersion)
															#line 45939 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results.send(rep.mutations[resultLoc]);
															#line 8716 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (DEBUG_CF_CLIENT_TRACE)
															#line 45945 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8717 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorSend", debugUID) .detail("Version", rep.mutations[resultLoc].version) .detail("Size", rep.mutations[resultLoc].mutations.size());
															#line 45949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8725 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : feedData->storageData ) {
															#line 8726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (refresh.canBeSet() && rep.mutations[resultLoc].version > it->desired.get())
															#line 45955 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8727 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					it->desired.set(rep.mutations[resultLoc].version);
															#line 45959 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
		else
		{
															#line 8731 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(rep.mutations[resultLoc].mutations.empty());
															#line 45967 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8733 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		resultLoc++;
															#line 45971 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1when1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1when1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1when1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state > 0) static_cast<PartialChangeFeedStreamActor*>(this)->actor_wait_state = 0;
		static_cast<PartialChangeFeedStreamActor*>(this)->ActorCallback< PartialChangeFeedStreamActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PartialChangeFeedStreamActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1loopBody1when1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< PartialChangeFeedStreamActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1loopBody1when1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< PartialChangeFeedStreamActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose2();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >*,ChangeFeedStreamReply const& value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >*,ChangeFeedStreamReply && value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >*,Error err) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< PartialChangeFeedStreamActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< PartialChangeFeedStreamActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1loopBody1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< PartialChangeFeedStreamActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< PartialChangeFeedStreamActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1loopBody1when3(value, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< PartialChangeFeedStreamActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1loopBody1when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< PartialChangeFeedStreamActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose1();
		try {
			a_body1Catch2(err, 0);
		}
		catch (Error& error) {
			a_body1Catch2(error, 0);
		} catch (...) {
			a_body1Catch2(unknown_error(), 0);
		}
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageServerInterface interf;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PromiseStream<Standalone<MutationsAndVersionRef>> results;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ReplyPromiseStream<ChangeFeedStreamReply> replyStream;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version begin;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version end;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> feedData;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedStorageData> storageData;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID debugUID;
															#line 8659 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<Void> refresh;
															#line 8660 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool atLatestVersion;
															#line 8661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version nextVersion;
															#line 8667 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version lastEmpty;
															#line 8675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedStreamReply rep;
															#line 8710 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int resultLoc;
															#line 46202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via partialChangeFeedStream()
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PartialChangeFeedStreamActor final : public Actor<Void>, public ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >, public ActorCallback< PartialChangeFeedStreamActor, 3, Void >, public ActorCallback< PartialChangeFeedStreamActor, 1, Void >, public ActorCallback< PartialChangeFeedStreamActor, 2, Void >, public FastAllocated<PartialChangeFeedStreamActor>, public PartialChangeFeedStreamActorState<PartialChangeFeedStreamActor> {
															#line 46207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<PartialChangeFeedStreamActor>::operator new;
	using FastAllocated<PartialChangeFeedStreamActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >;
friend struct ActorCallback< PartialChangeFeedStreamActor, 3, Void >;
friend struct ActorCallback< PartialChangeFeedStreamActor, 1, Void >;
friend struct ActorCallback< PartialChangeFeedStreamActor, 2, Void >;
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PartialChangeFeedStreamActor(StorageServerInterface const& interf,PromiseStream<Standalone<MutationsAndVersionRef>> const& results,ReplyPromiseStream<ChangeFeedStreamReply> const& replyStream,Version const& begin,Version const& end,Reference<ChangeFeedData> const& feedData,Reference<ChangeFeedStorageData> const& storageData,UID const& debugUID) 
															#line 46221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   PartialChangeFeedStreamActorState<PartialChangeFeedStreamActor>(interf, results, replyStream, begin, end, feedData, storageData, debugUID)
	{
		fdb_probe_actor_enter("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("partialChangeFeedStream");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("partialChangeFeedStream", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< PartialChangeFeedStreamActor, 0, ChangeFeedStreamReply >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< PartialChangeFeedStreamActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> partialChangeFeedStream( StorageServerInterface const& interf, PromiseStream<Standalone<MutationsAndVersionRef>> const& results, ReplyPromiseStream<ChangeFeedStreamReply> const& replyStream, Version const& begin, Version const& end, Reference<ChangeFeedData> const& feedData, Reference<ChangeFeedStorageData> const& storageData, UID const& debugUID ) {
															#line 8649 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new PartialChangeFeedStreamActor(interf, results, replyStream, begin, end, feedData, storageData, debugUID));
															#line 46250 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8781 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 46255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via mergeChangeFeedStreamInternal()
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class MergeChangeFeedStreamInternalActor>
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MergeChangeFeedStreamInternalActorState {
															#line 46262 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MergeChangeFeedStreamInternalActorState(Reference<ChangeFeedData> const& results,std::vector<std::pair<StorageServerInterface, KeyRange>> const& interfs,std::vector<MutationAndVersionStream> const& streams,Version* const& begin,Version const& end,UID const& mergeCursorUID) 
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : results(results),
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   interfs(interfs),
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   streams(streams),
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   mergeCursorUID(mergeCursorUID),
															#line 8788 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   refresh(results->refresh),
															#line 8791 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   mutations()
															#line 46283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this));

	}
	~MergeChangeFeedStreamInternalActorState() 
	{
		fdb_probe_actor_destroy("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8793 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (DEBUG_CF_CLIENT_TRACE)
															#line 46298 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8794 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorStart", mergeCursorUID) .detail("StreamCount", interfs.size()) .detail("Begin", *begin) .detail("End", end);
															#line 46302 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = results->mutations.onEmpty();
															#line 8802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 46308 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 1;
															#line 8802 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 46313 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MergeChangeFeedStreamInternalActorState();
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 8803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = delay(0);
															#line 8803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 46338 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 2;
															#line 8803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 46343 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 8803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = delay(0);
															#line 8803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 46354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 2;
															#line 8803 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 46359 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
															#line 8804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(results->mutations.isEmpty());
															#line 8806 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 46433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorGotEmpty", mergeCursorUID);
															#line 46437 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (*begin - 1 > results->lastReturnedVersion.get())
															#line 46441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->lastReturnedVersion.set(*begin - 1);
															#line 46445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		interfNum = 0;
															#line 8817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		streamsUsed = std::vector<MutationAndVersionStream>();
															#line 8819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& stream : streams ) {
															#line 8820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			streamsUsed.push_back(stream);
															#line 46455 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextVersion = Version();
															#line 8824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 46461 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
															#line 8804 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(results->mutations.isEmpty());
															#line 8806 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 46472 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8807 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorGotEmpty", mergeCursorUID);
															#line 46476 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (*begin - 1 > results->lastReturnedVersion.get())
															#line 46480 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8812 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->lastReturnedVersion.set(*begin - 1);
															#line 46484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		interfNum = 0;
															#line 8817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		streamsUsed = std::vector<MutationAndVersionStream>();
															#line 8819 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& stream : streams ) {
															#line 8820 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			streamsUsed.push_back(stream);
															#line 46494 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextVersion = Version();
															#line 8824 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 46500 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont3loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1(int loopDepth) 
	{
															#line 8826 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		interfNum = 0;
															#line 8827 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 46581 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopBody1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1(int loopDepth) 
	{
															#line 8840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (mutations.empty())
															#line 46590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8841 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(end_of_stream(), std::max(0, loopDepth - 1));
															#line 46594 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8844 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		streamsUsed.clear();
															#line 8847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_3 = delay(0);
															#line 8847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 46602 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont1when1(__when_expr_3.get(), loopDepth); };
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 4;
															#line 8847 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 46607 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont3loopBody1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1loopBody1(int loopDepth) 
	{
															#line 8827 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(interfNum < streamsUsed.size()))
															#line 46623 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1cont3loopBody1break1(loopDepth==0?0:loopDepth-1); // break
		}
		try {
															#line 8829 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			FutureStream<Standalone<MutationsAndVersionRef>> __when_expr_2 = streamsUsed[interfNum].results.getFuture();
															#line 8829 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 46632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont3loopBody1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont3loopBody1loopBody1when1(__when_expr_2.pop(), loopDepth); };
			static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 3;
															#line 8829 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 46637 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont3loopBody1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont3loopBody1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1break1(int loopDepth) 
	{
		try {
			return a_body1cont3loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1loopBody1cont1(int loopDepth) 
	{
															#line 8837 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		interfNum++;
															#line 46665 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont3loopBody1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont3loopBody1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 8833 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_end_of_stream)
															#line 46675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8834 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 2));
															#line 46679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
			loopDepth = a_body1cont3loopBody1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1loopBody1cont3(Standalone<MutationsAndVersionRef> const& res,int loopDepth) 
	{
															#line 8830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		streamsUsed[interfNum].next = res;
															#line 8831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		mutations.push(streamsUsed[interfNum]);
															#line 46697 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopBody1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1loopBody1cont3(Standalone<MutationsAndVersionRef> && res,int loopDepth) 
	{
															#line 8830 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		streamsUsed[interfNum].next = res;
															#line 8831 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		mutations.push(streamsUsed[interfNum]);
															#line 46708 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont3loopBody1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1loopBody1when1(Standalone<MutationsAndVersionRef> const& res,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1loopBody1cont3(res, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1loopBody1when1(Standalone<MutationsAndVersionRef> && res,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1loopBody1cont3(std::move(res), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >::remove();

	}
	void a_callback_fire(ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >*,Standalone<MutationsAndVersionRef> const& value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3loopBody1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >*,Standalone<MutationsAndVersionRef> && value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3loopBody1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >*,Error err) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont3loopBody1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont3loopBody1loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont3loopBody1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 8850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Standalone<VectorRef<MutationsAndVersionRef>> nextOut;
															#line 8851 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextVersion = mutations.top().next.version;
															#line 8853 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		streamsUsed.push_back(mutations.top());
															#line 8854 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextOut.push_back_deep(nextOut.arena(), mutations.top().next);
															#line 8855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		mutations.pop();
															#line 8858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(;!mutations.empty() && mutations.top().next.version == nextVersion;) {
															#line 8859 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (mutations.top().next.mutations.size() && mutations.top().next.mutations.front().param1 != lastEpochEndPrivateKey)
															#line 46805 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				nextOut.back().mutations.append_deep( nextOut.arena(), mutations.top().next.mutations.begin(), mutations.top().next.mutations.size());
															#line 46809 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			streamsUsed.push_back(mutations.top());
															#line 8865 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			mutations.pop();
															#line 46815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(nextOut.size() == 1);
															#line 8869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(nextVersion >= *begin);
															#line 8871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		*begin = nextVersion + 1;
															#line 8873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 46825 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8874 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorSending", mergeCursorUID) .detail("Count", streamsUsed.size()) .detail("Version", nextVersion);
															#line 46829 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nextOut.back().mutations.empty())
															#line 46833 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(results->mutations.isEmpty());
															#line 46837 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont3loopBody1cont4(loopDepth);
		}
		else
		{
															#line 8883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(nextOut.back().version > results->lastReturnedVersion.get());
															#line 8885 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->mutations.send(nextOut);
															#line 8886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = results->mutations.onEmpty();
															#line 8886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 46850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont2when1(__when_expr_4.get(), loopDepth); };
			static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 5;
															#line 8886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 46855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 8850 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		Standalone<VectorRef<MutationsAndVersionRef>> nextOut;
															#line 8851 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextVersion = mutations.top().next.version;
															#line 8853 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		streamsUsed.push_back(mutations.top());
															#line 8854 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		nextOut.push_back_deep(nextOut.arena(), mutations.top().next);
															#line 8855 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		mutations.pop();
															#line 8858 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(;!mutations.empty() && mutations.top().next.version == nextVersion;) {
															#line 8859 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (mutations.top().next.mutations.size() && mutations.top().next.mutations.front().param1 != lastEpochEndPrivateKey)
															#line 46877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8861 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				nextOut.back().mutations.append_deep( nextOut.arena(), mutations.top().next.mutations.begin(), mutations.top().next.mutations.size());
															#line 46881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8864 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			streamsUsed.push_back(mutations.top());
															#line 8865 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			mutations.pop();
															#line 46887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8868 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(nextOut.size() == 1);
															#line 8869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(nextVersion >= *begin);
															#line 8871 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		*begin = nextVersion + 1;
															#line 8873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (DEBUG_CF_CLIENT_TRACE)
															#line 46897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8874 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorSending", mergeCursorUID) .detail("Count", streamsUsed.size()) .detail("Version", nextVersion);
															#line 46901 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8880 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nextOut.back().mutations.empty())
															#line 46905 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8881 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(results->mutations.isEmpty());
															#line 46909 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1cont3loopBody1cont4(loopDepth);
		}
		else
		{
															#line 8883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(nextOut.back().version > results->lastReturnedVersion.get());
															#line 8885 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->mutations.send(nextOut);
															#line 8886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = results->mutations.onEmpty();
															#line 8886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 46922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont2when1(__when_expr_4.get(), loopDepth); };
			static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 5;
															#line 8886 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 46927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont3loopBody1cont4(int loopDepth) 
	{
															#line 8890 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (nextVersion > results->lastReturnedVersion.get())
															#line 47000 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8891 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->lastReturnedVersion.set(nextVersion);
															#line 47004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		if (loopDepth == 0) return a_body1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont9(Void const& _,int loopDepth) 
	{
															#line 8887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_5 = delay(0);
															#line 8887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 47016 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont9when1(__when_expr_5.get(), loopDepth); };
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 6;
															#line 8887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 47021 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont9(Void && _,int loopDepth) 
	{
															#line 8887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_5 = delay(0);
															#line 8887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 47032 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1cont9when1(__when_expr_5.get(), loopDepth); };
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 6;
															#line 8887 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >*>(static_cast<MergeChangeFeedStreamInternalActor*>(this)));
															#line 47037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont3loopBody1cont10(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont10(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont9when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont10(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont9when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont10(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<MergeChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<MergeChangeFeedStreamInternalActor*>(this)->ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3loopBody1cont9when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3loopBody1cont9when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);

	}
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> results;
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<std::pair<StorageServerInterface, KeyRange>> interfs;
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<MutationAndVersionStream> streams;
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version* begin;
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version end;
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID mergeCursorUID;
															#line 8788 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<Void> refresh;
															#line 8791 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::priority_queue<MutationAndVersionStream, std::vector<MutationAndVersionStream>> mutations;
															#line 8815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int interfNum;
															#line 8817 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<MutationAndVersionStream> streamsUsed;
															#line 8823 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version nextVersion;
															#line 47202 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via mergeChangeFeedStreamInternal()
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MergeChangeFeedStreamInternalActor final : public Actor<Void>, public ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >, public ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >, public ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >, public ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >, public ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >, public ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >, public FastAllocated<MergeChangeFeedStreamInternalActor>, public MergeChangeFeedStreamInternalActorState<MergeChangeFeedStreamInternalActor> {
															#line 47207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<MergeChangeFeedStreamInternalActor>::operator new;
	using FastAllocated<MergeChangeFeedStreamInternalActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >;
friend struct ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >;
friend struct ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >;
friend struct ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >;
friend struct ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >;
friend struct ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >;
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MergeChangeFeedStreamInternalActor(Reference<ChangeFeedData> const& results,std::vector<std::pair<StorageServerInterface, KeyRange>> const& interfs,std::vector<MutationAndVersionStream> const& streams,Version* const& begin,Version const& end,UID const& mergeCursorUID) 
															#line 47223 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   MergeChangeFeedStreamInternalActorState<MergeChangeFeedStreamInternalActor>(results, interfs, streams, begin, end, mergeCursorUID)
	{
		fdb_probe_actor_enter("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("mergeChangeFeedStreamInternal");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("mergeChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MergeChangeFeedStreamInternalActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< MergeChangeFeedStreamInternalActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorSingleCallback< MergeChangeFeedStreamInternalActor, 2, Standalone<MutationsAndVersionRef> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< MergeChangeFeedStreamInternalActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< MergeChangeFeedStreamInternalActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< MergeChangeFeedStreamInternalActor, 5, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> mergeChangeFeedStreamInternal( Reference<ChangeFeedData> const& results, std::vector<std::pair<StorageServerInterface, KeyRange>> const& interfs, std::vector<MutationAndVersionStream> const& streams, Version* const& begin, Version const& end, UID const& mergeCursorUID ) {
															#line 8782 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new MergeChangeFeedStreamInternalActor(results, interfs, streams, begin, end, mergeCursorUID));
															#line 47256 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8895 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 47261 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via mergeChangeFeedStream()
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class MergeChangeFeedStreamActor>
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MergeChangeFeedStreamActorState {
															#line 47268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MergeChangeFeedStreamActorState(Reference<DatabaseContext> const& db,std::vector<std::pair<StorageServerInterface, KeyRange>> const& interfs,Reference<ChangeFeedData> const& results,Key const& rangeID,Version* const& begin,Version const& end,int const& replyBufferSize,bool const& canReadPopped) 
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   interfs(interfs),
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(results),
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeID(rangeID),
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   replyBufferSize(replyBufferSize),
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   canReadPopped(canReadPopped),
															#line 8904 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   fetchers(interfs.size()),
															#line 8905 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   onErrors(interfs.size()),
															#line 8906 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   streams(interfs.size())
															#line 47295 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this));

	}
	~MergeChangeFeedStreamActorState() 
	{
		fdb_probe_actor_destroy("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8908 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(interfs.size() > 10);
															#line 8909 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(interfs.size() > 100);
															#line 8911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			mergeCursorUID = UID();
															#line 8912 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			debugUIDs = std::vector<UID>();
															#line 8913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->streams.clear();
															#line 8914 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : interfs ) {
															#line 8915 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				ChangeFeedStreamRequest req;
															#line 8916 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.rangeID = rangeID;
															#line 8917 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.begin = *begin;
															#line 8918 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.end = end;
															#line 8919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.range = it.second;
															#line 8920 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.canReadPopped = canReadPopped;
															#line 8922 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.replyBufferSize = replyBufferSize / interfs.size();
															#line 8923 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (replyBufferSize != -1 && req.replyBufferSize < CLIENT_KNOBS->CHANGE_FEED_STREAM_MIN_BYTES)
															#line 47336 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8924 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					req.replyBufferSize = CLIENT_KNOBS->CHANGE_FEED_STREAM_MIN_BYTES;
															#line 47340 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 8926 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				req.debugUID = deterministicRandom()->randomUniqueID();
															#line 8927 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				debugUIDs.push_back(req.debugUID);
															#line 8928 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				mergeCursorUID = UID(mergeCursorUID.first() ^ req.debugUID.first(), mergeCursorUID.second() ^ req.debugUID.second());
															#line 8931 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->streams.push_back(it.first.changeFeedStream.getReplyStream(req));
															#line 47350 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8934 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : results->storageData ) {
															#line 8935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (it->debugGetReferenceCount() == 2)
															#line 47356 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8936 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					db->changeFeedUpdaters.erase(it->interfToken);
															#line 47360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 8939 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->maxSeenVersion = invalidVersion;
															#line 8940 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->storageData.clear();
															#line 8941 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Promise<Void> refresh = results->refresh;
															#line 8942 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->refresh = Promise<Void>();
															#line 8943 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < interfs.size();i++) {
															#line 8944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->storageData.push_back(db->getStorageData(interfs[i].first));
															#line 47375 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8946 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->notAtLatest.set(interfs.size());
															#line 8947 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			refresh.send(Void());
															#line 8949 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < interfs.size();i++) {
															#line 8950 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (DEBUG_CF_CLIENT_TRACE)
															#line 47385 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 8951 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TraceEvent(SevDebug, "TraceChangeFeedClientMergeCursorInit", debugUIDs[i]) .detail("CursorDebugUID", mergeCursorUID) .detail("Idx", i) .detail("FeedID", rangeID) .detail("MergeRange", KeyRangeRef(interfs.front().second.begin, interfs.back().second.end)) .detail("PartialRange", interfs[i].second) .detail("Begin", *begin) .detail("End", end) .detail("CanReadPopped", canReadPopped);
															#line 47389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 8961 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				onErrors[i] = results->streams[i].onError();
															#line 8962 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fetchers[i] = partialChangeFeedStream(interfs[i].first, streams[i].results, results->streams[i], *begin, end, results, results->storageData[i], debugUIDs[i]);
															#line 47395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 8972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = waitForAny(onErrors) || mergeChangeFeedStreamInternal(results, interfs, streams, begin, end, mergeCursorUID);
															#line 8972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<MergeChangeFeedStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 47401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<MergeChangeFeedStreamActor*>(this)->actor_wait_state = 1;
															#line 8972 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< MergeChangeFeedStreamActor, 0, Void >*>(static_cast<MergeChangeFeedStreamActor*>(this)));
															#line 47406 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~MergeChangeFeedStreamActorState();
		static_cast<MergeChangeFeedStreamActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 8974 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<MergeChangeFeedStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~MergeChangeFeedStreamActorState(); static_cast<MergeChangeFeedStreamActor*>(this)->destroy(); return 0; }
															#line 47429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<MergeChangeFeedStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~MergeChangeFeedStreamActorState();
		static_cast<MergeChangeFeedStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 8974 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<MergeChangeFeedStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~MergeChangeFeedStreamActorState(); static_cast<MergeChangeFeedStreamActor*>(this)->destroy(); return 0; }
															#line 47441 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<MergeChangeFeedStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~MergeChangeFeedStreamActorState();
		static_cast<MergeChangeFeedStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<MergeChangeFeedStreamActor*>(this)->actor_wait_state > 0) static_cast<MergeChangeFeedStreamActor*>(this)->actor_wait_state = 0;
		static_cast<MergeChangeFeedStreamActor*>(this)->ActorCallback< MergeChangeFeedStreamActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< MergeChangeFeedStreamActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< MergeChangeFeedStreamActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<std::pair<StorageServerInterface, KeyRange>> interfs;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> results;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeID;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version* begin;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version end;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int replyBufferSize;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool canReadPopped;
															#line 8904 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<Void>> fetchers;
															#line 8905 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<Void>> onErrors;
															#line 8906 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<MutationAndVersionStream> streams;
															#line 8911 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	UID mergeCursorUID;
															#line 8912 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<UID> debugUIDs;
															#line 47538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via mergeChangeFeedStream()
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class MergeChangeFeedStreamActor final : public Actor<Void>, public ActorCallback< MergeChangeFeedStreamActor, 0, Void >, public FastAllocated<MergeChangeFeedStreamActor>, public MergeChangeFeedStreamActorState<MergeChangeFeedStreamActor> {
															#line 47543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<MergeChangeFeedStreamActor>::operator new;
	using FastAllocated<MergeChangeFeedStreamActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< MergeChangeFeedStreamActor, 0, Void >;
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	MergeChangeFeedStreamActor(Reference<DatabaseContext> const& db,std::vector<std::pair<StorageServerInterface, KeyRange>> const& interfs,Reference<ChangeFeedData> const& results,Key const& rangeID,Version* const& begin,Version const& end,int const& replyBufferSize,bool const& canReadPopped) 
															#line 47554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   MergeChangeFeedStreamActorState<MergeChangeFeedStreamActor>(db, interfs, results, rangeID, begin, end, replyBufferSize, canReadPopped)
	{
		fdb_probe_actor_enter("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("mergeChangeFeedStream");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("mergeChangeFeedStream", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< MergeChangeFeedStreamActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> mergeChangeFeedStream( Reference<DatabaseContext> const& db, std::vector<std::pair<StorageServerInterface, KeyRange>> const& interfs, Reference<ChangeFeedData> const& results, Key const& rangeID, Version* const& begin, Version const& end, int const& replyBufferSize, bool const& canReadPopped ) {
															#line 8896 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new MergeChangeFeedStreamActor(db, interfs, results, rangeID, begin, end, replyBufferSize, canReadPopped));
															#line 47582 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 8976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 47587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getChangeFeedRange()
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetChangeFeedRangeActor>
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetChangeFeedRangeActorState {
															#line 47594 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetChangeFeedRangeActorState(Reference<DatabaseContext> const& db,Database const& cx,Key const& rangeID,Version const& begin = 0) 
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(cx),
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeID(rangeID),
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 8978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(cx),
															#line 8979 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeIDKey(rangeID.withPrefix(changeFeedPrefix))
															#line 47611 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getChangeFeedRange", reinterpret_cast<unsigned long>(this));

	}
	~GetChangeFeedRangeActorState() 
	{
		fdb_probe_actor_destroy("getChangeFeedRange", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 8981 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			auto cacheLoc = db->changeFeedCache.find(rangeID);
															#line 8982 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (cacheLoc != db->changeFeedCache.end())
															#line 47628 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 8983 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<GetChangeFeedRangeActor*>(this)->SAV<KeyRange>::futures) { (void)(cacheLoc->second); this->~GetChangeFeedRangeActorState(); static_cast<GetChangeFeedRangeActor*>(this)->destroy(); return 0; }
															#line 47632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<GetChangeFeedRangeActor*>(this)->SAV< KeyRange >::value()) KeyRange(cacheLoc->second);
				this->~GetChangeFeedRangeActorState();
				static_cast<GetChangeFeedRangeActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 8986 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 47640 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetChangeFeedRangeActorState();
		static_cast<GetChangeFeedRangeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 8988 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::READ_SYSTEM_KEYS);
															#line 8989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Version> __when_expr_0 = tr.getReadVersion();
															#line 8989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 47675 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 1;
															#line 8989 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedRangeActor, 0, Version >*>(static_cast<GetChangeFeedRangeActor*>(this)));
															#line 47680 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9006 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr.onError(e);
															#line 9006 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 47704 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 4;
															#line 9006 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedRangeActor, 3, Void >*>(static_cast<GetChangeFeedRangeActor*>(this)));
															#line 47709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Version const& readVer,int loopDepth) 
	{
															#line 8990 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (readVer < begin)
															#line 47724 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 8991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 47730 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
			static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 2;
															#line 8991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedRangeActor, 1, Void >*>(static_cast<GetChangeFeedRangeActor*>(this)));
															#line 47735 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 8994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_2 = tr.get(rangeIDKey);
															#line 8994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 47744 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when2(__when_expr_2.get(), loopDepth); };
			static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 3;
															#line 8994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >*>(static_cast<GetChangeFeedRangeActor*>(this)));
															#line 47749 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Version && readVer,int loopDepth) 
	{
															#line 8990 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (readVer < begin)
															#line 47759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 8991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 47765 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
			static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 2;
															#line 8991 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedRangeActor, 1, Void >*>(static_cast<GetChangeFeedRangeActor*>(this)));
															#line 47770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 8994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_2 = tr.get(rangeIDKey);
															#line 8994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 47779 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2when2(__when_expr_2.get(), loopDepth); };
			static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 3;
															#line 8994 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >*>(static_cast<GetChangeFeedRangeActor*>(this)));
															#line 47784 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(Version const& readVer,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(readVer, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Version && readVer,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(readVer), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedRangeActor*>(this)->ActorCallback< GetChangeFeedRangeActor, 0, Version >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 0, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 0, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetChangeFeedRangeActor, 0, Version >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void const& _,int loopDepth) 
	{
															#line 8992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr.reset();
															#line 47863 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void && _,int loopDepth) 
	{
															#line 8992 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr.reset();
															#line 47872 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedRangeActor*>(this)->ActorCallback< GetChangeFeedRangeActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetChangeFeedRangeActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont6(Optional<Value> const& val,int loopDepth) 
	{
															#line 8995 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!val.present())
															#line 47944 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1Catch1(change_feed_not_registered(), loopDepth);
															#line 47948 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8998 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (db->changeFeedCache.size() > CLIENT_KNOBS->CHANGE_FEED_CACHE_SIZE)
															#line 47952 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8999 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			db->changeFeedCache.clear();
															#line 47956 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9001 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRange range = std::get<0>(decodeChangeFeedValue(val.get()));
															#line 9002 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		db->changeFeedCache[rangeID] = range;
															#line 9003 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetChangeFeedRangeActor*>(this)->SAV<KeyRange>::futures) { (void)(range); this->~GetChangeFeedRangeActorState(); static_cast<GetChangeFeedRangeActor*>(this)->destroy(); return 0; }
															#line 47964 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetChangeFeedRangeActor*>(this)->SAV< KeyRange >::value()) KeyRange(range);
		this->~GetChangeFeedRangeActorState();
		static_cast<GetChangeFeedRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont6(Optional<Value> && val,int loopDepth) 
	{
															#line 8995 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!val.present())
															#line 47976 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1Catch1(change_feed_not_registered(), loopDepth);
															#line 47980 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 8998 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (db->changeFeedCache.size() > CLIENT_KNOBS->CHANGE_FEED_CACHE_SIZE)
															#line 47984 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 8999 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			db->changeFeedCache.clear();
															#line 47988 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9001 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		KeyRange range = std::get<0>(decodeChangeFeedValue(val.get()));
															#line 9002 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		db->changeFeedCache[rangeID] = range;
															#line 9003 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetChangeFeedRangeActor*>(this)->SAV<KeyRange>::futures) { (void)(range); this->~GetChangeFeedRangeActorState(); static_cast<GetChangeFeedRangeActor*>(this)->destroy(); return 0; }
															#line 47996 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetChangeFeedRangeActor*>(this)->SAV< KeyRange >::value()) KeyRange(range);
		this->~GetChangeFeedRangeActorState();
		static_cast<GetChangeFeedRangeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(Optional<Value> const& val,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(val, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when2(Optional<Value> && val,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedRangeActor*>(this)->ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont10(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedRangeActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedRangeActor*>(this)->ActorCallback< GetChangeFeedRangeActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedRangeActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetChangeFeedRangeActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeID;
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version begin;
															#line 8978 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 8979 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeIDKey;
															#line 48167 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getChangeFeedRange()
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetChangeFeedRangeActor final : public Actor<KeyRange>, public ActorCallback< GetChangeFeedRangeActor, 0, Version >, public ActorCallback< GetChangeFeedRangeActor, 1, Void >, public ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >, public ActorCallback< GetChangeFeedRangeActor, 3, Void >, public FastAllocated<GetChangeFeedRangeActor>, public GetChangeFeedRangeActorState<GetChangeFeedRangeActor> {
															#line 48172 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetChangeFeedRangeActor>::operator new;
	using FastAllocated<GetChangeFeedRangeActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<KeyRange>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetChangeFeedRangeActor, 0, Version >;
friend struct ActorCallback< GetChangeFeedRangeActor, 1, Void >;
friend struct ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >;
friend struct ActorCallback< GetChangeFeedRangeActor, 3, Void >;
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetChangeFeedRangeActor(Reference<DatabaseContext> const& db,Database const& cx,Key const& rangeID,Version const& begin = 0) 
															#line 48186 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<KeyRange>(),
		   GetChangeFeedRangeActorState<GetChangeFeedRangeActor>(db, cx, rangeID, begin)
	{
		fdb_probe_actor_enter("getChangeFeedRange", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getChangeFeedRange");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getChangeFeedRange", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetChangeFeedRangeActor, 0, Version >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetChangeFeedRangeActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetChangeFeedRangeActor, 2, Optional<Value> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetChangeFeedRangeActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<KeyRange> getChangeFeedRange( Reference<DatabaseContext> const& db, Database const& cx, Key const& rangeID, Version const& begin = 0 ) {
															#line 8977 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<KeyRange>(new GetChangeFeedRangeActor(db, cx, rangeID, begin));
															#line 48217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9010 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 48222 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via singleChangeFeedStreamInternal()
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SingleChangeFeedStreamInternalActor>
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SingleChangeFeedStreamInternalActorState {
															#line 48229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SingleChangeFeedStreamInternalActorState(KeyRange const& range,Reference<ChangeFeedData> const& results,Key const& rangeID,Version* const& begin,Version const& end) 
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : range(range),
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(results),
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeID(rangeID),
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 9017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   refresh(results->refresh)
															#line 48246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this));

	}
	~SingleChangeFeedStreamInternalActorState() 
	{
		fdb_probe_actor_destroy("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9018 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(results->streams.size() == 1);
															#line 9019 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(results->storageData.size() == 1);
															#line 9020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			atLatest = false;
															#line 9023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = results->mutations.onEmpty();
															#line 9023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 48269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 1;
															#line 9023 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48274 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SingleChangeFeedStreamInternalActorState();
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 9024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = delay(0);
															#line 9024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 48299 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 2;
															#line 9024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48304 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 9024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = delay(0);
															#line 9024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 48315 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 2;
															#line 9024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48320 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 9025 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(results->mutations.isEmpty());
															#line 9027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (*begin - 1 > results->lastReturnedVersion.get())
															#line 48394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->lastReturnedVersion.set(*begin - 1);
															#line 48398 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 48402 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 9025 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(results->mutations.isEmpty());
															#line 9027 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (*begin - 1 > results->lastReturnedVersion.get())
															#line 48413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->lastReturnedVersion.set(*begin - 1);
															#line 48417 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9031 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 48421 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1(int loopDepth) 
	{
															#line 9033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		FutureStream<ChangeFeedStreamReply> __when_expr_2 = results->streams[0].getFuture();
															#line 9033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 48502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1when1(__when_expr_2.pop(), loopDepth); };
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 3;
															#line 9033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1(int loopDepth) 
	{
															#line 9034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		*begin = feedReply.mutations.back().version + 1;
															#line 9036 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (feedReply.popVersion > results->popVersion)
															#line 48518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9037 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->popVersion = feedReply.popVersion;
															#line 48522 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9041 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool anyMutations = false;
															#line 9042 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& it : feedReply.mutations ) {
															#line 9043 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!it.mutations.empty())
															#line 48530 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9044 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				anyMutations = true;
															#line 48534 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				break;
			}
		}
															#line 9048 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (anyMutations)
															#line 48540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9051 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(feedReply.mutations.front().version > results->lastReturnedVersion.get());
															#line 9053 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->mutations.send( Standalone<VectorRef<MutationsAndVersionRef>>(feedReply.mutations, feedReply.arena));
															#line 9057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = results->mutations.onEmpty();
															#line 9057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 48550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1cont1when1(__when_expr_3.get(), loopDepth); };
			static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 4;
															#line 9057 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont2loopBody1cont2(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(ChangeFeedStreamReply const& __feedReply,int loopDepth) 
	{
															#line 9033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		feedReply = __feedReply;
															#line 48569 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(ChangeFeedStreamReply && __feedReply,int loopDepth) 
	{
		feedReply = std::move(__feedReply);
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >::remove();

	}
	void a_callback_fire(ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >*,ChangeFeedStreamReply const& value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >*,ChangeFeedStreamReply && value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >*,Error err) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont2loopBody1cont2(int loopDepth) 
	{
															#line 9063 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (feedReply.mutations.back().version > results->lastReturnedVersion.get())
															#line 48636 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9064 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->lastReturnedVersion.set(feedReply.mutations.back().version);
															#line 48640 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9067 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!refresh.canBeSet())
															#line 48644 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			try {
															#line 9070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_5 = Future<Void>(Void());
															#line 9070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont2Catch1(actor_cancelled(), loopDepth);
															#line 48651 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont2loopBody1cont2Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_5.get(), loopDepth); };
				static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 6;
															#line 9070 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48656 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			catch (Error& error) {
				loopDepth = a_body1cont2loopBody1cont2Catch1(error, loopDepth);
			} catch (...) {
				loopDepth = a_body1cont2loopBody1cont2Catch1(unknown_error(), loopDepth);
			}
		}
		else
		{
			loopDepth = a_body1cont2loopBody1cont8(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont6(Void const& _,int loopDepth) 
	{
															#line 9058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_4 = delay(0);
															#line 9058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 48678 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1cont6when1(__when_expr_4.get(), loopDepth); };
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 5;
															#line 9058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48683 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont6(Void && _,int loopDepth) 
	{
															#line 9058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_4 = delay(0);
															#line 9058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 48694 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1cont6when1(__when_expr_4.get(), loopDepth); };
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 5;
															#line 9058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >*>(static_cast<SingleChangeFeedStreamInternalActor*>(this)));
															#line 48699 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont2loopBody1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont2loopBody1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont2loopBody1cont7(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont7(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont6when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont6when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1cont6when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1cont6when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont2loopBody1cont8(int loopDepth) 
	{
															#line 9079 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!atLatest && feedReply.atLatestVersion)
															#line 48846 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9080 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			atLatest = true;
															#line 9081 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->notAtLatest.set(0);
															#line 48852 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9084 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (feedReply.minStreamVersion > results->storageData[0]->version.get())
															#line 48856 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9085 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->storageData[0]->version.set(feedReply.minStreamVersion);
															#line 48860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		if (loopDepth == 0) return a_body1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont10(int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont8(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9074 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT(e.code() == error_code_actor_cancelled);
															#line 9075 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 48879 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont11(Void const& _,int loopDepth) 
	{
															#line 9072 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(false);
															#line 48893 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont11cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont11(Void && _,int loopDepth) 
	{
															#line 9072 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		ASSERT(false);
															#line 48902 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont11cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont11(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont11(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state > 0) static_cast<SingleChangeFeedStreamInternalActor*>(this)->actor_wait_state = 0;
		static_cast<SingleChangeFeedStreamInternalActor*>(this)->ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont2Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont2Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont2Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont2loopBody1cont11cont2(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont2loopBody1cont10(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange range;
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> results;
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeID;
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version* begin;
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version end;
															#line 9017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Promise<Void> refresh;
															#line 9020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool atLatest;
															#line 9033 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedStreamReply feedReply;
															#line 48999 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via singleChangeFeedStreamInternal()
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SingleChangeFeedStreamInternalActor final : public Actor<Void>, public ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >, public ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >, public ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >, public ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >, public ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >, public ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >, public FastAllocated<SingleChangeFeedStreamInternalActor>, public SingleChangeFeedStreamInternalActorState<SingleChangeFeedStreamInternalActor> {
															#line 49004 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SingleChangeFeedStreamInternalActor>::operator new;
	using FastAllocated<SingleChangeFeedStreamInternalActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >;
friend struct ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >;
friend struct ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >;
friend struct ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >;
friend struct ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >;
friend struct ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >;
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SingleChangeFeedStreamInternalActor(KeyRange const& range,Reference<ChangeFeedData> const& results,Key const& rangeID,Version* const& begin,Version const& end) 
															#line 49020 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   SingleChangeFeedStreamInternalActorState<SingleChangeFeedStreamInternalActor>(range, results, rangeID, begin, end)
	{
		fdb_probe_actor_enter("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("singleChangeFeedStreamInternal");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("singleChangeFeedStreamInternal", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SingleChangeFeedStreamInternalActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SingleChangeFeedStreamInternalActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorSingleCallback< SingleChangeFeedStreamInternalActor, 2, ChangeFeedStreamReply >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< SingleChangeFeedStreamInternalActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< SingleChangeFeedStreamInternalActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< SingleChangeFeedStreamInternalActor, 5, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> singleChangeFeedStreamInternal( KeyRange const& range, Reference<ChangeFeedData> const& results, Key const& rangeID, Version* const& begin, Version const& end ) {
															#line 9011 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new SingleChangeFeedStreamInternalActor(range, results, rangeID, begin, end));
															#line 49053 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9089 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 49058 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via singleChangeFeedStream()
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SingleChangeFeedStreamActor>
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SingleChangeFeedStreamActorState {
															#line 49065 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SingleChangeFeedStreamActorState(Reference<DatabaseContext> const& db,StorageServerInterface const& interf,KeyRange const& range,Reference<ChangeFeedData> const& results,Key const& rangeID,Version* const& begin,Version const& end,int const& replyBufferSize,bool const& canReadPopped) 
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   interf(interf),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(results),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeID(rangeID),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   replyBufferSize(replyBufferSize),
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   canReadPopped(canReadPopped),
															#line 9099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(db),
															#line 9100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   req()
															#line 49092 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("singleChangeFeedStream", reinterpret_cast<unsigned long>(this));

	}
	~SingleChangeFeedStreamActorState() 
	{
		fdb_probe_actor_destroy("singleChangeFeedStream", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9101 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.rangeID = rangeID;
															#line 9102 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.begin = *begin;
															#line 9103 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.end = end;
															#line 9104 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.range = range;
															#line 9105 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.canReadPopped = canReadPopped;
															#line 9106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.replyBufferSize = replyBufferSize;
															#line 9107 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.debugUID = deterministicRandom()->randomUniqueID();
															#line 9109 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (DEBUG_CF_CLIENT_TRACE)
															#line 49121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9110 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				TraceEvent(SevDebug, "TraceChangeFeedClientSingleCursor", req.debugUID) .detail("FeedID", rangeID) .detail("Range", range) .detail("Begin", *begin) .detail("End", end) .detail("CanReadPopped", canReadPopped);
															#line 49125 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9118 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->streams.clear();
															#line 9120 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for( auto& it : results->storageData ) {
															#line 9121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (it->debugGetReferenceCount() == 2)
															#line 49133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 9122 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					db->changeFeedUpdaters.erase(it->interfToken);
															#line 49137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 9125 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->streams.push_back(interf.changeFeedStream.getReplyStream(req));
															#line 9127 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->maxSeenVersion = invalidVersion;
															#line 9128 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->storageData.clear();
															#line 9129 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->storageData.push_back(db->getStorageData(interf));
															#line 9130 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Promise<Void> refresh = results->refresh;
															#line 9131 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->refresh = Promise<Void>();
															#line 9132 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->notAtLatest.set(1);
															#line 9133 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			refresh.send(Void());
															#line 9135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = results->streams[0].onError() || singleChangeFeedStreamInternal(range, results, rangeID, begin, end);
															#line 9135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SingleChangeFeedStreamActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 49160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SingleChangeFeedStreamActor*>(this)->actor_wait_state = 1;
															#line 9135 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SingleChangeFeedStreamActor, 0, Void >*>(static_cast<SingleChangeFeedStreamActor*>(this)));
															#line 49165 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SingleChangeFeedStreamActorState();
		static_cast<SingleChangeFeedStreamActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 9137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SingleChangeFeedStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SingleChangeFeedStreamActorState(); static_cast<SingleChangeFeedStreamActor*>(this)->destroy(); return 0; }
															#line 49188 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SingleChangeFeedStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SingleChangeFeedStreamActorState();
		static_cast<SingleChangeFeedStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 9137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SingleChangeFeedStreamActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SingleChangeFeedStreamActorState(); static_cast<SingleChangeFeedStreamActor*>(this)->destroy(); return 0; }
															#line 49200 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SingleChangeFeedStreamActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SingleChangeFeedStreamActorState();
		static_cast<SingleChangeFeedStreamActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SingleChangeFeedStreamActor*>(this)->actor_wait_state > 0) static_cast<SingleChangeFeedStreamActor*>(this)->actor_wait_state = 0;
		static_cast<SingleChangeFeedStreamActor*>(this)->ActorCallback< SingleChangeFeedStreamActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SingleChangeFeedStreamActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SingleChangeFeedStreamActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	StorageServerInterface interf;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange range;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> results;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeID;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version* begin;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version end;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int replyBufferSize;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool canReadPopped;
															#line 9099 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9100 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	ChangeFeedStreamRequest req;
															#line 49293 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via singleChangeFeedStream()
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SingleChangeFeedStreamActor final : public Actor<Void>, public ActorCallback< SingleChangeFeedStreamActor, 0, Void >, public FastAllocated<SingleChangeFeedStreamActor>, public SingleChangeFeedStreamActorState<SingleChangeFeedStreamActor> {
															#line 49298 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SingleChangeFeedStreamActor>::operator new;
	using FastAllocated<SingleChangeFeedStreamActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SingleChangeFeedStreamActor, 0, Void >;
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SingleChangeFeedStreamActor(Reference<DatabaseContext> const& db,StorageServerInterface const& interf,KeyRange const& range,Reference<ChangeFeedData> const& results,Key const& rangeID,Version* const& begin,Version const& end,int const& replyBufferSize,bool const& canReadPopped) 
															#line 49309 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   SingleChangeFeedStreamActorState<SingleChangeFeedStreamActor>(db, interf, range, results, rangeID, begin, end, replyBufferSize, canReadPopped)
	{
		fdb_probe_actor_enter("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("singleChangeFeedStream");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("singleChangeFeedStream", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SingleChangeFeedStreamActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> singleChangeFeedStream( Reference<DatabaseContext> const& db, StorageServerInterface const& interf, KeyRange const& range, Reference<ChangeFeedData> const& results, Key const& rangeID, Version* const& begin, Version const& end, int const& replyBufferSize, bool const& canReadPopped ) {
															#line 9090 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new SingleChangeFeedStreamActor(db, interf, range, results, rangeID, begin, end, replyBufferSize, canReadPopped));
															#line 49337 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9139 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 49342 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getChangeFeedStreamActor()
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetChangeFeedStreamActorActor>
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetChangeFeedStreamActorActorState {
															#line 49349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetChangeFeedStreamActorActorState(Reference<DatabaseContext> const& db,Reference<ChangeFeedData> const& results,Key const& rangeID,Version const& begin,Version const& end,KeyRange const& range,int const& replyBufferSize,bool const& canReadPopped) 
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   results(results),
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeID(rangeID),
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   begin(begin),
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   end(end),
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   replyBufferSize(replyBufferSize),
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   canReadPopped(canReadPopped),
															#line 9148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(db),
															#line 9149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:GetChangeFeedStream"_loc)
															#line 49374 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this));

	}
	~GetChangeFeedStreamActorActorState() 
	{
		fdb_probe_actor_destroy("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9151 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			results->endVersion = end;
															#line 9153 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			sleepWithBackoff = CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY;
															#line 9154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			lastBeginVersion = invalidVersion;
															#line 9156 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 49395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetChangeFeedStreamActorActorState();
		static_cast<GetChangeFeedStreamActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 9157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		keys = KeyRange();
															#line 49425 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		try {
															#line 9159 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			lastBeginVersion = begin;
															#line 9160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<KeyRange> __when_expr_0 = getChangeFeedRange(db, cx, rangeID, begin);
															#line 9160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 49433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 1;
															#line 9160 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >*>(static_cast<GetChangeFeedStreamActorActor*>(this)));
															#line 49438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9240 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_actor_cancelled || e.code() == error_code_change_feed_popped)
															#line 49460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9241 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for( auto& it : results->storageData ) {
															#line 9242 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (it->debugGetReferenceCount() == 2)
															#line 49466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 9243 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						db->changeFeedUpdaters.erase(it->interfToken);
															#line 49470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
															#line 9246 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->streams.clear();
															#line 9247 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->storageData.clear();
															#line 9248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (e.code() == error_code_change_feed_popped)
															#line 49479 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 9249 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					TEST(true);
															#line 9250 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					results->mutations.sendError(e);
															#line 9251 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					results->refresh.sendError(e);
															#line 49487 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 9253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					results->refresh.sendError(change_feed_cancelled());
															#line 49493 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 9255 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 49497 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9257 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (results->notAtLatest.get() == 0)
															#line 49501 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9258 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->notAtLatest.set(1);
															#line 49505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9261 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed || e.code() == error_code_connection_failed || e.code() == error_code_unknown_change_feed || e.code() == error_code_broken_promise)
															#line 49509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9264 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				db->changeFeedCache.erase(rangeID);
															#line 9265 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->invalidateCache(Key(), keys);
															#line 9266 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (begin == lastBeginVersion)
															#line 49517 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 9269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					sleepWithBackoff = std::min(1.0, sleepWithBackoff * 1.5);
															#line 49521 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
				else
				{
															#line 9271 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					sleepWithBackoff = CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY;
															#line 49527 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
															#line 9273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_5 = delay(sleepWithBackoff);
															#line 9273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 49533 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_5.get(), loopDepth); };
				static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 6;
															#line 9273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedStreamActorActor, 5, Void >*>(static_cast<GetChangeFeedStreamActorActor*>(this)));
															#line 49538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 9275 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->mutations.sendError(e);
															#line 9276 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->refresh.sendError(change_feed_cancelled());
															#line 9277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for( auto& it : results->storageData ) {
															#line 9278 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					if (it->debugGetReferenceCount() == 2)
															#line 49551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					{
															#line 9279 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
						db->changeFeedUpdaters.erase(it->interfToken);
															#line 49555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
					}
				}
															#line 9282 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->streams.clear();
															#line 9283 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				results->storageData.clear();
															#line 9284 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (!static_cast<GetChangeFeedStreamActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~GetChangeFeedStreamActorActorState(); static_cast<GetChangeFeedStreamActorActor*>(this)->destroy(); return 0; }
															#line 49564 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				new (&static_cast<GetChangeFeedStreamActorActor*>(this)->SAV< Void >::value()) Void(Void());
				this->~GetChangeFeedStreamActorActorState();
				static_cast<GetChangeFeedStreamActorActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(KeyRange const& fullRange,int loopDepth) 
	{
															#line 9161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		keys = fullRange & range;
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_1 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, CLIENT_KNOBS->CHANGE_FEED_LOCATION_LIMIT, Reverse::False, &StorageServerInterface::changeFeedStream, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 49587 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 2;
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetChangeFeedStreamActorActor*>(this)));
															#line 49592 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(KeyRange && fullRange,int loopDepth) 
	{
															#line 9161 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		keys = fullRange & range;
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_1 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, CLIENT_KNOBS->CHANGE_FEED_LOCATION_LIMIT, Reverse::False, &StorageServerInterface::changeFeedStream, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 49605 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 2;
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetChangeFeedStreamActorActor*>(this)));
															#line 49610 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(KeyRange const& fullRange,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(fullRange, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(KeyRange && fullRange,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(fullRange), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedStreamActorActor*>(this)->ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >*,KeyRange const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >*,KeyRange && value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
															#line 9174 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() >= CLIENT_KNOBS->CHANGE_FEED_LOCATION_LIMIT)
															#line 49682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9175 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ASSERT_WE_THINK(false);
															#line 9176 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1Catch1(unknown_change_feed(), loopDepth);
															#line 49688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		chosenLocations = std::vector<int>(locations.size());
															#line 9180 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		loc = 0;
															#line 9181 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		;
															#line 49696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 49705 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedStreamActorActor*>(this)->ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
															#line 9221 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() > 1)
															#line 49772 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9222 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::vector<std::pair<StorageServerInterface, KeyRange>> interfs;
															#line 9223 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < locations.size();i++) {
															#line 9224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				interfs.emplace_back(locations[i].locations->getInterface(chosenLocations[i]), locations[i].range & range);
															#line 49780 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 9229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = mergeChangeFeedStream(db, interfs, results, rangeID, &begin, end, replyBufferSize, canReadPopped) || cx->connectionFileChanged();
															#line 9229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 49788 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont4when1(__when_expr_3.get(), loopDepth); };
			static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 4;
															#line 9229 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedStreamActorActor, 3, Void >*>(static_cast<GetChangeFeedStreamActorActor*>(this)));
															#line 49793 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 9233 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TEST(true);
															#line 9234 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StorageServerInterface interf = locations[0].locations->getInterface(chosenLocations[0]);
															#line 9235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = singleChangeFeedStream( db, interf, range, results, rangeID, &begin, end, replyBufferSize, canReadPopped) || cx->connectionFileChanged();
															#line 9235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 49806 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont4when2(__when_expr_4.get(), loopDepth); };
			static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 5;
															#line 9235 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedStreamActorActor, 4, Void >*>(static_cast<GetChangeFeedStreamActorActor*>(this)));
															#line 49811 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont3loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3loopBody1(int loopDepth) 
	{
															#line 9181 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!(loc < locations.size()))
															#line 49828 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
			return a_body1loopBody1cont3break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 9184 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int count = 0;
															#line 9185 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		int useIdx = -1;
															#line 9186 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < locations[loc].locations->size();i++) {
															#line 9187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!IFailureMonitor::failureMonitor() .getState(locations[loc] .locations->get(i, &StorageServerInterface::changeFeedStream) .getEndpoint()) .failed)
															#line 49840 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9192 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (deterministicRandom()->random01() <= 1.0 / ++count)
															#line 49844 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 9193 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					useIdx = i;
															#line 49848 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 9198 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (useIdx >= 0)
															#line 49854 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9199 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			chosenLocations[loc] = useIdx;
															#line 9200 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			loc++;
															#line 49860 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			return a_body1loopBody1cont3loopHead1(loopDepth); // continue
		}
															#line 9204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<Future<Void>> ok(locations[loc].locations->size());
															#line 9205 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < ok.size();i++) {
															#line 9206 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ok[i] = IFailureMonitor::failureMonitor().onStateEqual( locations[loc].locations->get(i, &StorageServerInterface::changeFeedStream).getEndpoint(), FailureStatus(false));
															#line 49869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9212 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (now() - g_network->networkInfo.newestAlternativesFailure > 1 || deterministicRandom()->random01() < 0.01)
															#line 49873 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9214 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent("AllAlternativesFailed").detail("Alternatives", locations[0].locations->description());
															#line 49877 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = allAlternativesFailedDelay(quorum(ok, 1));
															#line 9217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 49883 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont3loopBody1when1(__when_expr_2.get(), loopDepth); };
		static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 3;
															#line 9217 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetChangeFeedStreamActorActor, 2, Void >*>(static_cast<GetChangeFeedStreamActorActor*>(this)));
															#line 49888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont3break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 9218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		loc = 0;
															#line 49910 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont3loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 9218 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		loc = 0;
															#line 49919 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopBody1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont3loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedStreamActorActor*>(this)->ActorCallback< GetChangeFeedStreamActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetChangeFeedStreamActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont7(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont7(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedStreamActorActor*>(this)->ActorCallback< GetChangeFeedStreamActorActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetChangeFeedStreamActorActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont9(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont9(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedStreamActorActor*>(this)->ActorCallback< GetChangeFeedStreamActorActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont4when2(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont4when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetChangeFeedStreamActorActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1loopBody1cont10(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont8(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont8(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state > 0) static_cast<GetChangeFeedStreamActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetChangeFeedStreamActorActor*>(this)->ActorCallback< GetChangeFeedStreamActorActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< GetChangeFeedStreamActorActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< GetChangeFeedStreamActorActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), 5);

	}
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ChangeFeedData> results;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeID;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version begin;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version end;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange range;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int replyBufferSize;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool canReadPopped;
															#line 9148 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9149 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 9153 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	double sleepWithBackoff;
															#line 9154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version lastBeginVersion;
															#line 9157 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 9162 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 9179 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<int> chosenLocations;
															#line 9180 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	int loc;
															#line 50269 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getChangeFeedStreamActor()
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetChangeFeedStreamActorActor final : public Actor<Void>, public ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >, public ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetChangeFeedStreamActorActor, 2, Void >, public ActorCallback< GetChangeFeedStreamActorActor, 3, Void >, public ActorCallback< GetChangeFeedStreamActorActor, 4, Void >, public ActorCallback< GetChangeFeedStreamActorActor, 5, Void >, public FastAllocated<GetChangeFeedStreamActorActor>, public GetChangeFeedStreamActorActorState<GetChangeFeedStreamActorActor> {
															#line 50274 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetChangeFeedStreamActorActor>::operator new;
	using FastAllocated<GetChangeFeedStreamActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >;
friend struct ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetChangeFeedStreamActorActor, 2, Void >;
friend struct ActorCallback< GetChangeFeedStreamActorActor, 3, Void >;
friend struct ActorCallback< GetChangeFeedStreamActorActor, 4, Void >;
friend struct ActorCallback< GetChangeFeedStreamActorActor, 5, Void >;
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetChangeFeedStreamActorActor(Reference<DatabaseContext> const& db,Reference<ChangeFeedData> const& results,Key const& rangeID,Version const& begin,Version const& end,KeyRange const& range,int const& replyBufferSize,bool const& canReadPopped) 
															#line 50290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   GetChangeFeedStreamActorActorState<GetChangeFeedStreamActorActor>(db, results, rangeID, begin, end, range, replyBufferSize, canReadPopped)
	{
		fdb_probe_actor_enter("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getChangeFeedStreamActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getChangeFeedStreamActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetChangeFeedStreamActorActor, 0, KeyRange >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetChangeFeedStreamActorActor, 1, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetChangeFeedStreamActorActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetChangeFeedStreamActorActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetChangeFeedStreamActorActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< GetChangeFeedStreamActorActor, 5, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> getChangeFeedStreamActor( Reference<DatabaseContext> const& db, Reference<ChangeFeedData> const& results, Key const& rangeID, Version const& begin, Version const& end, KeyRange const& range, int const& replyBufferSize, bool const& canReadPopped ) {
															#line 9140 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new GetChangeFeedStreamActorActor(db, results, rangeID, begin, end, range, replyBufferSize, canReadPopped));
															#line 50323 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9289 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> DatabaseContext::getChangeFeedStream(Reference<ChangeFeedData> results,
                                                  Key rangeID,
                                                  Version begin,
                                                  Version end,
                                                  KeyRange range,
                                                  int replyBufferSize,
                                                  bool canReadPopped) {
	return getChangeFeedStreamActor(
	    Reference<DatabaseContext>::addRef(this), results, rangeID, begin, end, range, replyBufferSize, canReadPopped);
}

															#line 50339 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via singleLocationOverlappingChangeFeeds()
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class SingleLocationOverlappingChangeFeedsActor>
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SingleLocationOverlappingChangeFeedsActorState {
															#line 50346 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SingleLocationOverlappingChangeFeedsActorState(Database const& cx,Reference<LocationInfo> const& location,KeyRangeRef const& range,Version const& minVersion) 
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   location(location),
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   minVersion(minVersion),
															#line 9306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   req()
															#line 50361 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this));

	}
	~SingleLocationOverlappingChangeFeedsActorState() 
	{
		fdb_probe_actor_destroy("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9307 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.range = range;
															#line 9308 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			req.minVersion = minVersion;
															#line 9310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<OverlappingChangeFeedsReply> __when_expr_0 = loadBalance(cx.getPtr(), location, &StorageServerInterface::overlappingChangeFeeds, req, TaskPriority::DefaultPromiseEndpoint, AtMostOnce::False, cx->enableLocalityLoadBalance ? &cx->queueModel : nullptr);
															#line 9310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 50382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->actor_wait_state = 1;
															#line 9310 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >*>(static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)));
															#line 50387 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SingleLocationOverlappingChangeFeedsActorState();
		static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(OverlappingChangeFeedsReply const& rep,int loopDepth) 
	{
															#line 9317 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->SAV<std::vector<OverlappingChangeFeedEntry>>::futures) { (void)(rep.rangeIds); this->~SingleLocationOverlappingChangeFeedsActorState(); static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->destroy(); return 0; }
															#line 50410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->SAV< std::vector<OverlappingChangeFeedEntry> >::value()) std::vector<OverlappingChangeFeedEntry>(rep.rangeIds);
		this->~SingleLocationOverlappingChangeFeedsActorState();
		static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(OverlappingChangeFeedsReply && rep,int loopDepth) 
	{
															#line 9317 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->SAV<std::vector<OverlappingChangeFeedEntry>>::futures) { (void)(rep.rangeIds); this->~SingleLocationOverlappingChangeFeedsActorState(); static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->destroy(); return 0; }
															#line 50422 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->SAV< std::vector<OverlappingChangeFeedEntry> >::value()) std::vector<OverlappingChangeFeedEntry>(rep.rangeIds);
		this->~SingleLocationOverlappingChangeFeedsActorState();
		static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(OverlappingChangeFeedsReply const& rep,int loopDepth) 
	{
		loopDepth = a_body1cont1(rep, loopDepth);

		return loopDepth;
	}
	int a_body1when1(OverlappingChangeFeedsReply && rep,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(rep), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->actor_wait_state > 0) static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->actor_wait_state = 0;
		static_cast<SingleLocationOverlappingChangeFeedsActor*>(this)->ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >::remove();

	}
	void a_callback_fire(ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >*,OverlappingChangeFeedsReply const& value) 
	{
		fdb_probe_actor_enter("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >*,OverlappingChangeFeedsReply && value) 
	{
		fdb_probe_actor_enter("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >*,Error err) 
	{
		fdb_probe_actor_enter("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<LocationInfo> location;
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeRef range;
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version minVersion;
															#line 9306 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	OverlappingChangeFeedsRequest req;
															#line 50503 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via singleLocationOverlappingChangeFeeds()
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class SingleLocationOverlappingChangeFeedsActor final : public Actor<std::vector<OverlappingChangeFeedEntry>>, public ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >, public FastAllocated<SingleLocationOverlappingChangeFeedsActor>, public SingleLocationOverlappingChangeFeedsActorState<SingleLocationOverlappingChangeFeedsActor> {
															#line 50508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<SingleLocationOverlappingChangeFeedsActor>::operator new;
	using FastAllocated<SingleLocationOverlappingChangeFeedsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<std::vector<OverlappingChangeFeedEntry>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >;
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	SingleLocationOverlappingChangeFeedsActor(Database const& cx,Reference<LocationInfo> const& location,KeyRangeRef const& range,Version const& minVersion) 
															#line 50519 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<std::vector<OverlappingChangeFeedEntry>>(),
		   SingleLocationOverlappingChangeFeedsActorState<SingleLocationOverlappingChangeFeedsActor>(cx, location, range, minVersion)
	{
		fdb_probe_actor_enter("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("singleLocationOverlappingChangeFeeds");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("singleLocationOverlappingChangeFeeds", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SingleLocationOverlappingChangeFeedsActor, 0, OverlappingChangeFeedsReply >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<std::vector<OverlappingChangeFeedEntry>> singleLocationOverlappingChangeFeeds( Database const& cx, Reference<LocationInfo> const& location, KeyRangeRef const& range, Version const& minVersion ) {
															#line 9301 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<std::vector<OverlappingChangeFeedEntry>>(new SingleLocationOverlappingChangeFeedsActor(cx, location, range, minVersion));
															#line 50547 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9319 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

bool compareChangeFeedResult(const OverlappingChangeFeedEntry& i, const OverlappingChangeFeedEntry& j) {
	return i.rangeId < j.rangeId;
}

															#line 50556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via getOverlappingChangeFeedsActor()
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class GetOverlappingChangeFeedsActorActor>
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetOverlappingChangeFeedsActorActorState {
															#line 50563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetOverlappingChangeFeedsActorActorState(Reference<DatabaseContext> const& db,KeyRangeRef const& range,Version const& minVersion) 
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   minVersion(minVersion),
															#line 9327 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(db),
															#line 9328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:GetOverlappingChangeFeeds"_loc)
															#line 50578 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this));

	}
	~GetOverlappingChangeFeedsActorActorState() 
	{
		fdb_probe_actor_destroy("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9330 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 50593 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetOverlappingChangeFeedsActorActorState();
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 9332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_0 = getKeyRangeLocations(cx, Optional<TenantName>(), range, CLIENT_KNOBS->CHANGE_FEED_LOCATION_LIMIT, Reverse::False, &StorageServerInterface::overlappingChangeFeeds, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 9332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 50626 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 1;
															#line 9332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >*>(static_cast<GetOverlappingChangeFeedsActorActor*>(this)));
															#line 50631 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9367 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() == error_code_wrong_shard_server || e.code() == error_code_all_alternatives_failed)
															#line 50653 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9368 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				cx->invalidateCache(Key(), range);
															#line 9369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				StrictFuture<Void> __when_expr_3 = delay(CLIENT_KNOBS->WRONG_SHARD_SERVER_DELAY);
															#line 9369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 50661 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
				static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 4;
															#line 9369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >*>(static_cast<GetOverlappingChangeFeedsActorActor*>(this)));
															#line 50666 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 9371 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 50673 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
															#line 9344 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() >= CLIENT_KNOBS->CHANGE_FEED_LOCATION_LIMIT)
															#line 50688 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9345 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			TraceEvent(SevError, "OverlappingRangeTooLarge") .detail("Range", range) .detail("Limit", CLIENT_KNOBS->CHANGE_FEED_LOCATION_LIMIT);
															#line 9348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_1 = delay(1.0);
															#line 9348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 50696 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
			static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 2;
															#line 9348 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >*>(static_cast<GetOverlappingChangeFeedsActorActor*>(this)));
															#line 50701 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 9332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 50715 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state > 0) static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
															#line 9352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		allOverlappingRequests = std::vector<Future<std::vector<OverlappingChangeFeedEntry>>>();
															#line 9353 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& it : locations ) {
															#line 9354 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			allOverlappingRequests.push_back( singleLocationOverlappingChangeFeeds(cx, it.locations, it.range & range, minVersion));
															#line 50786 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = waitForAll(allOverlappingRequests);
															#line 9357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 50792 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 3;
															#line 9357 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >*>(static_cast<GetOverlappingChangeFeedsActorActor*>(this)));
															#line 50797 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void const& _,int loopDepth) 
	{
															#line 9349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1loopBody1Catch1(all_alternatives_failed(), loopDepth);
															#line 50806 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1cont4(Void && _,int loopDepth) 
	{
															#line 9349 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		return a_body1loopBody1Catch1(all_alternatives_failed(), loopDepth);
															#line 50814 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state > 0) static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont6(Void const& _,int loopDepth) 
	{
															#line 9359 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<OverlappingChangeFeedEntry> result;
															#line 9360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& it : allOverlappingRequests ) {
															#line 9361 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			result.insert(result.end(), it.get().begin(), it.get().end());
															#line 50889 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9363 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::sort(result.begin(), result.end(), compareChangeFeedResult);
															#line 9364 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		result.resize(std::unique(result.begin(), result.end()) - result.begin());
															#line 9365 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetOverlappingChangeFeedsActorActor*>(this)->SAV<std::vector<OverlappingChangeFeedEntry>>::futures) { (void)(result); this->~GetOverlappingChangeFeedsActorActorState(); static_cast<GetOverlappingChangeFeedsActorActor*>(this)->destroy(); return 0; }
															#line 50897 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetOverlappingChangeFeedsActorActor*>(this)->SAV< std::vector<OverlappingChangeFeedEntry> >::value()) std::vector<OverlappingChangeFeedEntry>(result);
		this->~GetOverlappingChangeFeedsActorActorState();
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont6(Void && _,int loopDepth) 
	{
															#line 9359 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::vector<OverlappingChangeFeedEntry> result;
															#line 9360 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for( auto& it : allOverlappingRequests ) {
															#line 9361 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			result.insert(result.end(), it.get().begin(), it.get().end());
															#line 50913 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9363 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		std::sort(result.begin(), result.end(), compareChangeFeedResult);
															#line 9364 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		result.resize(std::unique(result.begin(), result.end()) - result.begin());
															#line 9365 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<GetOverlappingChangeFeedsActorActor*>(this)->SAV<std::vector<OverlappingChangeFeedEntry>>::futures) { (void)(result); this->~GetOverlappingChangeFeedsActorActorState(); static_cast<GetOverlappingChangeFeedsActorActor*>(this)->destroy(); return 0; }
															#line 50921 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<GetOverlappingChangeFeedsActorActor*>(this)->SAV< std::vector<OverlappingChangeFeedEntry> >::value()) std::vector<OverlappingChangeFeedEntry>(result);
		this->~GetOverlappingChangeFeedsActorActorState();
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state > 0) static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1Catch1cont1(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state > 0) static_cast<GetOverlappingChangeFeedsActorActor*>(this)->actor_wait_state = 0;
		static_cast<GetOverlappingChangeFeedsActorActor*>(this)->ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRangeRef range;
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version minVersion;
															#line 9327 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9328 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 9332 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 9352 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<Future<std::vector<OverlappingChangeFeedEntry>>> allOverlappingRequests;
															#line 51087 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via getOverlappingChangeFeedsActor()
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class GetOverlappingChangeFeedsActorActor final : public Actor<std::vector<OverlappingChangeFeedEntry>>, public ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >, public ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >, public ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >, public ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >, public FastAllocated<GetOverlappingChangeFeedsActorActor>, public GetOverlappingChangeFeedsActorActorState<GetOverlappingChangeFeedsActorActor> {
															#line 51092 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<GetOverlappingChangeFeedsActorActor>::operator new;
	using FastAllocated<GetOverlappingChangeFeedsActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<std::vector<OverlappingChangeFeedEntry>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >;
friend struct ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >;
friend struct ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >;
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	GetOverlappingChangeFeedsActorActor(Reference<DatabaseContext> const& db,KeyRangeRef const& range,Version const& minVersion) 
															#line 51106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<std::vector<OverlappingChangeFeedEntry>>(),
		   GetOverlappingChangeFeedsActorActorState<GetOverlappingChangeFeedsActorActor>(db, range, minVersion)
	{
		fdb_probe_actor_enter("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getOverlappingChangeFeedsActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getOverlappingChangeFeedsActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetOverlappingChangeFeedsActorActor, 0, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetOverlappingChangeFeedsActorActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetOverlappingChangeFeedsActorActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetOverlappingChangeFeedsActorActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<std::vector<OverlappingChangeFeedEntry>> getOverlappingChangeFeedsActor( Reference<DatabaseContext> const& db, KeyRangeRef const& range, Version const& minVersion ) {
															#line 9324 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<std::vector<OverlappingChangeFeedEntry>>(new GetOverlappingChangeFeedsActorActor(db, range, minVersion));
															#line 51137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9376 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<std::vector<OverlappingChangeFeedEntry>> DatabaseContext::getOverlappingChangeFeeds(KeyRangeRef range,
                                                                                           Version minVersion) {
	return getOverlappingChangeFeedsActor(Reference<DatabaseContext>::addRef(this), range, minVersion);
}

															#line 51147 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via popChangeFeedBackup()
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class PopChangeFeedBackupActor>
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PopChangeFeedBackupActorState {
															#line 51154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PopChangeFeedBackupActorState(Database const& cx,Key const& rangeID,Version const& version) 
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : cx(cx),
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeID(rangeID),
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 9383 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(cx)
															#line 51167 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("popChangeFeedBackup", reinterpret_cast<unsigned long>(this));

	}
	~PopChangeFeedBackupActorState() 
	{
		fdb_probe_actor_destroy("popChangeFeedBackup", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9384 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 51182 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~PopChangeFeedBackupActorState();
		static_cast<PopChangeFeedBackupActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 9386 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 9387 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			rangeIDKey = rangeID.withPrefix(changeFeedPrefix);
															#line 9388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = tr.get(rangeIDKey);
															#line 9388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 51219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state = 1;
															#line 9388 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >*>(static_cast<PopChangeFeedBackupActor*>(this)));
															#line 51224 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9403 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr.onError(e);
															#line 9403 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 51248 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state = 3;
															#line 9403 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedBackupActor, 2, Void >*>(static_cast<PopChangeFeedBackupActor*>(this)));
															#line 51253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Value> const& val,int loopDepth) 
	{
															#line 9389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (val.present())
															#line 51268 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9390 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			KeyRange range;
															#line 9391 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Version popVersion;
															#line 9392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ChangeFeedStatus status;
															#line 9393 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::tie(range, popVersion, status) = decodeChangeFeedValue(val.get());
															#line 9394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (version > popVersion)
															#line 51280 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr.set(rangeIDKey, changeFeedValue(range, version, status));
															#line 51284 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		else
		{
															#line 9398 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1Catch1(change_feed_not_registered(), loopDepth);
															#line 51291 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = tr.commit();
															#line 9400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 51297 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state = 2;
															#line 9400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedBackupActor, 1, Void >*>(static_cast<PopChangeFeedBackupActor*>(this)));
															#line 51302 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Value> && val,int loopDepth) 
	{
															#line 9389 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (val.present())
															#line 51311 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9390 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			KeyRange range;
															#line 9391 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Version popVersion;
															#line 9392 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			ChangeFeedStatus status;
															#line 9393 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::tie(range, popVersion, status) = decodeChangeFeedValue(val.get());
															#line 9394 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (version > popVersion)
															#line 51323 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9395 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				tr.set(rangeIDKey, changeFeedValue(range, version, status));
															#line 51327 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
		}
		else
		{
															#line 9398 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			return a_body1loopBody1Catch1(change_feed_not_registered(), loopDepth);
															#line 51334 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = tr.commit();
															#line 9400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 51340 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state = 2;
															#line 9400 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedBackupActor, 1, Void >*>(static_cast<PopChangeFeedBackupActor*>(this)));
															#line 51345 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> const& val,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(val, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> && val,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(val), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedBackupActor*>(this)->ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 9401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PopChangeFeedBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PopChangeFeedBackupActorState(); static_cast<PopChangeFeedBackupActor*>(this)->destroy(); return 0; }
															#line 51417 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PopChangeFeedBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~PopChangeFeedBackupActorState();
		static_cast<PopChangeFeedBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 9401 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PopChangeFeedBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PopChangeFeedBackupActorState(); static_cast<PopChangeFeedBackupActor*>(this)->destroy(); return 0; }
															#line 51429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PopChangeFeedBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~PopChangeFeedBackupActorState();
		static_cast<PopChangeFeedBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedBackupActor*>(this)->ActorCallback< PopChangeFeedBackupActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedBackupActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedBackupActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< PopChangeFeedBackupActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedBackupActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedBackupActor*>(this)->ActorCallback< PopChangeFeedBackupActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedBackupActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedBackupActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< PopChangeFeedBackupActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeID;
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 9383 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 9387 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeIDKey;
															#line 51585 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via popChangeFeedBackup()
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PopChangeFeedBackupActor final : public Actor<Void>, public ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >, public ActorCallback< PopChangeFeedBackupActor, 1, Void >, public ActorCallback< PopChangeFeedBackupActor, 2, Void >, public FastAllocated<PopChangeFeedBackupActor>, public PopChangeFeedBackupActorState<PopChangeFeedBackupActor> {
															#line 51590 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<PopChangeFeedBackupActor>::operator new;
	using FastAllocated<PopChangeFeedBackupActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >;
friend struct ActorCallback< PopChangeFeedBackupActor, 1, Void >;
friend struct ActorCallback< PopChangeFeedBackupActor, 2, Void >;
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PopChangeFeedBackupActor(Database const& cx,Key const& rangeID,Version const& version) 
															#line 51603 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   PopChangeFeedBackupActorState<PopChangeFeedBackupActor>(cx, rangeID, version)
	{
		fdb_probe_actor_enter("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("popChangeFeedBackup");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("popChangeFeedBackup", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< PopChangeFeedBackupActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< PopChangeFeedBackupActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< PopChangeFeedBackupActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] static Future<Void> popChangeFeedBackup( Database const& cx, Key const& rangeID, Version const& version ) {
															#line 9382 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new PopChangeFeedBackupActor(cx, rangeID, version));
															#line 51633 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9407 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

															#line 51638 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via popChangeFeedMutationsActor()
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class PopChangeFeedMutationsActorActor>
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PopChangeFeedMutationsActorActorState {
															#line 51645 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PopChangeFeedMutationsActorActorState(Reference<DatabaseContext> const& db,Key const& rangeID,Version const& version) 
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeID(rangeID),
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   version(version),
															#line 9409 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(db),
															#line 9410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   rangeIDKey(rangeID.withPrefix(changeFeedPrefix)),
															#line 9411 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   span("NAPI:PopChangeFeedMutations"_loc)
															#line 51662 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this));

	}
	~PopChangeFeedMutationsActorActorState() 
	{
		fdb_probe_actor_destroy("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<KeyRange> __when_expr_0 = getChangeFeedRange(db, cx, rangeID);
															#line 9413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 51679 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 1;
															#line 9413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 51684 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~PopChangeFeedMutationsActorActorState();
		static_cast<PopChangeFeedMutationsActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 9415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<std::vector<KeyRangeLocationInfo>> __when_expr_1 = getKeyRangeLocations(cx, Optional<TenantName>(), keys, 3, Reverse::False, &StorageServerInterface::changeFeedPop, span.context, Optional<UID>(), UseProvisionalProxies::False, latestVersion);
															#line 9415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 51709 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 2;
															#line 9415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 51714 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(KeyRange const& __keys,int loopDepth) 
	{
															#line 9413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		keys = __keys;
															#line 51723 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(KeyRange && __keys,int loopDepth) 
	{
		keys = std::move(__keys);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >*,KeyRange const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >*,KeyRange && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 9427 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (locations.size() > 2)
															#line 51790 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = popChangeFeedBackup(cx, rangeID, version);
															#line 9428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 51796 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 3;
															#line 9428 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 51801 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1when1(std::vector<KeyRangeLocationInfo> const& __locations,int loopDepth) 
	{
															#line 9415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		locations = __locations;
															#line 51815 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(std::vector<KeyRangeLocationInfo> && __locations,int loopDepth) 
	{
		locations = std::move(__locations);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >*,std::vector<KeyRangeLocationInfo> && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 9432 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		bool foundFailed = false;
															#line 9433 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		for(int i = 0;i < locations.size() && !foundFailed;i++) {
															#line 9434 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int j = 0;j < locations[i].locations->size() && !foundFailed;j++) {
															#line 9435 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				if (IFailureMonitor::failureMonitor() .getState(locations[i].locations->get(j, &StorageServerInterface::changeFeedPop).getEndpoint()) .isFailed())
															#line 51888 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				{
															#line 9438 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					foundFailed = true;
															#line 51892 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
		}
															#line 9443 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (foundFailed)
															#line 51898 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = popChangeFeedBackup(cx, rangeID, version);
															#line 9444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 51904 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont3when1(__when_expr_3.get(), loopDepth); };
			static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 4;
															#line 9444 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 51909 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont6(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont4(Void const& _,int loopDepth) 
	{
															#line 9429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PopChangeFeedMutationsActorActorState(); static_cast<PopChangeFeedMutationsActorActor*>(this)->destroy(); return 0; }
															#line 51923 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~PopChangeFeedMutationsActorActorState();
		static_cast<PopChangeFeedMutationsActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont4(Void && _,int loopDepth) 
	{
															#line 9429 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PopChangeFeedMutationsActorActorState(); static_cast<PopChangeFeedMutationsActorActor*>(this)->destroy(); return 0; }
															#line 51935 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~PopChangeFeedMutationsActorActorState();
		static_cast<PopChangeFeedMutationsActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont6(int loopDepth) 
	{
		try {
															#line 9450 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			std::vector<Future<Void>> popRequests;
															#line 9451 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			for(int i = 0;i < locations.size();i++) {
															#line 9452 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				for(int j = 0;j < locations[i].locations->size();j++) {
															#line 9453 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
					popRequests.push_back(locations[i].locations->getInterface(j).changeFeedPop.getReply( ChangeFeedPopRequest(rangeID, version, locations[i].range)));
															#line 52017 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
				}
			}
															#line 9458 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_4 = waitForAll(popRequests);
															#line 9457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1cont6Catch1(actor_cancelled(), loopDepth);
															#line 52024 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1cont6Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont6when1(__when_expr_4.get(), loopDepth); };
															#line 9459 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_5 = delay(CLIENT_KNOBS->CHANGE_FEED_POP_TIMEOUT);
															#line 52028 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont6Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont6when2(__when_expr_5.get(), loopDepth); };
			static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 5;
															#line 9458 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 9459 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 5, Void >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 52035 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont6Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont6Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont10(Void const& _,int loopDepth) 
	{
															#line 9445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PopChangeFeedMutationsActorActorState(); static_cast<PopChangeFeedMutationsActorActor*>(this)->destroy(); return 0; }
															#line 52050 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~PopChangeFeedMutationsActorActorState();
		static_cast<PopChangeFeedMutationsActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont10(Void && _,int loopDepth) 
	{
															#line 9445 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PopChangeFeedMutationsActorActorState(); static_cast<PopChangeFeedMutationsActorActor*>(this)->destroy(); return 0; }
															#line 52062 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~PopChangeFeedMutationsActorActorState();
		static_cast<PopChangeFeedMutationsActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont10(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont10(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont11(int loopDepth) 
	{
															#line 9473 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~PopChangeFeedMutationsActorActorState(); static_cast<PopChangeFeedMutationsActorActor*>(this)->destroy(); return 0; }
															#line 52137 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PopChangeFeedMutationsActorActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~PopChangeFeedMutationsActorActorState();
		static_cast<PopChangeFeedMutationsActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9464 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (e.code() != error_code_unknown_change_feed && e.code() != error_code_wrong_shard_server && e.code() != error_code_all_alternatives_failed && e.code() != error_code_broken_promise && e.code() != error_code_server_overloaded)
															#line 52150 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9467 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(e, loopDepth);
															#line 52154 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9469 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			db->changeFeedCache.erase(rangeID);
															#line 9470 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			cx->invalidateCache(Key(), keys);
															#line 9471 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_7 = popChangeFeedBackup(cx, rangeID, version);
															#line 9471 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 52164 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont6Catch1when1(__when_expr_7.get(), loopDepth); };
			static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 7;
															#line 9471 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 52169 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont12(int loopDepth) 
	{
		loopDepth = a_body1cont12cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont12(loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont12(loopDepth);

		return loopDepth;
	}
	int a_body1cont6when2(Void const& _,int loopDepth) 
	{
															#line 9460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_6 = popChangeFeedBackup(cx, rangeID, version);
															#line 9460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1cont6Catch1(actor_cancelled(), loopDepth);
															#line 52204 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont6Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont6when2when1(__when_expr_6.get(), loopDepth); };
		static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 6;
															#line 9460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 52209 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont6when2(Void && _,int loopDepth) 
	{
															#line 9460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_6 = popChangeFeedBackup(cx, rangeID, version);
															#line 9460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state < 0) return a_body1cont6Catch1(actor_cancelled(), loopDepth);
															#line 52220 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont6Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont6when2when1(__when_expr_6.get(), loopDepth); };
		static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 6;
															#line 9460 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >*>(static_cast<PopChangeFeedMutationsActorActor*>(this)));
															#line 52225 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >::remove();
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont6when2cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont12(loopDepth);

		return loopDepth;
	}
	int a_body1cont6when2cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont12(loopDepth);

		return loopDepth;
	}
	int a_body1cont6when2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6when2cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont6when2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6when2cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1cont6when2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1cont6when2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose6();
		try {
			a_body1cont6Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1cont6when2(value, 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1cont6when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose5();
		try {
			a_body1cont6Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont6Catch1(error, 0);
		} catch (...) {
			a_body1cont6Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont12cont1(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont11(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont6Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11(loopDepth);

		return loopDepth;
	}
	int a_body1cont6Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11(loopDepth);

		return loopDepth;
	}
	int a_body1cont6Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont6Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state > 0) static_cast<PopChangeFeedMutationsActorActor*>(this)->actor_wait_state = 0;
		static_cast<PopChangeFeedMutationsActorActor*>(this)->ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1cont6Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1cont6Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), 7);

	}
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeID;
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version version;
															#line 9409 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9410 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key rangeIDKey;
															#line 9411 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Span span;
															#line 9413 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange keys;
															#line 9415 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	std::vector<KeyRangeLocationInfo> locations;
															#line 52506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via popChangeFeedMutationsActor()
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PopChangeFeedMutationsActorActor final : public Actor<Void>, public ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >, public ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >, public ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >, public ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >, public ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >, public ActorCallback< PopChangeFeedMutationsActorActor, 5, Void >, public ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >, public ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >, public FastAllocated<PopChangeFeedMutationsActorActor>, public PopChangeFeedMutationsActorActorState<PopChangeFeedMutationsActorActor> {
															#line 52511 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<PopChangeFeedMutationsActorActor>::operator new;
	using FastAllocated<PopChangeFeedMutationsActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >;
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >;
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >;
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >;
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >;
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 5, Void >;
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >;
friend struct ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >;
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PopChangeFeedMutationsActorActor(Reference<DatabaseContext> const& db,Key const& rangeID,Version const& version) 
															#line 52529 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   PopChangeFeedMutationsActorActorState<PopChangeFeedMutationsActorActor>(db, rangeID, version)
	{
		fdb_probe_actor_enter("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("popChangeFeedMutationsActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("popChangeFeedMutationsActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< PopChangeFeedMutationsActorActor, 0, KeyRange >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< PopChangeFeedMutationsActorActor, 1, std::vector<KeyRangeLocationInfo> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< PopChangeFeedMutationsActorActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< PopChangeFeedMutationsActorActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< PopChangeFeedMutationsActorActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< PopChangeFeedMutationsActorActor, 6, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< PopChangeFeedMutationsActorActor, 7, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> popChangeFeedMutationsActor( Reference<DatabaseContext> const& db, Key const& rangeID, Version const& version ) {
															#line 9408 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new PopChangeFeedMutationsActorActor(db, rangeID, version));
															#line 52563 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9475 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> DatabaseContext::popChangeFeedMutations(Key rangeID, Version version) {
	return popChangeFeedMutationsActor(Reference<DatabaseContext>::addRef(this), rangeID, version);
}

Reference<DatabaseContext::TransactionT> DatabaseContext::createTransaction() {
	return makeReference<ReadYourWritesTransaction>(Database(Reference<DatabaseContext>::addRef(this)));
}

															#line 52576 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via purgeBlobGranulesActor()
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class PurgeBlobGranulesActorActor>
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PurgeBlobGranulesActorActorState {
															#line 52583 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PurgeBlobGranulesActorActorState(Reference<DatabaseContext> const& db,KeyRange const& range,Version const& purgeVersion,bool const& force) 
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   range(range),
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   purgeVersion(purgeVersion),
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   force(force),
															#line 9488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(db),
															#line 9489 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(cx),
															#line 9490 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   purgeKey()
															#line 52602 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this));

	}
	~PurgeBlobGranulesActorActorState() 
	{
		fdb_probe_actor_destroy("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9493 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!force)
															#line 52617 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9494 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				return a_body1Catch1(unsupported_operation(), loopDepth);
															#line 52621 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9496 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 52625 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~PurgeBlobGranulesActorActorState();
		static_cast<PurgeBlobGranulesActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 9528 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!static_cast<PurgeBlobGranulesActorActor*>(this)->SAV<Key>::futures) { (void)(purgeKey); this->~PurgeBlobGranulesActorActorState(); static_cast<PurgeBlobGranulesActorActor*>(this)->destroy(); return 0; }
															#line 52648 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		new (&static_cast<PurgeBlobGranulesActorActor*>(this)->SAV< Key >::value()) Key(std::move(purgeKey)); // state_var_RVO
		this->~PurgeBlobGranulesActorActorState();
		static_cast<PurgeBlobGranulesActorActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 9498 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 9499 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE);
															#line 9501 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			Value purgeValue = blobGranulePurgeValueFor(purgeVersion, range, force);
															#line 9502 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.atomicOp( addVersionStampAtEnd(blobGranulePurgeKeys.begin), purgeValue, MutationRef::SetVersionstampedKey);
															#line 9504 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr.set(blobGranulePurgeChangeKey, deterministicRandom()->randomUniqueID().toString());
															#line 9505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fTrVs = tr.getVersionstamp();
															#line 9506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_0 = tr.commit();
															#line 9506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 52682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state = 1;
															#line 9506 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< PurgeBlobGranulesActorActor, 0, Void >*>(static_cast<PurgeBlobGranulesActorActor*>(this)));
															#line 52687 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9518 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 52722 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9519 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("purgeBlobGranules for range [{0} - {1}) at version {2} encountered error {3}\n", range.begin.printable(), range.end.printable(), purgeVersion, e.name());
															#line 52726 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_2 = tr.onError(e);
															#line 9525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 52732 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_2.get(), loopDepth); };
			static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state = 3;
															#line 9525 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< PurgeBlobGranulesActorActor, 2, Void >*>(static_cast<PurgeBlobGranulesActorActor*>(this)));
															#line 52737 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 9507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Standalone<StringRef>> __when_expr_1 = fTrVs;
															#line 9507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 52754 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state = 2;
															#line 9507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >*>(static_cast<PurgeBlobGranulesActorActor*>(this)));
															#line 52759 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 9507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Standalone<StringRef>> __when_expr_1 = fTrVs;
															#line 9507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 52770 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state = 2;
															#line 9507 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >*>(static_cast<PurgeBlobGranulesActorActor*>(this)));
															#line 52775 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state > 0) static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state = 0;
		static_cast<PurgeBlobGranulesActorActor*>(this)->ActorCallback< PurgeBlobGranulesActorActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PurgeBlobGranulesActorActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< PurgeBlobGranulesActorActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< PurgeBlobGranulesActorActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(Standalone<StringRef> const& vs,int loopDepth) 
	{
															#line 9508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		purgeKey = blobGranulePurgeKeys.begin.withSuffix(vs);
															#line 9509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 52849 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("purgeBlobGranules for range [{0} - {1}) at version {2} registered {3}\n", range.begin.printable(), range.end.printable(), purgeVersion, purgeKey.printable());
															#line 52853 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont3(Standalone<StringRef> && vs,int loopDepth) 
	{
															#line 9508 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		purgeKey = blobGranulePurgeKeys.begin.withSuffix(vs);
															#line 9509 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 52865 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9510 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("purgeBlobGranules for range [{0} - {1}) at version {2} registered {3}\n", range.begin.printable(), range.end.printable(), purgeVersion, purgeKey.printable());
															#line 52869 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Standalone<StringRef> const& vs,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(vs, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Standalone<StringRef> && vs,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(vs), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state > 0) static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state = 0;
		static_cast<PurgeBlobGranulesActorActor*>(this)->ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >::remove();

	}
	void a_callback_fire(ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >*,Standalone<StringRef> const& value) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >*,Standalone<StringRef> && value) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >*,Error err) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state > 0) static_cast<PurgeBlobGranulesActorActor*>(this)->actor_wait_state = 0;
		static_cast<PurgeBlobGranulesActorActor*>(this)->ActorCallback< PurgeBlobGranulesActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< PurgeBlobGranulesActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< PurgeBlobGranulesActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< PurgeBlobGranulesActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	KeyRange range;
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Version purgeVersion;
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	bool force;
															#line 9488 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9489 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Transaction tr;
															#line 9490 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key purgeKey;
															#line 9505 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Standalone<StringRef>> fTrVs;
															#line 53029 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via purgeBlobGranulesActor()
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class PurgeBlobGranulesActorActor final : public Actor<Key>, public ActorCallback< PurgeBlobGranulesActorActor, 0, Void >, public ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >, public ActorCallback< PurgeBlobGranulesActorActor, 2, Void >, public FastAllocated<PurgeBlobGranulesActorActor>, public PurgeBlobGranulesActorActorState<PurgeBlobGranulesActorActor> {
															#line 53034 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<PurgeBlobGranulesActorActor>::operator new;
	using FastAllocated<PurgeBlobGranulesActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< PurgeBlobGranulesActorActor, 0, Void >;
friend struct ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >;
friend struct ActorCallback< PurgeBlobGranulesActorActor, 2, Void >;
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	PurgeBlobGranulesActorActor(Reference<DatabaseContext> const& db,KeyRange const& range,Version const& purgeVersion,bool const& force) 
															#line 53047 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Key>(),
		   PurgeBlobGranulesActorActorState<PurgeBlobGranulesActorActor>(db, range, purgeVersion, force)
	{
		fdb_probe_actor_enter("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("purgeBlobGranulesActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("purgeBlobGranulesActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< PurgeBlobGranulesActorActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< PurgeBlobGranulesActorActor, 1, Standalone<StringRef> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< PurgeBlobGranulesActorActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Key> purgeBlobGranulesActor( Reference<DatabaseContext> const& db, KeyRange const& range, Version const& purgeVersion, bool const& force ) {
															#line 9484 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Key>(new PurgeBlobGranulesActorActor(db, range, purgeVersion, force));
															#line 53077 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9530 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Key> DatabaseContext::purgeBlobGranules(KeyRange range, Version purgeVersion, bool force) {
	return purgeBlobGranulesActor(Reference<DatabaseContext>::addRef(this), range, purgeVersion, force);
}

															#line 53086 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
namespace {
// This generated class is to be used only via waitPurgeGranulesCompleteActor()
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
template <class WaitPurgeGranulesCompleteActorActor>
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitPurgeGranulesCompleteActorActorState {
															#line 53093 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitPurgeGranulesCompleteActorActorState(Reference<DatabaseContext> const& db,Key const& purgeKey) 
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		 : db(db),
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   purgeKey(purgeKey),
															#line 9536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   cx(db),
															#line 9537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		   tr(makeReference<ReadYourWritesTransaction>(cx))
															#line 53106 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
	{
		fdb_probe_actor_create("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this));

	}
	~WaitPurgeGranulesCompleteActorActorState() 
	{
		fdb_probe_actor_destroy("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 9538 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			;
															#line 53121 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitPurgeGranulesCompleteActorActorState();
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 9540 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 9541 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			tr->setOption(FDBTransactionOptions::PRIORITY_SYSTEM_IMMEDIATE);
															#line 9543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = tr->get(purgeKey);
															#line 9543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 53158 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 1;
															#line 9543 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >*>(static_cast<WaitPurgeGranulesCompleteActorActor*>(this)));
															#line 53163 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 9558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr->onError(e);
															#line 9558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 53187 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 4;
															#line 9558 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >*>(static_cast<WaitPurgeGranulesCompleteActorActor*>(this)));
															#line 53192 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Value> const& purgeVal,int loopDepth) 
	{
															#line 9544 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!purgeVal.present())
															#line 53207 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9545 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 53211 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("purgeBlobGranules for {0} succeeded\n", purgeKey.printable());
															#line 53215 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9548 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WaitPurgeGranulesCompleteActorActorState(); static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->destroy(); return 0; }
															#line 53219 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~WaitPurgeGranulesCompleteActorActorState();
			static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 9550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 53227 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("purgeBlobGranules for {0} watching\n", purgeKey.printable());
															#line 53231 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		watchFuture = tr->watch(purgeKey);
															#line 9554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = tr->commit();
															#line 9554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 53239 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 2;
															#line 9554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >*>(static_cast<WaitPurgeGranulesCompleteActorActor*>(this)));
															#line 53244 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Value> && purgeVal,int loopDepth) 
	{
															#line 9544 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (!purgeVal.present())
															#line 53253 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9545 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (BG_REQUEST_DEBUG)
															#line 53257 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			{
															#line 9546 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
				fmt::print("purgeBlobGranules for {0} succeeded\n", purgeKey.printable());
															#line 53261 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			}
															#line 9548 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			if (!static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WaitPurgeGranulesCompleteActorActorState(); static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->destroy(); return 0; }
															#line 53265 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
			new (&static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~WaitPurgeGranulesCompleteActorActorState();
			static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 9550 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (BG_REQUEST_DEBUG)
															#line 53273 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		{
															#line 9551 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
			fmt::print("purgeBlobGranules for {0} watching\n", purgeKey.printable());
															#line 53277 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		}
															#line 9553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		watchFuture = tr->watch(purgeKey);
															#line 9554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_1 = tr->commit();
															#line 9554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 53285 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 2;
															#line 9554 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >*>(static_cast<WaitPurgeGranulesCompleteActorActor*>(this)));
															#line 53290 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> const& purgeVal,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(purgeVal, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Value> && purgeVal,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(purgeVal), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state > 0) static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 0;
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 9555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = watchFuture;
															#line 9555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 53364 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 3;
															#line 9555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >*>(static_cast<WaitPurgeGranulesCompleteActorActor*>(this)));
															#line 53369 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 9555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		StrictFuture<Void> __when_expr_2 = watchFuture;
															#line 9555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 53380 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 3;
															#line 9555 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >*>(static_cast<WaitPurgeGranulesCompleteActorActor*>(this)));
															#line 53385 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state > 0) static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 0;
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont7(Void const& _,int loopDepth) 
	{
															#line 9556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr->reset();
															#line 53457 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont7(Void && _,int loopDepth) 
	{
															#line 9556 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
		tr->reset();
															#line 53466 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state > 0) static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 0;
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont9(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state > 0) static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->actor_wait_state = 0;
		static_cast<WaitPurgeGranulesCompleteActorActor*>(this)->ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<DatabaseContext> db;
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Key purgeKey;
															#line 9536 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Database cx;
															#line 9537 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 9553 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	Future<Void> watchFuture;
															#line 53632 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
};
// This generated class is to be used only via waitPurgeGranulesCompleteActor()
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
class WaitPurgeGranulesCompleteActorActor final : public Actor<Void>, public ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >, public ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >, public ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >, public ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >, public FastAllocated<WaitPurgeGranulesCompleteActorActor>, public WaitPurgeGranulesCompleteActorActorState<WaitPurgeGranulesCompleteActorActor> {
															#line 53637 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
public:
	using FastAllocated<WaitPurgeGranulesCompleteActorActor>::operator new;
	using FastAllocated<WaitPurgeGranulesCompleteActorActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >;
friend struct ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >;
friend struct ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >;
friend struct ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >;
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	WaitPurgeGranulesCompleteActorActor(Reference<DatabaseContext> const& db,Key const& purgeKey) 
															#line 53651 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
		 : Actor<Void>(),
		   WaitPurgeGranulesCompleteActorActorState<WaitPurgeGranulesCompleteActorActor>(db, purgeKey)
	{
		fdb_probe_actor_enter("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitPurgeGranulesCompleteActor");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitPurgeGranulesCompleteActor", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitPurgeGranulesCompleteActorActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WaitPurgeGranulesCompleteActorActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WaitPurgeGranulesCompleteActorActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< WaitPurgeGranulesCompleteActorActor, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
}
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
[[nodiscard]] Future<Void> waitPurgeGranulesCompleteActor( Reference<DatabaseContext> const& db, Key const& purgeKey ) {
															#line 9535 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"
	return Future<Void>(new WaitPurgeGranulesCompleteActorActor(db, purgeKey));
															#line 53682 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.g.cpp"
}

#line 9562 "/usr/src/libfdb_c/fdbclient/NativeAPI.actor.cpp"

Future<Void> DatabaseContext::waitPurgeGranulesComplete(Key purgeKey) {
	return waitPurgeGranulesCompleteActor(Reference<DatabaseContext>::addRef(this), purgeKey);
}

int64_t getMaxKeySize(KeyRef const& key) {
	return getMaxWriteKeySize(key, true);
}

int64_t getMaxReadKeySize(KeyRef const& key) {
	return getMaxKeySize(key);
}

int64_t getMaxWriteKeySize(KeyRef const& key, bool hasRawAccess) {
	int64_t tenantSize = hasRawAccess ? CLIENT_KNOBS->TENANT_PREFIX_SIZE_LIMIT : 0;
	return key.startsWith(systemKeys.begin) ? CLIENT_KNOBS->SYSTEM_KEY_SIZE_LIMIT
	                                        : CLIENT_KNOBS->KEY_SIZE_LIMIT + tenantSize;
}

int64_t getMaxClearKeySize(KeyRef const& key) {
	return getMaxKeySize(key);
}
