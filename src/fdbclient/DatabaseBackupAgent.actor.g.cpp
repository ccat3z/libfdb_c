#define POST_ACTOR_COMPILER 1
#line 1 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
/*
 * DatabaseBackupAgent.actor.cpp
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2013-2022 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <iterator>
#include "fdbclient/BackupAgent.actor.h"
#include "fdbclient/Status.h"
#include "fdbclient/StatusClient.h"
#include "fdbclient/DatabaseContext.h"
#include "fdbclient/NativeAPI.actor.h"
#include <ctime>
#include <climits>
#include "fdbrpc/IAsyncFile.h"
#include "flow/genericactors.actor.h"
#include "flow/Hash3.h"
#include <numeric>
#include "fdbclient/ManagementAPI.actor.h"
#include "fdbclient/KeyBackedTypes.h"
#include <inttypes.h>
#include <map>

#include "flow/actorcompiler.h" // has to be last include

const Key DatabaseBackupAgent::keyAddPrefix = LiteralStringRef("add_prefix");
const Key DatabaseBackupAgent::keyRemovePrefix = LiteralStringRef("remove_prefix");
const Key DatabaseBackupAgent::keyRangeVersions = LiteralStringRef("range_versions");
const Key DatabaseBackupAgent::keyCopyStop = LiteralStringRef("copy_stop");
const Key DatabaseBackupAgent::keyDatabasesInSync = LiteralStringRef("databases_in_sync");
const int DatabaseBackupAgent::LATEST_DR_VERSION = 1;

DatabaseBackupAgent::DatabaseBackupAgent()
  : subspace(Subspace(databaseBackupPrefixRange.begin)), states(subspace.get(BackupAgentBase::keyStates)),
    config(subspace.get(BackupAgentBase::keyConfig)), errors(subspace.get(BackupAgentBase::keyErrors)),
    ranges(subspace.get(BackupAgentBase::keyRanges)), tagNames(subspace.get(BackupAgentBase::keyTagName)),
    sourceStates(subspace.get(BackupAgentBase::keySourceStates)),
    sourceTagNames(subspace.get(BackupAgentBase::keyTagName)),
    taskBucket(new TaskBucket(subspace.get(BackupAgentBase::keyTasks),
                              AccessSystemKeys::True,
                              PriorityBatch::False,
                              LockAware::True)),
    futureBucket(new FutureBucket(subspace.get(BackupAgentBase::keyFutures), AccessSystemKeys::True, LockAware::True)) {
}

DatabaseBackupAgent::DatabaseBackupAgent(Database src)
  : subspace(Subspace(databaseBackupPrefixRange.begin)), states(subspace.get(BackupAgentBase::keyStates)),
    config(subspace.get(BackupAgentBase::keyConfig)), errors(subspace.get(BackupAgentBase::keyErrors)),
    ranges(subspace.get(BackupAgentBase::keyRanges)), tagNames(subspace.get(BackupAgentBase::keyTagName)),
    sourceStates(subspace.get(BackupAgentBase::keySourceStates)),
    sourceTagNames(subspace.get(BackupAgentBase::keyTagName)),
    taskBucket(new TaskBucket(subspace.get(BackupAgentBase::keyTasks),
                              AccessSystemKeys::True,
                              PriorityBatch::False,
                              LockAware::True)),
    futureBucket(new FutureBucket(subspace.get(BackupAgentBase::keyFutures), AccessSystemKeys::True, LockAware::True)) {
	taskBucket->src = src;
}

// Any new per-DR properties should go here.
class DRConfig {
public:
	DRConfig(UID uid = UID())
	  : uid(uid),
	    configSpace(uidPrefixKey(LiteralStringRef("uid->config/").withPrefix(databaseBackupPrefixRange.begin), uid)) {}
	DRConfig(Reference<Task> task)
	  : DRConfig(BinaryReader::fromStringRef<UID>(task->params[BackupAgentBase::keyConfigLogUid], Unversioned())) {}

	KeyBackedBinaryValue<int64_t> rangeBytesWritten() { return configSpace.pack(LiteralStringRef(__FUNCTION__)); }

	KeyBackedBinaryValue<int64_t> logBytesWritten() { return configSpace.pack(LiteralStringRef(__FUNCTION__)); }

	void clear(Reference<ReadYourWritesTransaction> tr) { tr->clear(configSpace.range()); }

	UID getUid() { return uid; }

private:
	UID uid;
	Subspace configSpace;
};

namespace dbBackup {

bool copyDefaultParameters(Reference<Task> source, Reference<Task> dest) {
	if (source) {
		copyParameter(source, dest, BackupAgentBase::keyFolderId);
		copyParameter(source, dest, BackupAgentBase::keyConfigLogUid);
		copyParameter(source, dest, BackupAgentBase::destUid);

		copyParameter(source, dest, DatabaseBackupAgent::keyAddPrefix);
		copyParameter(source, dest, DatabaseBackupAgent::keyRemovePrefix);
		return true;
	}

	return false;
}

															#line 114 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via checkTaskVersion()
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class Tr, class CheckTaskVersionActor>
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class CheckTaskVersionActorState {
															#line 120 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	CheckTaskVersionActorState(Tr const& tr,Reference<Task> const& task,StringRef const& name,uint32_t const& version) 
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   name(name),
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   version(version)
															#line 133 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("checkTaskVersion", reinterpret_cast<unsigned long>(this));

	}
	~CheckTaskVersionActorState() 
	{
		fdb_probe_actor_destroy("checkTaskVersion", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 114 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			uint32_t taskVersion = task->getVersion();
															#line 115 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (taskVersion > version)
															#line 150 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 116 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				TraceEvent(SevError, "BA_BackupRangeTaskFuncExecute") .detail("TaskVersion", taskVersion) .detail("Name", name) .detail("Version", version);
															#line 120 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_0 = logError(tr, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyErrors) .pack(task->params[BackupAgentBase::keyConfigLogUid]), format("ERROR: %s task version `%lu' is greater than supported version `%lu'", task->params[Task::reservedTaskParamKeyType].toString().c_str(), (unsigned long)taskVersion, (unsigned long)version));
															#line 120 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<CheckTaskVersionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 158 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<CheckTaskVersionActor*>(this)->actor_wait_state = 1;
															#line 120 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< CheckTaskVersionActor, 0, Void >*>(static_cast<CheckTaskVersionActor*>(this)));
															#line 163 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont1(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~CheckTaskVersionActorState();
		static_cast<CheckTaskVersionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 132 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<CheckTaskVersionActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~CheckTaskVersionActorState(); static_cast<CheckTaskVersionActor*>(this)->destroy(); return 0; }
															#line 191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<CheckTaskVersionActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~CheckTaskVersionActorState();
		static_cast<CheckTaskVersionActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(task_invalid_version(), loopDepth);
															#line 203 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(task_invalid_version(), loopDepth);
															#line 211 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<CheckTaskVersionActor*>(this)->actor_wait_state > 0) static_cast<CheckTaskVersionActor*>(this)->actor_wait_state = 0;
		static_cast<CheckTaskVersionActor*>(this)->ActorCallback< CheckTaskVersionActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< CheckTaskVersionActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("checkTaskVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkTaskVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< CheckTaskVersionActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("checkTaskVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkTaskVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< CheckTaskVersionActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("checkTaskVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("checkTaskVersion", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Tr tr;
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	StringRef name;
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	uint32_t version;
															#line 286 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via checkTaskVersion()
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class Tr>
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class CheckTaskVersionActor final : public Actor<Void>, public ActorCallback< CheckTaskVersionActor<Tr>, 0, Void >, public FastAllocated<CheckTaskVersionActor<Tr>>, public CheckTaskVersionActorState<Tr, CheckTaskVersionActor<Tr>> {
															#line 293 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<CheckTaskVersionActor<Tr>>::operator new;
	using FastAllocated<CheckTaskVersionActor<Tr>>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< CheckTaskVersionActor<Tr>, 0, Void >;
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	CheckTaskVersionActor(Tr const& tr,Reference<Task> const& task,StringRef const& name,uint32_t const& version) 
															#line 304 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   CheckTaskVersionActorState<Tr, CheckTaskVersionActor<Tr>>(tr, task, name, version)
	{
		fdb_probe_actor_enter("checkTaskVersion", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("checkTaskVersion");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("checkTaskVersion", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< CheckTaskVersionActor<Tr>, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class Tr>
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] Future<Void> checkTaskVersion( Tr const& tr, Reference<Task> const& task, StringRef const& name, uint32_t const& version ) {
															#line 112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new CheckTaskVersionActor<Tr>(tr, task, name, version));
															#line 333 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

struct BackupRangeTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

	static struct {
		static TaskParam<int64_t> bytesWritten() { return LiteralStringRef(__FUNCTION__); }
	} Params;

	static const Key keyAddBackupRangeTasks;
	static const Key keyBackupRangeBeginKey;

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};

																#line 364 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via getBlockOfShards()
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class GetBlockOfShardsActor>
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetBlockOfShardsActorState {
															#line 370 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetBlockOfShardsActorState(Reference<ReadYourWritesTransaction> const& tr,Key const& beginKey,Key const& endKey,int const& limit) 
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   beginKey(beginKey),
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endKey(endKey),
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   limit(limit)
															#line 383 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("getBlockOfShards", reinterpret_cast<unsigned long>(this));

	}
	~GetBlockOfShardsActorState() 
	{
		fdb_probe_actor_destroy("getBlockOfShards", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 165 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 166 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 167 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			results = Standalone<VectorRef<KeyRef>>();
															#line 168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<RangeResult> __when_expr_0 = tr->getRange( KeyRangeRef(keyAfter(beginKey.withPrefix(keyServersPrefix)), endKey.withPrefix(keyServersPrefix)), limit);
															#line 168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetBlockOfShardsActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 406 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetBlockOfShardsActor*>(this)->actor_wait_state = 1;
															#line 168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetBlockOfShardsActor, 0, RangeResult >*>(static_cast<GetBlockOfShardsActor*>(this)));
															#line 411 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetBlockOfShardsActorState();
		static_cast<GetBlockOfShardsActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(RangeResult const& values,int loopDepth) 
	{
															#line 171 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto& s : values ) {
															#line 172 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			KeyRef k = s.key.removePrefix(keyServersPrefix);
															#line 173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			results.push_back_deep(results.arena(), k);
															#line 438 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 176 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetBlockOfShardsActor*>(this)->SAV<Standalone<VectorRef<KeyRef>>>::futures) { (void)(results); this->~GetBlockOfShardsActorState(); static_cast<GetBlockOfShardsActor*>(this)->destroy(); return 0; }
															#line 442 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetBlockOfShardsActor*>(this)->SAV< Standalone<VectorRef<KeyRef>> >::value()) Standalone<VectorRef<KeyRef>>(std::move(results)); // state_var_RVO
		this->~GetBlockOfShardsActorState();
		static_cast<GetBlockOfShardsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(RangeResult && values,int loopDepth) 
	{
															#line 171 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto& s : values ) {
															#line 172 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			KeyRef k = s.key.removePrefix(keyServersPrefix);
															#line 173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			results.push_back_deep(results.arena(), k);
															#line 458 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 176 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetBlockOfShardsActor*>(this)->SAV<Standalone<VectorRef<KeyRef>>>::futures) { (void)(results); this->~GetBlockOfShardsActorState(); static_cast<GetBlockOfShardsActor*>(this)->destroy(); return 0; }
															#line 462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetBlockOfShardsActor*>(this)->SAV< Standalone<VectorRef<KeyRef>> >::value()) Standalone<VectorRef<KeyRef>>(std::move(results)); // state_var_RVO
		this->~GetBlockOfShardsActorState();
		static_cast<GetBlockOfShardsActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(RangeResult const& values,int loopDepth) 
	{
		loopDepth = a_body1cont1(values, loopDepth);

		return loopDepth;
	}
	int a_body1when1(RangeResult && values,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(values), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetBlockOfShardsActor*>(this)->actor_wait_state > 0) static_cast<GetBlockOfShardsActor*>(this)->actor_wait_state = 0;
		static_cast<GetBlockOfShardsActor*>(this)->ActorCallback< GetBlockOfShardsActor, 0, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< GetBlockOfShardsActor, 0, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("getBlockOfShards", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getBlockOfShards", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetBlockOfShardsActor, 0, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("getBlockOfShards", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getBlockOfShards", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetBlockOfShardsActor, 0, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("getBlockOfShards", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getBlockOfShards", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key beginKey;
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key endKey;
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int limit;
															#line 167 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRef>> results;
															#line 543 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via getBlockOfShards()
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetBlockOfShardsActor final : public Actor<Standalone<VectorRef<KeyRef>>>, public ActorCallback< GetBlockOfShardsActor, 0, RangeResult >, public FastAllocated<GetBlockOfShardsActor>, public GetBlockOfShardsActorState<GetBlockOfShardsActor> {
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<GetBlockOfShardsActor>::operator new;
	using FastAllocated<GetBlockOfShardsActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Standalone<VectorRef<KeyRef>>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetBlockOfShardsActor, 0, RangeResult >;
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetBlockOfShardsActor(Reference<ReadYourWritesTransaction> const& tr,Key const& beginKey,Key const& endKey,int const& limit) 
															#line 559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Standalone<VectorRef<KeyRef>>>(),
		   GetBlockOfShardsActorState<GetBlockOfShardsActor>(tr, beginKey, endKey, limit)
	{
		fdb_probe_actor_enter("getBlockOfShards", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getBlockOfShards");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getBlockOfShards", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetBlockOfShardsActor, 0, RangeResult >*)0, actor_cancelled()); break;
		}

	}
};
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Standalone<VectorRef<KeyRef>>> getBlockOfShards( Reference<ReadYourWritesTransaction> const& tr, Key const& beginKey, Key const& endKey, int const& limit ) {
															#line 161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Standalone<VectorRef<KeyRef>>>(new GetBlockOfShardsActor(tr, beginKey, endKey, limit));
															#line 586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 178 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 591 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor>
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActorState {
															#line 597 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActorState(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Key const& begin,Key const& end,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   begin(begin),
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   end(end),
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 616 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActorState() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 186 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 186 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 633 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor*>(this)->actor_wait_state = 1;
															#line 186 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor, 0, Key >*>(static_cast<AddTaskActor*>(this)));
															#line 638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActorState();
		static_cast<AddTaskActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(BackupRangeTaskFunc::name, BackupRangeTaskFunc::version, doneKey);
															#line 189 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyBeginKey] = begin;
															#line 192 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyEndKey] = end;
															#line 194 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 669 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 195 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActorState(); static_cast<AddTaskActor*>(this)->destroy(); return 0; }
															#line 673 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActorState();
			static_cast<AddTaskActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 683 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor*>(this)->actor_wait_state = 2;
															#line 201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor, 1, Void >*>(static_cast<AddTaskActor*>(this)));
															#line 688 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(BackupRangeTaskFunc::name, BackupRangeTaskFunc::version, doneKey);
															#line 189 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyBeginKey] = begin;
															#line 192 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyEndKey] = end;
															#line 194 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 195 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActorState(); static_cast<AddTaskActor*>(this)->destroy(); return 0; }
															#line 709 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActorState();
			static_cast<AddTaskActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor*>(this)->actor_wait_state = 2;
															#line 201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor, 1, Void >*>(static_cast<AddTaskActor*>(this)));
															#line 724 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor*>(this)->actor_wait_state > 0) static_cast<AddTaskActor*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor*>(this)->ActorCallback< AddTaskActor, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActorState(); static_cast<AddTaskActor*>(this)->destroy(); return 0; }
															#line 796 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActorState();
		static_cast<AddTaskActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActorState(); static_cast<AddTaskActor*>(this)->destroy(); return 0; }
															#line 808 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActorState();
		static_cast<AddTaskActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor*>(this)->actor_wait_state > 0) static_cast<AddTaskActor*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor*>(this)->ActorCallback< AddTaskActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key begin;
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key end;
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 893 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor final : public Actor<Key>, public ActorCallback< AddTaskActor, 0, Key >, public ActorCallback< AddTaskActor, 1, Void >, public FastAllocated<AddTaskActor>, public AddTaskActorState<AddTaskActor> {
															#line 898 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor>::operator new;
	using FastAllocated<AddTaskActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor, 0, Key >;
friend struct ActorCallback< AddTaskActor, 1, Void >;
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Key const& begin,Key const& end,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 910 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActorState<AddTaskActor>(tr, taskBucket, parentTask, begin, end, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, Key const& begin, Key const& end, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor(tr, taskBucket, parentTask, begin, end, completionKey, waitFor));
															#line 938 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 943 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor>
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActorState {
															#line 949 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActorState(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 213 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lock(new FlowLock(CLIENT_KNOBS->BACKUP_LOCK_BYTES)),
															#line 214 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   conf(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 966 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActorState() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 218 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, BackupRangeTaskFunc::name, BackupRangeTaskFunc::version);
															#line 218 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 983 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor*>(this)->actor_wait_state = 1;
															#line 218 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 0, Void >*>(static_cast<_executeActor*>(this)));
															#line 988 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActorState();
		static_cast<_executeActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 220 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Standalone<VectorRef<KeyRef>>> __when_expr_1 = runRYWTransaction(taskBucket->src, [=](Reference<ReadYourWritesTransaction> tr) { return getBlockOfShards(tr, task->params[DatabaseBackupAgent::keyBeginKey], task->params[DatabaseBackupAgent::keyEndKey], CLIENT_KNOBS->BACKUP_SHARD_TASK_LIMIT); });
															#line 220 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 1013 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_executeActor*>(this)->actor_wait_state = 2;
															#line 220 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >*>(static_cast<_executeActor*>(this)));
															#line 1018 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 220 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Standalone<VectorRef<KeyRef>>> __when_expr_1 = runRYWTransaction(taskBucket->src, [=](Reference<ReadYourWritesTransaction> tr) { return getBlockOfShards(tr, task->params[DatabaseBackupAgent::keyBeginKey], task->params[DatabaseBackupAgent::keyEndKey], CLIENT_KNOBS->BACKUP_SHARD_TASK_LIMIT); });
															#line 220 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 1029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_executeActor*>(this)->actor_wait_state = 2;
															#line 220 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >*>(static_cast<_executeActor*>(this)));
															#line 1034 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Standalone<VectorRef<KeyRef>> const& keys,int loopDepth) 
	{
															#line 227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (keys.size() > 0)
															#line 1106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 228 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			task->params[BackupRangeTaskFunc::keyAddBackupRangeTasks] = BinaryWriter::toValue(keys, IncludeVersion());
															#line 229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 1112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActorState();
			static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		timeout = now() + CLIENT_KNOBS->BACKUP_RANGE_TIMEOUT;
															#line 236 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		addPrefix = task->params[DatabaseBackupAgent::keyAddPrefix];
															#line 237 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		removePrefix = task->params[DatabaseBackupAgent::keyRemovePrefix];
															#line 239 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		range = KeyRange(KeyRangeRef(task->params[BackupAgentBase::keyBeginKey], task->params[BackupAgentBase::keyEndKey]));
															#line 243 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		results = PromiseStream<RangeResultWithVersion>();
															#line 245 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rc = readCommitted( taskBucket->src, results, lock, range, Terminator::True, AccessSystemKeys::True, LockAware::True);
															#line 247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeBegin = range.begin;
															#line 248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeEnd = Key();
															#line 249 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endOfStream = false;
															#line 250 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValues = RangeResultWithVersion();
															#line 251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValuesSize = 0;
															#line 252 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValues.second = invalidVersion;
															#line 253 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 1144 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Standalone<VectorRef<KeyRef>> && keys,int loopDepth) 
	{
															#line 227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (keys.size() > 0)
															#line 1153 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 228 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			task->params[BackupRangeTaskFunc::keyAddBackupRangeTasks] = BinaryWriter::toValue(keys, IncludeVersion());
															#line 229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 1159 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActorState();
			static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		timeout = now() + CLIENT_KNOBS->BACKUP_RANGE_TIMEOUT;
															#line 236 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		addPrefix = task->params[DatabaseBackupAgent::keyAddPrefix];
															#line 237 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		removePrefix = task->params[DatabaseBackupAgent::keyRemovePrefix];
															#line 239 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		range = KeyRange(KeyRangeRef(task->params[BackupAgentBase::keyBeginKey], task->params[BackupAgentBase::keyEndKey]));
															#line 243 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		results = PromiseStream<RangeResultWithVersion>();
															#line 245 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rc = readCommitted( taskBucket->src, results, lock, range, Terminator::True, AccessSystemKeys::True, LockAware::True);
															#line 247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeBegin = range.begin;
															#line 248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeEnd = Key();
															#line 249 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endOfStream = false;
															#line 250 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValues = RangeResultWithVersion();
															#line 251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValuesSize = 0;
															#line 252 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValues.second = invalidVersion;
															#line 253 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 1191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Standalone<VectorRef<KeyRef>> const& keys,int loopDepth) 
	{
		loopDepth = a_body1cont2(keys, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Standalone<VectorRef<KeyRef>> && keys,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(keys), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >*,Standalone<VectorRef<KeyRef>> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >*,Standalone<VectorRef<KeyRef>> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1(int loopDepth) 
	{
															#line 254 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (endOfStream && nextValues.second == invalidVersion)
															#line 1270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 1274 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActorState();
			static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 257 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		values = std::move(nextValues);
															#line 258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		valuesSize = nextValuesSize;
															#line 259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValues = RangeResultWithVersion();
															#line 260 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValues.second = invalidVersion;
															#line 261 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextValuesSize = 0;
															#line 263 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!endOfStream)
															#line 1292 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 264 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			;
															#line 1296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1cont2loopBody1loopHead1(loopDepth);
		}
		else
		{
			loopDepth = a_body1cont2loopBody1cont1(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1(int loopDepth) 
	{
															#line 307 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (now() >= timeout)
															#line 1310 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 308 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			task->params[BackupRangeTaskFunc::keyBackupRangeBeginKey] = rangeBegin;
															#line 309 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 1316 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActorState();
			static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 312 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeEnd = values.first.more ? keyAfter(values.first.end()[-1].key) : range.end;
															#line 314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		valueLoc = 0;
															#line 315 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		committedValueLoc = 0;
															#line 316 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = makeReference<ReadYourWritesTransaction>(cx);
															#line 317 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 1332 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1(int loopDepth) 
	{
		try {
															#line 266 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			FutureStream<RangeResultWithVersion> __when_expr_2 = results.getFuture();
															#line 266 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1357 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont2loopBody1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2loopBody1loopBody1when1(__when_expr_2.pop(), loopDepth); };
			static_cast<_executeActor*>(this)->actor_wait_state = 3;
															#line 266 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >*>(static_cast<_executeActor*>(this)));
															#line 1362 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont2loopBody1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont2loopBody1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1break1(int loopDepth) 
	{
		try {
			return a_body1cont2loopBody1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont2loopBody1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 285 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			err = e;
															#line 286 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (err.code() == error_code_actor_cancelled)
															#line 1399 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 287 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1Catch1(err, std::max(0, loopDepth - 2));
															#line 1403 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 289 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (err.code() == error_code_end_of_stream)
															#line 1407 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 290 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				endOfStream = true;
															#line 291 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (values.second != invalidVersion)
															#line 1413 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
					return a_body1cont2loopBody1break1(loopDepth==0?0:loopDepth-1); // break
				}
															#line 293 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 1419 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
				this->~_executeActorState();
				static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = logError(cx, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyErrors) .pack(task->params[BackupAgentBase::keyConfigLogUid]), format("ERROR: %s", err.what()));
															#line 296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 1429 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 2)); else return a_body1cont2loopBody1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<_executeActor*>(this)->actor_wait_state = 4;
															#line 296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 3, Void >*>(static_cast<_executeActor*>(this)));
															#line 1434 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1cont2(RangeResultWithVersion const& v,int loopDepth) 
	{
															#line 267 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int64_t resultSize = v.first.expectedSize();
															#line 268 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		lock->release(resultSize);
															#line 270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (values.second == invalidVersion)
															#line 1453 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 271 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			values = v;
															#line 1457 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
															#line 272 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if ((values.second != v.second) || (valuesSize > 0 && resultSize > 0 && valuesSize + resultSize > CLIENT_KNOBS->BACKUP_LOG_WRITE_BATCH_MAX_SIZE))
															#line 1463 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 275 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				nextValues = v;
															#line 276 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				nextValuesSize = resultSize;
															#line 1469 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				return a_body1cont2loopBody1break1(loopDepth==0?0:loopDepth-1); // break
			}
			else
			{
															#line 279 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				values.first.append_deep(values.first.arena(), v.first.begin(), v.first.size());
															#line 280 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				values.first.more = v.first.more;
															#line 1478 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 283 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		valuesSize += resultSize;
															#line 1483 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1loopBody1cont8(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1cont2(RangeResultWithVersion && v,int loopDepth) 
	{
															#line 267 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int64_t resultSize = v.first.expectedSize();
															#line 268 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		lock->release(resultSize);
															#line 270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (values.second == invalidVersion)
															#line 1496 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 271 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			values = v;
															#line 1500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
															#line 272 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if ((values.second != v.second) || (valuesSize > 0 && resultSize > 0 && valuesSize + resultSize > CLIENT_KNOBS->BACKUP_LOG_WRITE_BATCH_MAX_SIZE))
															#line 1506 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 275 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				nextValues = v;
															#line 276 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				nextValuesSize = resultSize;
															#line 1512 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				return a_body1cont2loopBody1break1(loopDepth==0?0:loopDepth-1); // break
			}
			else
			{
															#line 279 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				values.first.append_deep(values.first.arena(), v.first.begin(), v.first.size());
															#line 280 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				values.first.more = v.first.more;
															#line 1521 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 283 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		valuesSize += resultSize;
															#line 1526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1loopBody1cont8(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1when1(RangeResultWithVersion const& v,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1loopBody1cont2(v, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1when1(RangeResultWithVersion && v,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1loopBody1cont2(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >::remove();

	}
	void a_callback_fire(ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >*,RangeResultWithVersion const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2loopBody1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >*,RangeResultWithVersion && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2loopBody1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2loopBody1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont2loopBody1loopBody1cont8(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont2loopBody1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
															#line 302 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 2));
															#line 1611 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
															#line 302 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 2));
															#line 1619 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont2loopBody1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _executeActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont2loopBody1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _executeActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont2loopBody1cont4(int loopDepth) 
	{
															#line 462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeBegin = rangeEnd;
															#line 1690 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1(int loopDepth) 
	{
		try {
															#line 319 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->reset();
															#line 320 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 321 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			prefix = task->params[BackupAgentBase::keyConfigLogUid].withPrefix( applyMutationsKeyVersionMapRange.begin);
															#line 324 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rangeCountKey = task->params[BackupAgentBase::keyConfigLogUid].withPrefix( applyMutationsKeyVersionCountRange.begin);
															#line 326 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			backupVersions = krmGetRanges(tr, prefix, KeyRangeRef(rangeBegin, rangeEnd), BUGGIFY ? 2 : 2000, 1e5);
															#line 328 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			logVersionValue = tr->get(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsEndRange.begin), Snapshot::True);
															#line 331 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rangeCountValue = tr->get(rangeCountKey, Snapshot::True);
															#line 332 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			prevRange = tr->getRange(firstGreaterOrEqual(prefix), lastLessOrEqual(rangeBegin.withPrefix(prefix)), 1, Snapshot::True, Reverse::True);
															#line 337 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextRange = tr->getRange(firstGreaterOrEqual(rangeEnd.withPrefix(prefix)), firstGreaterOrEqual(strinc(prefix)), 1, Snapshot::True, Reverse::False);
															#line 342 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			verified = taskBucket->keepRunning(tr, task);
															#line 344 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = checkDatabaseLock(tr, BinaryReader::fromStringRef<UID>( task->params[BackupAgentBase::keyConfigLogUid], Unversioned()));
															#line 344 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1731 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1when1(__when_expr_4.get(), loopDepth); };
			static_cast<_executeActor*>(this)->actor_wait_state = 5;
															#line 344 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 4, Void >*>(static_cast<_executeActor*>(this)));
															#line 1736 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont2loopBody1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2loopBody1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont2loopBody1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 457 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_9 = tr->onError(e);
															#line 457 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 1773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1Catch1(__when_expr_9.getError(), std::max(0, loopDepth - 2)); else return a_body1cont2loopBody1cont1loopBody1Catch1when1(__when_expr_9.get(), loopDepth); };
			static_cast<_executeActor*>(this)->actor_wait_state = 10;
															#line 457 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 9, Void >*>(static_cast<_executeActor*>(this)));
															#line 1778 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_5 = success(backupVersions) && success(logVersionValue) && success(rangeCountValue) && success(prevRange) && success(nextRange) && success(verified);
															#line 347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1795 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1cont2when1(__when_expr_5.get(), loopDepth); };
		static_cast<_executeActor*>(this)->actor_wait_state = 6;
															#line 347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 5, Void >*>(static_cast<_executeActor*>(this)));
															#line 1800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_5 = success(backupVersions) && success(logVersionValue) && success(rangeCountValue) && success(prevRange) && success(nextRange) && success(verified);
															#line 347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1811 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1cont2when1(__when_expr_5.get(), loopDepth); };
		static_cast<_executeActor*>(this)->actor_wait_state = 6;
															#line 347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 5, Void >*>(static_cast<_executeActor*>(this)));
															#line 1816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _executeActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _executeActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont2loopBody1cont1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 350 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int64_t rangeCount = 0;
															#line 351 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (rangeCountValue.get().present())
															#line 1890 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 352 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			ASSERT(rangeCountValue.get().get().size() == sizeof(int64_t));
															#line 353 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			memcpy(&rangeCount, rangeCountValue.get().get().begin(), rangeCountValue.get().get().size());
															#line 1896 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 356 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool prevAdjacent = prevRange.get().size() && prevRange.get()[0].value.size() && BinaryReader::fromStringRef<Version>(prevRange.get()[0].value, Unversioned()) != invalidVersion;
															#line 359 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool nextAdjacent = nextRange.get().size() && nextRange.get()[0].value.size() && BinaryReader::fromStringRef<Version>(nextRange.get()[0].value, Unversioned()) != invalidVersion;
															#line 363 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if ((!prevAdjacent || !nextAdjacent) && rangeCount > ((prevAdjacent || nextAdjacent) ? CLIENT_KNOBS->BACKUP_MAP_KEY_UPPER_LIMIT : CLIENT_KNOBS->BACKUP_MAP_KEY_LOWER_LIMIT))
															#line 1904 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 366 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TEST(true);
															#line 368 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (rangeCount > CLIENT_KNOBS->BACKUP_MAP_KEY_UPPER_LIMIT)
															#line 1910 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 369 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				TraceEvent(SevWarnAlways, "DBA_KeyRangeMapTooLarge").log();
															#line 1914 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 371 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_6 = delay(1);
															#line 371 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1920 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1cont3when1(__when_expr_6.get(), loopDepth); };
			static_cast<_executeActor*>(this)->actor_wait_state = 7;
															#line 371 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 6, Void >*>(static_cast<_executeActor*>(this)));
															#line 1925 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont2loopBody1cont1loopBody1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 350 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int64_t rangeCount = 0;
															#line 351 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (rangeCountValue.get().present())
															#line 1941 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 352 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			ASSERT(rangeCountValue.get().get().size() == sizeof(int64_t));
															#line 353 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			memcpy(&rangeCount, rangeCountValue.get().get().begin(), rangeCountValue.get().get().size());
															#line 1947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 356 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool prevAdjacent = prevRange.get().size() && prevRange.get()[0].value.size() && BinaryReader::fromStringRef<Version>(prevRange.get()[0].value, Unversioned()) != invalidVersion;
															#line 359 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool nextAdjacent = nextRange.get().size() && nextRange.get()[0].value.size() && BinaryReader::fromStringRef<Version>(nextRange.get()[0].value, Unversioned()) != invalidVersion;
															#line 363 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if ((!prevAdjacent || !nextAdjacent) && rangeCount > ((prevAdjacent || nextAdjacent) ? CLIENT_KNOBS->BACKUP_MAP_KEY_UPPER_LIMIT : CLIENT_KNOBS->BACKUP_MAP_KEY_LOWER_LIMIT))
															#line 1955 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 366 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TEST(true);
															#line 368 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (rangeCount > CLIENT_KNOBS->BACKUP_MAP_KEY_UPPER_LIMIT)
															#line 1961 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 369 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				TraceEvent(SevWarnAlways, "DBA_KeyRangeMapTooLarge").log();
															#line 1965 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 371 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_6 = delay(1);
															#line 371 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 1971 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1cont3when1(__when_expr_6.get(), loopDepth); };
			static_cast<_executeActor*>(this)->actor_wait_state = 7;
															#line 371 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 6, Void >*>(static_cast<_executeActor*>(this)));
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont2loopBody1cont1loopBody1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< _executeActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< _executeActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont2loopBody1cont1loopBody1cont4(int loopDepth) 
	{
															#line 376 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Version logVersion = logVersionValue.get().present() ? BinaryReader::fromStringRef<Version>(logVersionValue.get().get(), Unversioned()) : ::invalidVersion;
															#line 380 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (logVersion >= values.second)
															#line 2055 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 381 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			task->params[BackupRangeTaskFunc::keyBackupRangeBeginKey] = rangeBegin;
															#line 382 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 2061 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActorState();
			static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 387 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Subspace krv(conf.get(DatabaseBackupAgent::keyRangeVersions));
															#line 388 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		versionRange = singleKeyRange(krv.pack(values.second));
															#line 389 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->addReadConflictRange(versionRange);
															#line 390 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->addWriteConflictRange(versionRange);
															#line 392 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int versionLoc = 0;
															#line 393 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		std::vector<Future<Void>> setRanges;
															#line 394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bytesSet = 0;
															#line 396 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for(;;) {
															#line 397 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(;versionLoc < backupVersions.get().size() - 1 && (backupVersions.get()[versionLoc].value.size() < sizeof(Version) || BinaryReader::fromStringRef<Version>(backupVersions.get()[versionLoc].value, Unversioned()) != invalidVersion);) {
															#line 401 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				versionLoc++;
															#line 2087 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 404 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (versionLoc == backupVersions.get().size() - 1)
															#line 2091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
				break;
			}
															#line 407 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (backupVersions.get()[versionLoc + 1].key == (removePrefix == StringRef() ? normalKeys.end : strinc(removePrefix)))
															#line 2097 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 409 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr->clear(KeyRangeRef( backupVersions.get()[versionLoc].key.removePrefix(removePrefix).withPrefix(addPrefix), addPrefix == StringRef() ? normalKeys.end : strinc(addPrefix)));
															#line 2101 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
			else
			{
															#line 413 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr->clear(KeyRangeRef(backupVersions.get()[versionLoc].key, backupVersions.get()[versionLoc + 1].key) .removePrefix(removePrefix) .withPrefix(addPrefix));
															#line 2107 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 419 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			setRanges.push_back(krmSetRange( tr, prefix, KeyRangeRef(backupVersions.get()[versionLoc].key, backupVersions.get()[versionLoc + 1].key), BinaryWriter::toValue(values.second, Unversioned())));
															#line 424 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int64_t added = 1;
															#line 425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->atomicOp(rangeCountKey, StringRef((uint8_t*)&added, 8), MutationRef::AddValue);
															#line 427 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(;valueLoc < values.first.size();++valueLoc) {
															#line 428 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (values.first[valueLoc].key >= backupVersions.get()[versionLoc + 1].key)
															#line 2119 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
					break;
				}
															#line 431 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (values.first[valueLoc].key >= backupVersions.get()[versionLoc].key)
															#line 2125 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 433 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					tr->set(values.first[valueLoc].key.removePrefix(removePrefix).withPrefix(addPrefix), values.first[valueLoc].value);
															#line 435 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					bytesSet += values.first[valueLoc].expectedSize() - removePrefix.expectedSize() + addPrefix.expectedSize();
															#line 2131 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
			}
															#line 440 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			versionLoc++;
															#line 2136 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 443 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_7 = waitForAll(setRanges);
															#line 443 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 2142 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1cont4when1(__when_expr_7.get(), loopDepth); };
		static_cast<_executeActor*>(this)->actor_wait_state = 8;
															#line 443 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 7, Void >*>(static_cast<_executeActor*>(this)));
															#line 2147 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont6(Void const& _,int loopDepth) 
	{
															#line 372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupRangeTaskFunc::keyBackupRangeBeginKey] = rangeBegin;
															#line 373 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 2158 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActorState();
		static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont6(Void && _,int loopDepth) 
	{
															#line 372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupRangeTaskFunc::keyBackupRangeBeginKey] = rangeBegin;
															#line 373 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActorState(); static_cast<_executeActor*>(this)->destroy(); return 0; }
															#line 2172 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActorState();
		static_cast<_executeActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1cont1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< _executeActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1cont1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< _executeActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont2loopBody1cont1loopBody1cont9(Void const& _,int loopDepth) 
	{
															#line 445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_8 = tr->commit();
															#line 445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 2249 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1cont9when1(__when_expr_8.get(), loopDepth); };
		static_cast<_executeActor*>(this)->actor_wait_state = 9;
															#line 445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 8, Void >*>(static_cast<_executeActor*>(this)));
															#line 2254 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont9(Void && _,int loopDepth) 
	{
															#line 445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_8 = tr->commit();
															#line 445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 2265 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1cont2loopBody1cont1loopBody1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont2loopBody1cont1loopBody1cont9when1(__when_expr_8.get(), loopDepth); };
		static_cast<_executeActor*>(this)->actor_wait_state = 9;
															#line 445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< _executeActor, 8, Void >*>(static_cast<_executeActor*>(this)));
															#line 2270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1cont1loopBody1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< _executeActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1cont1loopBody1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< _executeActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1cont2loopBody1cont1loopBody1cont19(Void const& _,int loopDepth) 
	{
															#line 446 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Params.bytesWritten().set(task, Params.bytesWritten().getOrDefault(task) + bytesSet);
															#line 449 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupVersions.get().more)
															#line 2344 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 450 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->reset();
															#line 451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			committedValueLoc = valueLoc;
															#line 452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rangeBegin = backupVersions.get().end()[-1].key;
															#line 2352 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
			return a_body1cont2loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont19cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont19(Void && _,int loopDepth) 
	{
															#line 446 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Params.bytesWritten().set(task, Params.bytesWritten().getOrDefault(task) + bytesSet);
															#line 449 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupVersions.get().more)
															#line 2368 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 450 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->reset();
															#line 451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			committedValueLoc = valueLoc;
															#line 452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rangeBegin = backupVersions.get().end()[-1].key;
															#line 2376 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
			return a_body1cont2loopBody1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont19cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont9when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont19(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1cont9when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont19(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 8, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 8, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1cont1loopBody1cont9when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< _executeActor, 8, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1cont1loopBody1cont9when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< _executeActor, 8, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	int a_body1cont2loopBody1cont1loopBody1cont19cont4(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont2loopBody1cont1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
															#line 458 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		valueLoc = committedValueLoc;
															#line 2466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
															#line 458 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		valueLoc = committedValueLoc;
															#line 2475 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose10() 
	{
		if (static_cast<_executeActor*>(this)->actor_wait_state > 0) static_cast<_executeActor*>(this)->actor_wait_state = 0;
		static_cast<_executeActor*>(this)->ActorCallback< _executeActor, 9, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor, 9, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont2loopBody1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_fire(ActorCallback< _executeActor, 9, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont2loopBody1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_error(ActorCallback< _executeActor, 9, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 9);

	}
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 213 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FlowLock> lock;
															#line 214 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace conf;
															#line 235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	double timeout;
															#line 236 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key addPrefix;
															#line 237 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key removePrefix;
															#line 239 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	KeyRange range;
															#line 243 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	PromiseStream<RangeResultWithVersion> results;
															#line 245 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> rc;
															#line 247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key rangeBegin;
															#line 248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key rangeEnd;
															#line 249 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	bool endOfStream;
															#line 250 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	RangeResultWithVersion nextValues;
															#line 251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t nextValuesSize;
															#line 257 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	RangeResultWithVersion values;
															#line 258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t valuesSize;
															#line 285 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Error err;
															#line 314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int valueLoc;
															#line 315 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int committedValueLoc;
															#line 316 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key prefix;
															#line 324 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key rangeCountKey;
															#line 326 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<RangeResult> backupVersions;
															#line 328 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> logVersionValue;
															#line 331 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> rangeCountValue;
															#line 332 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<RangeResult> prevRange;
															#line 337 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<RangeResult> nextRange;
															#line 342 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> verified;
															#line 388 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	KeyRange versionRange;
															#line 394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t bytesSet;
															#line 2609 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor final : public Actor<Void>, public ActorCallback< _executeActor, 0, Void >, public ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >, public ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >, public ActorCallback< _executeActor, 3, Void >, public ActorCallback< _executeActor, 4, Void >, public ActorCallback< _executeActor, 5, Void >, public ActorCallback< _executeActor, 6, Void >, public ActorCallback< _executeActor, 7, Void >, public ActorCallback< _executeActor, 8, Void >, public ActorCallback< _executeActor, 9, Void >, public FastAllocated<_executeActor>, public _executeActorState<_executeActor> {
															#line 2614 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor>::operator new;
	using FastAllocated<_executeActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor, 0, Void >;
friend struct ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >;
friend struct ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >;
friend struct ActorCallback< _executeActor, 3, Void >;
friend struct ActorCallback< _executeActor, 4, Void >;
friend struct ActorCallback< _executeActor, 5, Void >;
friend struct ActorCallback< _executeActor, 6, Void >;
friend struct ActorCallback< _executeActor, 7, Void >;
friend struct ActorCallback< _executeActor, 8, Void >;
friend struct ActorCallback< _executeActor, 9, Void >;
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 2634 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActorState<_executeActor>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor, 1, Standalone<VectorRef<KeyRef>> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorSingleCallback< _executeActor, 2, RangeResultWithVersion >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _executeActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _executeActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< _executeActor, 5, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< _executeActor, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< _executeActor, 7, Void >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< _executeActor, 8, Void >*)0, actor_cancelled()); break;
		case 10: this->a_callback_error((ActorCallback< _executeActor, 9, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor(cx, taskBucket, futureBucket, task));
															#line 2670 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 465 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 2675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via startBackupRangeInternal()
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class StartBackupRangeInternalActor>
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class StartBackupRangeInternalActorState {
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	StartBackupRangeInternalActorState(Reference<ReadYourWritesTransaction> const& tr,Standalone<VectorRef<KeyRef>> const& keys,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task,Reference<TaskFuture> const& onDone) 
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   keys(keys),
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   onDone(onDone)
															#line 2698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("startBackupRangeInternal", reinterpret_cast<unsigned long>(this));

	}
	~StartBackupRangeInternalActorState() 
	{
		fdb_probe_actor_destroy("startBackupRangeInternal", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 472 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 473 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 474 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextKey = task->params[BackupAgentBase::keyBeginKey];
															#line 476 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			std::vector<Future<Key>> addTaskVector;
															#line 477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(int idx = 0;idx < keys.size();++idx) {
															#line 478 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (nextKey != keys[idx])
															#line 2723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					addTaskVector.push_back( addTask(tr, taskBucket, task, nextKey, keys[idx], TaskCompletionKey::joinWith(onDone)));
															#line 2727 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
															#line 482 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				nextKey = keys[idx];
															#line 2731 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 485 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (nextKey != task->params[BackupAgentBase::keyEndKey])
															#line 2735 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 486 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(addTask(tr, taskBucket, task, nextKey, task->params[BackupAgentBase::keyEndKey], TaskCompletionKey::joinWith(onDone)));
															#line 2739 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 494 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = waitForAll(addTaskVector);
															#line 494 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<StartBackupRangeInternalActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 2745 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<StartBackupRangeInternalActor*>(this)->actor_wait_state = 1;
															#line 494 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< StartBackupRangeInternalActor, 0, Void >*>(static_cast<StartBackupRangeInternalActor*>(this)));
															#line 2750 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~StartBackupRangeInternalActorState();
		static_cast<StartBackupRangeInternalActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 496 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<StartBackupRangeInternalActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~StartBackupRangeInternalActorState(); static_cast<StartBackupRangeInternalActor*>(this)->destroy(); return 0; }
															#line 2773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<StartBackupRangeInternalActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~StartBackupRangeInternalActorState();
		static_cast<StartBackupRangeInternalActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 496 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<StartBackupRangeInternalActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~StartBackupRangeInternalActorState(); static_cast<StartBackupRangeInternalActor*>(this)->destroy(); return 0; }
															#line 2785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<StartBackupRangeInternalActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~StartBackupRangeInternalActorState();
		static_cast<StartBackupRangeInternalActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<StartBackupRangeInternalActor*>(this)->actor_wait_state > 0) static_cast<StartBackupRangeInternalActor*>(this)->actor_wait_state = 0;
		static_cast<StartBackupRangeInternalActor*>(this)->ActorCallback< StartBackupRangeInternalActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< StartBackupRangeInternalActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< StartBackupRangeInternalActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< StartBackupRangeInternalActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRef>> keys;
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> onDone;
															#line 474 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key nextKey;
															#line 2870 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via startBackupRangeInternal()
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class StartBackupRangeInternalActor final : public Actor<Void>, public ActorCallback< StartBackupRangeInternalActor, 0, Void >, public FastAllocated<StartBackupRangeInternalActor>, public StartBackupRangeInternalActorState<StartBackupRangeInternalActor> {
															#line 2875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<StartBackupRangeInternalActor>::operator new;
	using FastAllocated<StartBackupRangeInternalActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< StartBackupRangeInternalActor, 0, Void >;
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	StartBackupRangeInternalActor(Reference<ReadYourWritesTransaction> const& tr,Standalone<VectorRef<KeyRef>> const& keys,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task,Reference<TaskFuture> const& onDone) 
															#line 2886 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   StartBackupRangeInternalActorState<StartBackupRangeInternalActor>(tr, keys, taskBucket, futureBucket, task, onDone)
	{
		fdb_probe_actor_enter("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("startBackupRangeInternal");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("startBackupRangeInternal", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< StartBackupRangeInternalActor, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> startBackupRangeInternal( Reference<ReadYourWritesTransaction> const& tr, Standalone<VectorRef<KeyRef>> const& keys, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task, Reference<TaskFuture> const& onDone ) {
															#line 466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new StartBackupRangeInternalActor(tr, keys, taskBucket, futureBucket, task, onDone));
															#line 2913 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 498 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 2918 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor>
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActorState {
															#line 2924 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActorState(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 503 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskFuture(futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]))
															#line 2939 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActorState() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 507 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			DRConfig config(task);
															#line 508 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int64_t bytesWritten = Params.bytesWritten().getOrDefault(task);
															#line 509 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			config.rangeBytesWritten().atomicOp(tr, bytesWritten, MutationRef::AddValue);
															#line 511 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (task->params.find(BackupRangeTaskFunc::keyAddBackupRangeTasks) != task->params.end())
															#line 2960 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 512 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_0 = startBackupRangeInternal( tr, BinaryReader::fromStringRef<Standalone<VectorRef<KeyRef>>>( task->params[BackupRangeTaskFunc::keyAddBackupRangeTasks], IncludeVersion()), taskBucket, futureBucket, task, taskFuture) && taskBucket->finish(tr, task);
															#line 512 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 2966 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<_finishActor*>(this)->actor_wait_state = 1;
															#line 512 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor, 0, Void >*>(static_cast<_finishActor*>(this)));
															#line 2971 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 521 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (task->params.find(BackupRangeTaskFunc::keyBackupRangeBeginKey) != task->params.end() && task->params[BackupRangeTaskFunc::keyBackupRangeBeginKey] < task->params[BackupAgentBase::keyEndKey])
															#line 2978 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 524 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					ASSERT(taskFuture->key.size() > 0);
															#line 525 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					StrictFuture<Void> __when_expr_1 = success(BackupRangeTaskFunc::addTask(tr, taskBucket, task, task->params[BackupRangeTaskFunc::keyBackupRangeBeginKey], task->params[BackupAgentBase::keyEndKey], TaskCompletionKey::signal(taskFuture->key))) && taskBucket->finish(tr, task);
															#line 525 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					if (static_cast<_finishActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 2986 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
					static_cast<_finishActor*>(this)->actor_wait_state = 2;
															#line 525 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor, 1, Void >*>(static_cast<_finishActor*>(this)));
															#line 2991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					loopDepth = 0;
				}
				else
				{
															#line 533 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					StrictFuture<Void> __when_expr_2 = taskFuture->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 533 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					if (static_cast<_finishActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1when3(__when_expr_2.get(), loopDepth); };
					static_cast<_finishActor*>(this)->actor_wait_state = 3;
															#line 533 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor, 2, Void >*>(static_cast<_finishActor*>(this)));
															#line 3005 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					loopDepth = 0;
				}
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActorState();
		static_cast<_finishActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 536 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActorState(); static_cast<_finishActor*>(this)->destroy(); return 0; }
															#line 3030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActorState();
		static_cast<_finishActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor*>(this)->actor_wait_state > 0) static_cast<_finishActor*>(this)->actor_wait_state = 0;
		static_cast<_finishActor*>(this)->ActorCallback< _finishActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor*>(this)->actor_wait_state > 0) static_cast<_finishActor*>(this)->actor_wait_state = 0;
		static_cast<_finishActor*>(this)->ActorCallback< _finishActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1when3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1when3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor*>(this)->actor_wait_state > 0) static_cast<_finishActor*>(this)->actor_wait_state = 0;
		static_cast<_finishActor*>(this)->ActorCallback< _finishActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1when3(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1when3(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 503 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> taskFuture;
															#line 3279 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor final : public Actor<Void>, public ActorCallback< _finishActor, 0, Void >, public ActorCallback< _finishActor, 1, Void >, public ActorCallback< _finishActor, 2, Void >, public FastAllocated<_finishActor>, public _finishActorState<_finishActor> {
															#line 3284 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor>::operator new;
	using FastAllocated<_finishActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor, 0, Void >;
friend struct ActorCallback< _finishActor, 1, Void >;
friend struct ActorCallback< _finishActor, 2, Void >;
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 3297 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActorState<_finishActor>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor(tr, taskBucket, futureBucket, task));
															#line 3326 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 538 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
};
StringRef BackupRangeTaskFunc::name = LiteralStringRef("dr_backup_range");
const Key BackupRangeTaskFunc::keyAddBackupRangeTasks = LiteralStringRef("addBackupRangeTasks");
const Key BackupRangeTaskFunc::keyBackupRangeBeginKey = LiteralStringRef("backupRangeBeginKey");
REGISTER_TASKFUNC(BackupRangeTaskFunc);

struct FinishFullBackupTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 3340 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor1>
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor1State {
															#line 3346 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor1State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 552 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   states(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyStates) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 3361 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor1State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(tr, task, FinishFullBackupTaskFunc::name, FinishFullBackupTaskFunc::version);
															#line 555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3378 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor1*>(this)->actor_wait_state = 1;
															#line 555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor1, 0, Void >*>(static_cast<_finishActor1*>(this)));
															#line 3383 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor1State();
		static_cast<_finishActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 558 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Transaction srcTr(taskBucket->src);
															#line 559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Version> __when_expr_1 = srcTr.getReadVersion();
															#line 560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3412 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor1*>(this)->actor_wait_state = 2;
															#line 560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor1, 1, Version >*>(static_cast<_finishActor1*>(this)));
															#line 3417 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 558 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Transaction srcTr(taskBucket->src);
															#line 559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Version> __when_expr_1 = srcTr.getReadVersion();
															#line 560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3432 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor1*>(this)->actor_wait_state = 2;
															#line 560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor1, 1, Version >*>(static_cast<_finishActor1*>(this)));
															#line 3437 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor1*>(this)->actor_wait_state > 0) static_cast<_finishActor1*>(this)->actor_wait_state = 0;
		static_cast<_finishActor1*>(this)->ActorCallback< _finishActor1, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor1, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor1, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor1, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Version const& readVersion,int loopDepth) 
	{
															#line 561 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(states.pack(DatabaseBackupAgent::keyCopyStop), BinaryWriter::toValue(readVersion, Unversioned()));
															#line 562 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_FinishFullBackup").detail("CopyStop", readVersion);
															#line 563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = taskBucket->finish(tr, task);
															#line 563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3515 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_finishActor1*>(this)->actor_wait_state = 3;
															#line 563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor1, 2, Void >*>(static_cast<_finishActor1*>(this)));
															#line 3520 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2(Version && readVersion,int loopDepth) 
	{
															#line 561 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(states.pack(DatabaseBackupAgent::keyCopyStop), BinaryWriter::toValue(readVersion, Unversioned()));
															#line 562 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_FinishFullBackup").detail("CopyStop", readVersion);
															#line 563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = taskBucket->finish(tr, task);
															#line 563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3535 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_finishActor1*>(this)->actor_wait_state = 3;
															#line 563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor1, 2, Void >*>(static_cast<_finishActor1*>(this)));
															#line 3540 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(Version const& readVersion,int loopDepth) 
	{
		loopDepth = a_body1cont2(readVersion, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Version && readVersion,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(readVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor1*>(this)->actor_wait_state > 0) static_cast<_finishActor1*>(this)->actor_wait_state = 0;
		static_cast<_finishActor1*>(this)->ActorCallback< _finishActor1, 1, Version >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor1, 1, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor1, 1, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor1, 1, Version >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
															#line 565 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor1State(); static_cast<_finishActor1*>(this)->destroy(); return 0; }
															#line 3612 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor1State();
		static_cast<_finishActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
															#line 565 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor1State(); static_cast<_finishActor1*>(this)->destroy(); return 0; }
															#line 3624 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor1State();
		static_cast<_finishActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor1*>(this)->actor_wait_state > 0) static_cast<_finishActor1*>(this)->actor_wait_state = 0;
		static_cast<_finishActor1*>(this)->ActorCallback< _finishActor1, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor1, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor1, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor1, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 552 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace states;
															#line 3705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor1 final : public Actor<Void>, public ActorCallback< _finishActor1, 0, Void >, public ActorCallback< _finishActor1, 1, Version >, public ActorCallback< _finishActor1, 2, Void >, public FastAllocated<_finishActor1>, public _finishActor1State<_finishActor1> {
															#line 3710 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor1>::operator new;
	using FastAllocated<_finishActor1>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor1, 0, Void >;
friend struct ActorCallback< _finishActor1, 1, Version >;
friend struct ActorCallback< _finishActor1, 2, Void >;
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor1(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 3723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor1State<_finishActor1>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor1, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor1, 1, Version >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor1, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor1(tr, taskBucket, futureBucket, task));
															#line 3752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 567 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 3757 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor1>
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor1State {
															#line 3763 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor1State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 3778 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor1State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 574 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 574 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3795 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor1*>(this)->actor_wait_state = 1;
															#line 574 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor1, 0, Key >*>(static_cast<AddTaskActor1*>(this)));
															#line 3800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor1State();
		static_cast<AddTaskActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 575 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(FinishFullBackupTaskFunc::name, FinishFullBackupTaskFunc::version, doneKey);
															#line 577 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 579 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 3827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 580 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor1*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor1State(); static_cast<AddTaskActor1*>(this)->destroy(); return 0; }
															#line 3831 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor1*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor1State();
			static_cast<AddTaskActor1*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3841 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor1*>(this)->actor_wait_state = 2;
															#line 586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor1, 1, Void >*>(static_cast<AddTaskActor1*>(this)));
															#line 3846 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 575 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(FinishFullBackupTaskFunc::name, FinishFullBackupTaskFunc::version, doneKey);
															#line 577 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 579 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 3859 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 580 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor1*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor1State(); static_cast<AddTaskActor1*>(this)->destroy(); return 0; }
															#line 3863 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor1*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor1State();
			static_cast<AddTaskActor1*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 3873 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor1*>(this)->actor_wait_state = 2;
															#line 586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor1, 1, Void >*>(static_cast<AddTaskActor1*>(this)));
															#line 3878 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor1*>(this)->actor_wait_state > 0) static_cast<AddTaskActor1*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor1*>(this)->ActorCallback< AddTaskActor1, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor1, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor1, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor1, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 591 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor1*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor1State(); static_cast<AddTaskActor1*>(this)->destroy(); return 0; }
															#line 3950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor1*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor1State();
		static_cast<AddTaskActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 591 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor1*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor1State(); static_cast<AddTaskActor1*>(this)->destroy(); return 0; }
															#line 3962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor1*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor1State();
		static_cast<AddTaskActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor1*>(this)->actor_wait_state > 0) static_cast<AddTaskActor1*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor1*>(this)->ActorCallback< AddTaskActor1, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor1, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor1, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor1, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 4043 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor1 final : public Actor<Key>, public ActorCallback< AddTaskActor1, 0, Key >, public ActorCallback< AddTaskActor1, 1, Void >, public FastAllocated<AddTaskActor1>, public AddTaskActor1State<AddTaskActor1> {
															#line 4048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor1>::operator new;
	using FastAllocated<AddTaskActor1>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor1, 0, Key >;
friend struct ActorCallback< AddTaskActor1, 1, Void >;
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor1(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 4060 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor1State<AddTaskActor1>(tr, taskBucket, parentTask, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor1, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor1, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor1(tr, taskBucket, parentTask, completionKey, waitFor));
															#line 4088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 593 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return Void();
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef FinishFullBackupTaskFunc::name = LiteralStringRef("dr_finish_full_backup");
REGISTER_TASKFUNC(FinishFullBackupTaskFunc);

struct EraseLogRangeTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};

																#line 4130 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor1>
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor1State {
															#line 4136 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor1State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lock(CLIENT_KNOBS->BACKUP_LOCK_BYTES)
															#line 4151 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor1State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 637 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, EraseLogRangeTaskFunc::name, EraseLogRangeTaskFunc::version);
															#line 637 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 4168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor1*>(this)->actor_wait_state = 1;
															#line 637 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor1, 0, Void >*>(static_cast<_executeActor1*>(this)));
															#line 4173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor1State();
		static_cast<_executeActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 639 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 640 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 4198 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 639 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 640 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 4209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor1*>(this)->actor_wait_state > 0) static_cast<_executeActor1*>(this)->actor_wait_state = 0;
		static_cast<_executeActor1*>(this)->ActorCallback< _executeActor1, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor1, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor1, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor1, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
		try {
															#line 642 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version endVersion = BinaryReader::fromStringRef<Version>( task->params[DatabaseBackupAgent::keyEndVersion], Unversioned());
															#line 644 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_1 = eraseLogData( tr, task->params[BackupAgentBase::keyConfigLogUid], task->params[BackupAgentBase::destUid], Optional<Version>(endVersion), CheckBackupUID::True, BinaryReader::fromStringRef<Version>(task->params[BackupAgentBase::keyFolderId], Unversioned()));
															#line 644 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor1*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 4293 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<_executeActor1*>(this)->actor_wait_state = 2;
															#line 644 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor1, 1, Void >*>(static_cast<_executeActor1*>(this)));
															#line 4298 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 654 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr->onError(e);
															#line 654 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 4322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<_executeActor1*>(this)->actor_wait_state = 4;
															#line 654 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor1, 3, Void >*>(static_cast<_executeActor1*>(this)));
															#line 4327 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor1*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 4344 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor1*>(this)->actor_wait_state = 3;
															#line 651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor1, 2, Void >*>(static_cast<_executeActor1*>(this)));
															#line 4349 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor1*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 4360 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor1*>(this)->actor_wait_state = 3;
															#line 651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor1, 2, Void >*>(static_cast<_executeActor1*>(this)));
															#line 4365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor1*>(this)->actor_wait_state > 0) static_cast<_executeActor1*>(this)->actor_wait_state = 0;
		static_cast<_executeActor1*>(this)->ActorCallback< _executeActor1, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor1, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor1, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor1, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 652 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor1State(); static_cast<_executeActor1*>(this)->destroy(); return 0; }
															#line 4437 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor1State();
		static_cast<_executeActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 652 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor1State(); static_cast<_executeActor1*>(this)->destroy(); return 0; }
															#line 4449 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor1*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor1State();
		static_cast<_executeActor1*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_executeActor1*>(this)->actor_wait_state > 0) static_cast<_executeActor1*>(this)->actor_wait_state = 0;
		static_cast<_executeActor1*>(this)->ActorCallback< _executeActor1, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor1, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _executeActor1, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _executeActor1, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_executeActor1*>(this)->actor_wait_state > 0) static_cast<_executeActor1*>(this)->actor_wait_state = 0;
		static_cast<_executeActor1*>(this)->ActorCallback< _executeActor1, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor1, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _executeActor1, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _executeActor1, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	FlowLock lock;
															#line 639 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 4607 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor1 final : public Actor<Void>, public ActorCallback< _executeActor1, 0, Void >, public ActorCallback< _executeActor1, 1, Void >, public ActorCallback< _executeActor1, 2, Void >, public ActorCallback< _executeActor1, 3, Void >, public FastAllocated<_executeActor1>, public _executeActor1State<_executeActor1> {
															#line 4612 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor1>::operator new;
	using FastAllocated<_executeActor1>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor1, 0, Void >;
friend struct ActorCallback< _executeActor1, 1, Void >;
friend struct ActorCallback< _executeActor1, 2, Void >;
friend struct ActorCallback< _executeActor1, 3, Void >;
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor1(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 4626 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor1State<_executeActor1>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor1, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor1, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _executeActor1, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _executeActor1, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor1(cx, taskBucket, futureBucket, task));
															#line 4656 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 4661 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor2>
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor2State {
															#line 4667 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor2State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& endVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endVersion(endVersion),
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 4684 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor2State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 665 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 665 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor2*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 4701 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor2*>(this)->actor_wait_state = 1;
															#line 665 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor2, 0, Key >*>(static_cast<AddTaskActor2*>(this)));
															#line 4706 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor2State();
		static_cast<AddTaskActor2*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 666 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(EraseLogRangeTaskFunc::name, EraseLogRangeTaskFunc::version, doneKey, 1);
															#line 668 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 670 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(1, Unversioned());
															#line 672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyEndVersion] = BinaryWriter::toValue(endVersion, Unversioned());
															#line 674 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 4737 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor2*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor2State(); static_cast<AddTaskActor2*>(this)->destroy(); return 0; }
															#line 4741 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor2*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor2State();
			static_cast<AddTaskActor2*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor2*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 4751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor2*>(this)->actor_wait_state = 2;
															#line 681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor2, 1, Void >*>(static_cast<AddTaskActor2*>(this)));
															#line 4756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 666 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(EraseLogRangeTaskFunc::name, EraseLogRangeTaskFunc::version, doneKey, 1);
															#line 668 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 670 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(1, Unversioned());
															#line 672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyEndVersion] = BinaryWriter::toValue(endVersion, Unversioned());
															#line 674 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 4773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor2*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor2State(); static_cast<AddTaskActor2*>(this)->destroy(); return 0; }
															#line 4777 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor2*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor2State();
			static_cast<AddTaskActor2*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor2*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 4787 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor2*>(this)->actor_wait_state = 2;
															#line 681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor2, 1, Void >*>(static_cast<AddTaskActor2*>(this)));
															#line 4792 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor2*>(this)->actor_wait_state > 0) static_cast<AddTaskActor2*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor2*>(this)->ActorCallback< AddTaskActor2, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor2, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor2, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor2, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 686 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor2*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor2State(); static_cast<AddTaskActor2*>(this)->destroy(); return 0; }
															#line 4864 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor2*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor2State();
		static_cast<AddTaskActor2*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 686 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor2*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor2State(); static_cast<AddTaskActor2*>(this)->destroy(); return 0; }
															#line 4876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor2*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor2State();
		static_cast<AddTaskActor2*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor2*>(this)->actor_wait_state > 0) static_cast<AddTaskActor2*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor2*>(this)->ActorCallback< AddTaskActor2, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor2, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor2, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor2, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 4959 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor2 final : public Actor<Key>, public ActorCallback< AddTaskActor2, 0, Key >, public ActorCallback< AddTaskActor2, 1, Void >, public FastAllocated<AddTaskActor2>, public AddTaskActor2State<AddTaskActor2> {
															#line 4964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor2>::operator new;
	using FastAllocated<AddTaskActor2>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor2, 0, Key >;
friend struct ActorCallback< AddTaskActor2, 1, Void >;
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor2(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& endVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 4976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor2State<AddTaskActor2>(tr, taskBucket, parentTask, endVersion, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor2, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor2, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, Version const& endVersion, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor2(tr, taskBucket, parentTask, endVersion, completionKey, waitFor));
															#line 5004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 688 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 5009 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor2>
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor2State {
															#line 5015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor2State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskFuture(futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]))
															#line 5030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor2State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 696 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = taskFuture->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 696 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor2*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 5047 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor2*>(this)->actor_wait_state = 1;
															#line 696 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor2, 0, Void >*>(static_cast<_finishActor2*>(this)));
															#line 5052 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor2State();
		static_cast<_finishActor2*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 697 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor2*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor2State(); static_cast<_finishActor2*>(this)->destroy(); return 0; }
															#line 5075 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor2*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor2State();
		static_cast<_finishActor2*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 697 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor2*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor2State(); static_cast<_finishActor2*>(this)->destroy(); return 0; }
															#line 5087 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor2*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor2State();
		static_cast<_finishActor2*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor2*>(this)->actor_wait_state > 0) static_cast<_finishActor2*>(this)->actor_wait_state = 0;
		static_cast<_finishActor2*>(this)->ActorCallback< _finishActor2, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor2, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor2, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor2, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> taskFuture;
															#line 5168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor2 final : public Actor<Void>, public ActorCallback< _finishActor2, 0, Void >, public FastAllocated<_finishActor2>, public _finishActor2State<_finishActor2> {
															#line 5173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor2>::operator new;
	using FastAllocated<_finishActor2>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor2, 0, Void >;
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor2(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 5184 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor2State<_finishActor2>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor2, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor2(tr, taskBucket, futureBucket, task));
															#line 5211 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 699 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
};
StringRef EraseLogRangeTaskFunc::name = LiteralStringRef("dr_erase_log_range");
REGISTER_TASKFUNC(EraseLogRangeTaskFunc);

struct CopyLogRangeTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

	static struct {
		static TaskParam<int64_t> bytesWritten() { return LiteralStringRef(__FUNCTION__); }
	} Params;

	static const Key keyNextBeginVersion;

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};

	// store mutation data from results until the end of stream or the timeout. If breaks on timeout returns the first
	// uncopied version
																#line 5246 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via dumpData()
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class DumpDataActor>
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class DumpDataActorState {
															#line 5252 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DumpDataActorState(Database const& cx,Reference<Task> const& task,PromiseStream<RCGroup> const& results,FlowLock* const& lock,Reference<TaskBucket> const& tb,double const& breakTime) 
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   results(results),
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lock(lock),
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tb(tb),
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   breakTime(breakTime),
															#line 736 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endOfStream(false),
															#line 737 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   conf(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[BackupAgentBase::keyConfigLogUid])),
															#line 740 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   nextMutations(),
															#line 741 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   isTimeoutOccured(false),
															#line 742 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lastKey(),
															#line 743 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lastVersion(),
															#line 744 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   nextMutationSize(0)
															#line 5283 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("dumpData", reinterpret_cast<unsigned long>(this));

	}
	~DumpDataActorState() 
	{
		fdb_probe_actor_destroy("dumpData", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 745 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			;
															#line 5298 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DumpDataActorState();
		static_cast<DumpDataActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 747 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (endOfStream && !nextMutationSize)
															#line 5329 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 748 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (!static_cast<DumpDataActor*>(this)->SAV<Optional<Version>>::futures) { (void)(Optional<Version>()); this->~DumpDataActorState(); static_cast<DumpDataActor*>(this)->destroy(); return 0; }
															#line 5333 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				new (&static_cast<DumpDataActor*>(this)->SAV< Optional<Version> >::value()) Optional<Version>(Optional<Version>());
				this->~DumpDataActorState();
				static_cast<DumpDataActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			mutations = std::move(nextMutations);
															#line 752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			mutationSize = nextMutationSize;
															#line 753 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutations = std::vector<RangeResult>();
															#line 754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutationSize = 0;
															#line 756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!endOfStream)
															#line 5349 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 757 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				;
															#line 5353 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = a_body1loopBody1loopHead1(loopDepth);
			}
			else
			{
				loopDepth = a_body1loopBody1cont2(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 841 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (e.code() == error_code_actor_cancelled || e.code() == error_code_backup_error)
															#line 5380 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 842 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 5384 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 844 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			err = e;
															#line 845 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = logError(cx, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyErrors) .pack(task->params[BackupAgentBase::keyConfigLogUid]), format("ERROR: Failed to dump mutations because of error %s", err.what()));
															#line 845 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 5392 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<DumpDataActor*>(this)->actor_wait_state = 5;
															#line 845 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor, 4, Void >*>(static_cast<DumpDataActor*>(this)));
															#line 5397 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
															#line 784 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextVersionAfterBreak = Optional<Version>();
															#line 785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Transaction(cx);
															#line 787 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 5416 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1(int loopDepth) 
	{
		try {
															#line 759 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			FutureStream<RCGroup> __when_expr_0 = results.getFuture();
															#line 759 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor*>(this)->actor_wait_state < 0) return a_body1loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 5441 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1loopBody1when1(__when_expr_0.pop(), loopDepth); };
			static_cast<DumpDataActor*>(this)->actor_wait_state = 1;
															#line 759 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< DumpDataActor, 0, RCGroup >*>(static_cast<DumpDataActor*>(this)));
															#line 5446 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			error = e;
															#line 774 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (e.code() == error_code_end_of_stream)
															#line 5483 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 775 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				endOfStream = true;
															#line 5487 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				return a_body1loopBody1break1(loopDepth==0?0:loopDepth-1); // break
			}
															#line 779 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
															#line 5492 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1loopBody1cont2(RCGroup const& group,int loopDepth) 
	{
															#line 760 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		lock->release(group.items.expectedSize());
															#line 762 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int vecSize = group.items.expectedSize();
															#line 763 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (mutationSize + vecSize >= CLIENT_KNOBS->BACKUP_LOG_WRITE_BATCH_MAX_SIZE)
															#line 5510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutations.push_back(group.items);
															#line 766 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutationSize = vecSize;
															#line 5516 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			return a_body1loopBody1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 770 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutations.push_back(group.items);
															#line 771 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutationSize += vecSize;
															#line 5523 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1cont2(RCGroup && group,int loopDepth) 
	{
															#line 760 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		lock->release(group.items.expectedSize());
															#line 762 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int vecSize = group.items.expectedSize();
															#line 763 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (mutationSize + vecSize >= CLIENT_KNOBS->BACKUP_LOG_WRITE_BATCH_MAX_SIZE)
															#line 5536 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutations.push_back(group.items);
															#line 766 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutationSize = vecSize;
															#line 5542 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			return a_body1loopBody1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 770 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutations.push_back(group.items);
															#line 771 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutationSize += vecSize;
															#line 5549 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1when1(RCGroup const& group,int loopDepth) 
	{
		loopDepth = a_body1loopBody1loopBody1cont2(group, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1when1(RCGroup && group,int loopDepth) 
	{
		loopDepth = a_body1loopBody1loopBody1cont2(std::move(group), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DumpDataActor*>(this)->actor_wait_state > 0) static_cast<DumpDataActor*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor*>(this)->ActorSingleCallback< DumpDataActor, 0, RCGroup >::remove();

	}
	void a_callback_fire(ActorSingleCallback< DumpDataActor, 0, RCGroup >*,RCGroup const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< DumpDataActor, 0, RCGroup >*,RCGroup && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< DumpDataActor, 0, RCGroup >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
															#line 829 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (nextVersionAfterBreak.present())
															#line 5634 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<DumpDataActor*>(this)->SAV<Optional<Version>>::futures) { (void)(nextVersionAfterBreak); this->~DumpDataActorState(); static_cast<DumpDataActor*>(this)->destroy(); return 0; }
															#line 5638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<DumpDataActor*>(this)->SAV< Optional<Version> >::value()) Optional<Version>(std::move(nextVersionAfterBreak)); // state_var_RVO
			this->~DumpDataActorState();
			static_cast<DumpDataActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 832 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!isTimeoutOccured && timer_monotonic() >= breakTime && lastKey.present())
															#line 5646 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 837 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			lastVersion = getLogKeyVersion(lastKey.get());
															#line 838 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			isTimeoutOccured = true;
															#line 5652 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		loopDepth = a_body1loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1(int loopDepth) 
	{
		try {
															#line 789 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 790 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr.trState->options.sizeLimit = 2 * CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT;
															#line 791 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_1 = checkDatabaseLock(&tr, BinaryReader::fromStringRef<UID>( task->params[BackupAgentBase::keyConfigLogUid], Unversioned()));
															#line 791 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 5676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont2loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<DumpDataActor*>(this)->actor_wait_state = 2;
															#line 791 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor, 1, Void >*>(static_cast<DumpDataActor*>(this)));
															#line 5681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont2loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont2loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont5(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 826 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr.onError(e);
															#line 826 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 5718 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont2loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<DumpDataActor*>(this)->actor_wait_state = 4;
															#line 826 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor, 3, Void >*>(static_cast<DumpDataActor*>(this)));
															#line 5723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 794 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bytesSet = 0;
															#line 796 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool first = true;
															#line 797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto m : mutations ) {
															#line 798 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto kv : m ) {
															#line 799 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (isTimeoutOccured)
															#line 5746 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					Version newVersion = getLogKeyVersion(kv.key);
															#line 802 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					if (newVersion > lastVersion)
															#line 5752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					{
															#line 803 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
						nextVersionAfterBreak = newVersion;
															#line 5756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
						break;
					}
				}
															#line 807 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (first)
															#line 5762 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 808 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					tr.addReadConflictRange(singleKeyRange(kv.key));
															#line 809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					first = false;
															#line 5768 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
															#line 811 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr.set(kv.key.removePrefix(backupLogKeys.begin) .removePrefix(task->params[BackupAgentBase::destUid]) .withPrefix(task->params[BackupAgentBase::keyConfigLogUid]) .withPrefix(applyLogKeys.begin), kv.value);
															#line 816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				bytesSet += kv.expectedSize() - backupLogKeys.begin.expectedSize() + applyLogKeys.begin.expectedSize();
															#line 818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				lastKey = kv.key;
															#line 5776 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr.commit();
															#line 822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<DumpDataActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 5783 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont2loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<DumpDataActor*>(this)->actor_wait_state = 3;
															#line 822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor, 2, Void >*>(static_cast<DumpDataActor*>(this)));
															#line 5788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 794 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bytesSet = 0;
															#line 796 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool first = true;
															#line 797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto m : mutations ) {
															#line 798 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto kv : m ) {
															#line 799 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (isTimeoutOccured)
															#line 5805 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					Version newVersion = getLogKeyVersion(kv.key);
															#line 802 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					if (newVersion > lastVersion)
															#line 5811 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					{
															#line 803 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
						nextVersionAfterBreak = newVersion;
															#line 5815 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
						break;
					}
				}
															#line 807 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (first)
															#line 5821 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 808 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					tr.addReadConflictRange(singleKeyRange(kv.key));
															#line 809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					first = false;
															#line 5827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
															#line 811 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr.set(kv.key.removePrefix(backupLogKeys.begin) .removePrefix(task->params[BackupAgentBase::destUid]) .withPrefix(task->params[BackupAgentBase::keyConfigLogUid]) .withPrefix(applyLogKeys.begin), kv.value);
															#line 816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				bytesSet += kv.expectedSize() - backupLogKeys.begin.expectedSize() + applyLogKeys.begin.expectedSize();
															#line 818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				lastKey = kv.key;
															#line 5835 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr.commit();
															#line 822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<DumpDataActor*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 5842 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont2loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<DumpDataActor*>(this)->actor_wait_state = 3;
															#line 822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor, 2, Void >*>(static_cast<DumpDataActor*>(this)));
															#line 5847 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DumpDataActor*>(this)->actor_wait_state > 0) static_cast<DumpDataActor*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor*>(this)->ActorCallback< DumpDataActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DumpDataActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont2loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Params.bytesWritten().set(task, Params.bytesWritten().getOrDefault(task) + bytesSet);
															#line 5919 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Params.bytesWritten().set(task, Params.bytesWritten().getOrDefault(task) + bytesSet);
															#line 5928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<DumpDataActor*>(this)->actor_wait_state > 0) static_cast<DumpDataActor*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor*>(this)->ActorCallback< DumpDataActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< DumpDataActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont2loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<DumpDataActor*>(this)->actor_wait_state > 0) static_cast<DumpDataActor*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor*>(this)->ActorCallback< DumpDataActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont2loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont2loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< DumpDataActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont9(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
															#line 851 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 1));
															#line 6088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
															#line 851 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 1));
															#line 6096 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<DumpDataActor*>(this)->actor_wait_state > 0) static_cast<DumpDataActor*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor*>(this)->ActorCallback< DumpDataActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< DumpDataActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< DumpDataActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	PromiseStream<RCGroup> results;
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	FlowLock* lock;
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> tb;
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	double breakTime;
															#line 736 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	bool endOfStream;
															#line 737 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace conf;
															#line 740 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<RangeResult> nextMutations;
															#line 741 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	bool isTimeoutOccured;
															#line 742 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<KeyRef> lastKey;
															#line 743 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version lastVersion;
															#line 744 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t nextMutationSize;
															#line 751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<RangeResult> mutations;
															#line 752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t mutationSize;
															#line 773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Error error;
															#line 784 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Version> nextVersionAfterBreak;
															#line 785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Transaction tr;
															#line 794 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t bytesSet;
															#line 844 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Error err;
															#line 6203 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via dumpData()
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class DumpDataActor final : public Actor<Optional<Version>>, public ActorSingleCallback< DumpDataActor, 0, RCGroup >, public ActorCallback< DumpDataActor, 1, Void >, public ActorCallback< DumpDataActor, 2, Void >, public ActorCallback< DumpDataActor, 3, Void >, public ActorCallback< DumpDataActor, 4, Void >, public FastAllocated<DumpDataActor>, public DumpDataActorState<DumpDataActor> {
															#line 6208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<DumpDataActor>::operator new;
	using FastAllocated<DumpDataActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Optional<Version>>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< DumpDataActor, 0, RCGroup >;
friend struct ActorCallback< DumpDataActor, 1, Void >;
friend struct ActorCallback< DumpDataActor, 2, Void >;
friend struct ActorCallback< DumpDataActor, 3, Void >;
friend struct ActorCallback< DumpDataActor, 4, Void >;
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DumpDataActor(Database const& cx,Reference<Task> const& task,PromiseStream<RCGroup> const& results,FlowLock* const& lock,Reference<TaskBucket> const& tb,double const& breakTime) 
															#line 6223 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Optional<Version>>(),
		   DumpDataActorState<DumpDataActor>(cx, task, results, lock, tb, breakTime)
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("dumpData");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< DumpDataActor, 0, RCGroup >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DumpDataActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< DumpDataActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< DumpDataActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< DumpDataActor, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Optional<Version>> dumpData( Database const& cx, Reference<Task> const& task, PromiseStream<RCGroup> const& results, FlowLock* const& lock, Reference<TaskBucket> const& tb, double const& breakTime ) {
															#line 730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Optional<Version>>(new DumpDataActor(cx, task, results, lock, tb, breakTime));
															#line 6254 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 855 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 6259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor2>
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor2State {
															#line 6265 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor2State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task)
															#line 6278 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor2State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 862 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, CopyLogRangeTaskFunc::name, CopyLogRangeTaskFunc::version);
															#line 862 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor2*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 6295 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor2*>(this)->actor_wait_state = 1;
															#line 862 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor2, 0, Void >*>(static_cast<_executeActor2*>(this)));
															#line 6300 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor2State();
		static_cast<_executeActor2*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 864 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyEndVersion], Unversioned());
															#line 869 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Version newEndVersion = std::min(endVersion, (((beginVersion - 1) / CLIENT_KNOBS->COPY_LOG_BLOCK_SIZE) + 1 + CLIENT_KNOBS->COPY_LOG_BLOCKS_PER_TASK + (g_network->isSimulated() ? CLIENT_KNOBS->BACKUP_SIM_COPY_LOG_RANGES : 0)) * CLIENT_KNOBS->COPY_LOG_BLOCK_SIZE);
															#line 875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		ranges = getLogRanges( beginVersion, newEndVersion, task->params[BackupAgentBase::destUid], CLIENT_KNOBS->COPY_LOG_BLOCK_SIZE);
															#line 877 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nRanges = ranges.size();
															#line 879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		results = std::vector<PromiseStream<RCGroup>>();
															#line 880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rc = std::vector<Future<Void>>();
															#line 881 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		locks = std::vector<Reference<FlowLock>>();
															#line 882 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextVersion = beginVersion;
															#line 883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		breakTime = timer_monotonic() + CLIENT_KNOBS->COPY_LOG_TASK_DURATION_NANOS;
															#line 884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeN = 0;
															#line 886 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 6345 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 864 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyEndVersion], Unversioned());
															#line 869 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Version newEndVersion = std::min(endVersion, (((beginVersion - 1) / CLIENT_KNOBS->COPY_LOG_BLOCK_SIZE) + 1 + CLIENT_KNOBS->COPY_LOG_BLOCKS_PER_TASK + (g_network->isSimulated() ? CLIENT_KNOBS->BACKUP_SIM_COPY_LOG_RANGES : 0)) * CLIENT_KNOBS->COPY_LOG_BLOCK_SIZE);
															#line 875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		ranges = getLogRanges( beginVersion, newEndVersion, task->params[BackupAgentBase::destUid], CLIENT_KNOBS->COPY_LOG_BLOCK_SIZE);
															#line 877 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nRanges = ranges.size();
															#line 879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		results = std::vector<PromiseStream<RCGroup>>();
															#line 880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rc = std::vector<Future<Void>>();
															#line 881 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		locks = std::vector<Reference<FlowLock>>();
															#line 882 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextVersion = beginVersion;
															#line 883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		breakTime = timer_monotonic() + CLIENT_KNOBS->COPY_LOG_TASK_DURATION_NANOS;
															#line 884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeN = 0;
															#line 886 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 6376 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor2*>(this)->actor_wait_state > 0) static_cast<_executeActor2*>(this)->actor_wait_state = 0;
		static_cast<_executeActor2*>(this)->ActorCallback< _executeActor2, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor2, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor2, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor2, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (nextVersion < endVersion)
															#line 6448 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 929 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			task->params[CopyLogRangeTaskFunc::keyNextBeginVersion] = BinaryWriter::toValue(nextVersion, Unversioned());
															#line 6452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 931 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor2*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor2State(); static_cast<_executeActor2*>(this)->destroy(); return 0; }
															#line 6456 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor2*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor2State();
		static_cast<_executeActor2*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 887 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (rangeN >= nRanges)
															#line 6475 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 891 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int prefetchTo = std::min(rangeN + CLIENT_KNOBS->COPY_LOG_PREFETCH_BLOCKS, nRanges);
															#line 893 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for(int j = results.size();j < prefetchTo;j++) {
															#line 894 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			results.push_back(PromiseStream<RCGroup>());
															#line 895 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			locks.push_back(makeReference<FlowLock>(CLIENT_KNOBS->COPY_LOG_READ_AHEAD_BYTES));
															#line 896 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rc.push_back(readCommitted(taskBucket->src, results[j], Future<Void>(Void()), locks[j], ranges[j], decodeBKMutationLogKey, Terminator::True, AccessSystemKeys::True, LockAware::True));
															#line 6489 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Version>> __when_expr_1 = dumpData(cx, task, results[rangeN], locks[rangeN].getPtr(), taskBucket, breakTime);
															#line 908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor2*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 6495 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_executeActor2*>(this)->actor_wait_state = 2;
															#line 908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor2, 1, Optional<Version> >*>(static_cast<_executeActor2*>(this)));
															#line 6500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(Optional<Version> const& nextVersionBr,int loopDepth) 
	{
															#line 912 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (nextVersionBr.present())
															#line 6522 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 913 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextVersion = nextVersionBr.get();
															#line 915 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent(SevInfo, "CopyLogRangeTaskFuncAborted") .detail("DurationNanos", CLIENT_KNOBS->COPY_LOG_TASK_DURATION_NANOS) .detail("RangeN", rangeN) .detail("BytesWritten", Params.bytesWritten().getOrDefault(task));
															#line 919 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(int j = results.size();--j >= rangeN;) {
															#line 920 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				rc[j].cancel();
															#line 6532 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
			return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 924 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextVersion = getLogKeyVersion(ranges[rangeN].end);
															#line 925 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeN++;
															#line 6540 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(Optional<Version> && nextVersionBr,int loopDepth) 
	{
															#line 912 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (nextVersionBr.present())
															#line 6549 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 913 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextVersion = nextVersionBr.get();
															#line 915 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent(SevInfo, "CopyLogRangeTaskFuncAborted") .detail("DurationNanos", CLIENT_KNOBS->COPY_LOG_TASK_DURATION_NANOS) .detail("RangeN", rangeN) .detail("BytesWritten", Params.bytesWritten().getOrDefault(task));
															#line 919 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(int j = results.size();--j >= rangeN;) {
															#line 920 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				rc[j].cancel();
															#line 6559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
			return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 924 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		nextVersion = getLogKeyVersion(ranges[rangeN].end);
															#line 925 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rangeN++;
															#line 6567 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Version> const& nextVersionBr,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(nextVersionBr, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Version> && nextVersionBr,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(std::move(nextVersionBr), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor2*>(this)->actor_wait_state > 0) static_cast<_executeActor2*>(this)->actor_wait_state = 0;
		static_cast<_executeActor2*>(this)->ActorCallback< _executeActor2, 1, Optional<Version> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor2, 1, Optional<Version> >*,Optional<Version> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor2, 1, Optional<Version> >*,Optional<Version> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor2, 1, Optional<Version> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 864 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> ranges;
															#line 877 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int nRanges;
															#line 879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<PromiseStream<RCGroup>> results;
															#line 880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<Future<Void>> rc;
															#line 881 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<Reference<FlowLock>> locks;
															#line 882 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version nextVersion;
															#line 883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	double breakTime;
															#line 884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int rangeN;
															#line 6663 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor2 final : public Actor<Void>, public ActorCallback< _executeActor2, 0, Void >, public ActorCallback< _executeActor2, 1, Optional<Version> >, public FastAllocated<_executeActor2>, public _executeActor2State<_executeActor2> {
															#line 6668 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor2>::operator new;
	using FastAllocated<_executeActor2>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor2, 0, Void >;
friend struct ActorCallback< _executeActor2, 1, Optional<Version> >;
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor2(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 6680 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor2State<_executeActor2>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor2, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor2, 1, Optional<Version> >*)0, actor_cancelled()); break;
		}

	}
};
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor2(cx, taskBucket, futureBucket, task));
															#line 6708 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 933 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 6713 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor3>
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor3State {
															#line 6719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor3State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& beginVersion,Version const& endVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   beginVersion(beginVersion),
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endVersion(endVersion),
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 6738 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor3State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 941 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 941 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 6755 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor3*>(this)->actor_wait_state = 1;
															#line 941 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor3, 0, Key >*>(static_cast<AddTaskActor3*>(this)));
															#line 6760 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor3State();
		static_cast<AddTaskActor3*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 942 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(CopyLogRangeTaskFunc::name, CopyLogRangeTaskFunc::version, doneKey, 1);
															#line 944 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 946 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyEndVersion] = BinaryWriter::toValue(endVersion, Unversioned());
															#line 949 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 6791 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor3*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor3State(); static_cast<AddTaskActor3*>(this)->destroy(); return 0; }
															#line 6795 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor3*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor3State();
			static_cast<AddTaskActor3*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 956 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 956 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 6805 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor3*>(this)->actor_wait_state = 2;
															#line 956 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor3, 1, Void >*>(static_cast<AddTaskActor3*>(this)));
															#line 6810 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 942 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(CopyLogRangeTaskFunc::name, CopyLogRangeTaskFunc::version, doneKey, 1);
															#line 944 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 946 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyEndVersion] = BinaryWriter::toValue(endVersion, Unversioned());
															#line 949 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 6827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor3*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor3State(); static_cast<AddTaskActor3*>(this)->destroy(); return 0; }
															#line 6831 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor3*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor3State();
			static_cast<AddTaskActor3*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 956 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 956 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 6841 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor3*>(this)->actor_wait_state = 2;
															#line 956 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor3, 1, Void >*>(static_cast<AddTaskActor3*>(this)));
															#line 6846 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor3*>(this)->actor_wait_state > 0) static_cast<AddTaskActor3*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor3*>(this)->ActorCallback< AddTaskActor3, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor3, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor3, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor3, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 961 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor3*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor3State(); static_cast<AddTaskActor3*>(this)->destroy(); return 0; }
															#line 6918 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor3*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor3State();
		static_cast<AddTaskActor3*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 961 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor3*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor3State(); static_cast<AddTaskActor3*>(this)->destroy(); return 0; }
															#line 6930 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor3*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor3State();
		static_cast<AddTaskActor3*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor3*>(this)->actor_wait_state > 0) static_cast<AddTaskActor3*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor3*>(this)->ActorCallback< AddTaskActor3, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor3, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor3, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor3, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 7015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor3 final : public Actor<Key>, public ActorCallback< AddTaskActor3, 0, Key >, public ActorCallback< AddTaskActor3, 1, Void >, public FastAllocated<AddTaskActor3>, public AddTaskActor3State<AddTaskActor3> {
															#line 7020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor3>::operator new;
	using FastAllocated<AddTaskActor3>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor3, 0, Key >;
friend struct ActorCallback< AddTaskActor3, 1, Void >;
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor3(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& beginVersion,Version const& endVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 7032 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor3State<AddTaskActor3>(tr, taskBucket, parentTask, beginVersion, endVersion, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor3, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor3, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, Version const& beginVersion, Version const& endVersion, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor3(tr, taskBucket, parentTask, beginVersion, endVersion, completionKey, waitFor));
															#line 7060 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 963 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 7065 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor3>
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor3State {
															#line 7071 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor3State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 969 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endVersion(BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyEndVersion], Unversioned())),
															#line 971 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskFuture(futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]))
															#line 7088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor3State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 975 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			DRConfig config(task);
															#line 976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int64_t bytesWritten = Params.bytesWritten().getOrDefault(task);
															#line 977 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			config.logBytesWritten().atomicOp(tr, bytesWritten, MutationRef::AddValue);
															#line 979 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (task->params.find(CopyLogRangeTaskFunc::keyNextBeginVersion) != task->params.end())
															#line 7109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				nextVersion = BinaryReader::fromStringRef<Version>( task->params[CopyLogRangeTaskFunc::keyNextBeginVersion], Unversioned());
															#line 982 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_0 = success(CopyLogRangeTaskFunc::addTask( tr, taskBucket, task, nextVersion, endVersion, TaskCompletionKey::signal(taskFuture->key))) && taskBucket->finish(tr, task);
															#line 982 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<_finishActor3*>(this)->actor_wait_state = 1;
															#line 982 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor3, 0, Void >*>(static_cast<_finishActor3*>(this)));
															#line 7122 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 986 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_1 = taskFuture->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 986 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7131 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
				static_cast<_finishActor3*>(this)->actor_wait_state = 2;
															#line 986 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor3, 1, Void >*>(static_cast<_finishActor3*>(this)));
															#line 7136 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor3State();
		static_cast<_finishActor3*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 989 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor3*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor3State(); static_cast<_finishActor3*>(this)->destroy(); return 0; }
															#line 7160 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor3*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor3State();
		static_cast<_finishActor3*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor3*>(this)->actor_wait_state > 0) static_cast<_finishActor3*>(this)->actor_wait_state = 0;
		static_cast<_finishActor3*>(this)->ActorCallback< _finishActor3, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor3, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor3, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor3, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor3*>(this)->actor_wait_state > 0) static_cast<_finishActor3*>(this)->actor_wait_state = 0;
		static_cast<_finishActor3*>(this)->ActorCallback< _finishActor3, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor3, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor3, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor3, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 969 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 971 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> taskFuture;
															#line 980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version nextVersion;
															#line 7332 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor3 final : public Actor<Void>, public ActorCallback< _finishActor3, 0, Void >, public ActorCallback< _finishActor3, 1, Void >, public FastAllocated<_finishActor3>, public _finishActor3State<_finishActor3> {
															#line 7337 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor3>::operator new;
	using FastAllocated<_finishActor3>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor3, 0, Void >;
friend struct ActorCallback< _finishActor3, 1, Void >;
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor3(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 7349 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor3State<_finishActor3>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor3, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor3, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor3(tr, taskBucket, futureBucket, task));
															#line 7377 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
};
StringRef CopyLogRangeTaskFunc::name = LiteralStringRef("dr_copy_log_range");
const Key CopyLogRangeTaskFunc::keyNextBeginVersion = LiteralStringRef("nextBeginVersion");
REGISTER_TASKFUNC(CopyLogRangeTaskFunc);

struct CopyLogsTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 7390 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor4>
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor4State {
															#line 7396 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor4State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   conf(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[BackupAgentBase::keyConfigLogUid])),
															#line 1007 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   states(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyStates) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 7413 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor4State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(tr, task, CopyLogsTaskFunc::name, CopyLogsTaskFunc::version);
															#line 1010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7430 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor4*>(this)->actor_wait_state = 1;
															#line 1010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 0, Void >*>(static_cast<_finishActor4*>(this)));
															#line 7435 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor4State();
		static_cast<_finishActor4*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1014 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		prevBeginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyPrevBeginVersion], Unversioned());
															#line 1016 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fStopValue = tr->get(states.pack(DatabaseBackupAgent::keyCopyStop));
															#line 1017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fAppliedValue = tr->get(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsBeginRange.begin));
															#line 1020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Transaction srcTr(taskBucket->src);
															#line 1021 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Version> __when_expr_1 = srcTr.getReadVersion();
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7472 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 2;
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 1, Version >*>(static_cast<_finishActor4*>(this)));
															#line 7477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1014 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		prevBeginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyPrevBeginVersion], Unversioned());
															#line 1016 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fStopValue = tr->get(states.pack(DatabaseBackupAgent::keyCopyStop));
															#line 1017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fAppliedValue = tr->get(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsBeginRange.begin));
															#line 1020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Transaction srcTr(taskBucket->src);
															#line 1021 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Version> __when_expr_1 = srcTr.getReadVersion();
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 2;
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 1, Version >*>(static_cast<_finishActor4*>(this)));
															#line 7505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor4, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 1024 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		onDone = futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]);
															#line 1026 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (endVersion <= beginVersion)
															#line 7579 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1027 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_2 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 1027 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<_finishActor4*>(this)->actor_wait_state = 3;
															#line 1027 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 2, Void >*>(static_cast<_finishActor4*>(this)));
															#line 7590 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1when1(Version const& __endVersion,int loopDepth) 
	{
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = __endVersion;
															#line 7604 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Version && __endVersion,int loopDepth) 
	{
		endVersion = std::move(__endVersion);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 1, Version >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 1, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 1, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor4, 1, Version >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1034 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_5 = fAppliedValue;
															#line 1034 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7673 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont3when1(__when_expr_5.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 6;
															#line 1034 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 5, Optional<Value> >*>(static_cast<_finishActor4*>(this)));
															#line 7678 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4(Void const& _,int loopDepth) 
	{
															#line 1028 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = success(CopyLogsTaskFunc::addTask( tr, taskBucket, task, prevBeginVersion, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1028 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 4;
															#line 1028 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 3, Void >*>(static_cast<_finishActor4*>(this)));
															#line 7694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4(Void && _,int loopDepth) 
	{
															#line 1028 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = success(CopyLogsTaskFunc::addTask( tr, taskBucket, task, prevBeginVersion, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1028 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 4;
															#line 1028 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 3, Void >*>(static_cast<_finishActor4*>(this)));
															#line 7710 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor4, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
															#line 1030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = taskBucket->finish(tr, task);
															#line 1030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7784 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont5when1(__when_expr_4.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 5;
															#line 1030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 4, Void >*>(static_cast<_finishActor4*>(this)));
															#line 7789 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
															#line 1030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = taskBucket->finish(tr, task);
															#line 1030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont5when1(__when_expr_4.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 5;
															#line 1030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 4, Void >*>(static_cast<_finishActor4*>(this)));
															#line 7805 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _finishActor4, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont6(Void const& _,int loopDepth) 
	{
															#line 1031 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor4*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor4State(); static_cast<_finishActor4*>(this)->destroy(); return 0; }
															#line 7877 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor4*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor4State();
		static_cast<_finishActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6(Void && _,int loopDepth) 
	{
															#line 1031 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor4*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor4State(); static_cast<_finishActor4*>(this)->destroy(); return 0; }
															#line 7889 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor4*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor4State();
		static_cast<_finishActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont5when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _finishActor4, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont8(Optional<Value> const& appliedValue,int loopDepth) 
	{
															#line 1035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		appliedVersion = appliedValue.present() ? BinaryReader::fromStringRef<Version>(appliedValue.get(), Unversioned()) : 100;
															#line 1038 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		applyVersion = std::max<Version>(appliedVersion, beginVersion - CLIENT_KNOBS->BACKUP_VERSION_DELAY);
															#line 1040 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Subspace krv = conf.get(DatabaseBackupAgent::keyRangeVersions);
															#line 1041 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		KeyRange versionRange = KeyRangeRef(krv.pack(0), krv.pack(applyVersion + 1));
															#line 1042 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->addReadConflictRange(versionRange);
															#line 1043 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->addWriteConflictRange(versionRange);
															#line 1044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsEndRange.begin), BinaryWriter::toValue(applyVersion, Unversioned()));
															#line 1047 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_6 = fStopValue;
															#line 1047 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 7980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont8when1(__when_expr_6.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 7;
															#line 1047 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 6, Optional<Value> >*>(static_cast<_finishActor4*>(this)));
															#line 7985 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont8(Optional<Value> && appliedValue,int loopDepth) 
	{
															#line 1035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		appliedVersion = appliedValue.present() ? BinaryReader::fromStringRef<Version>(appliedValue.get(), Unversioned()) : 100;
															#line 1038 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		applyVersion = std::max<Version>(appliedVersion, beginVersion - CLIENT_KNOBS->BACKUP_VERSION_DELAY);
															#line 1040 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Subspace krv = conf.get(DatabaseBackupAgent::keyRangeVersions);
															#line 1041 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		KeyRange versionRange = KeyRangeRef(krv.pack(0), krv.pack(applyVersion + 1));
															#line 1042 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->addReadConflictRange(versionRange);
															#line 1043 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->addWriteConflictRange(versionRange);
															#line 1044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsEndRange.begin), BinaryWriter::toValue(applyVersion, Unversioned()));
															#line 1047 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_6 = fStopValue;
															#line 1047 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont8when1(__when_expr_6.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 7;
															#line 1047 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 6, Optional<Value> >*>(static_cast<_finishActor4*>(this)));
															#line 8015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3when1(Optional<Value> const& appliedValue,int loopDepth) 
	{
		loopDepth = a_body1cont8(appliedValue, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Optional<Value> && appliedValue,int loopDepth) 
	{
		loopDepth = a_body1cont8(std::move(appliedValue), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 5, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 5, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 5, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< _finishActor4, 5, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont9(Optional<Value> const& stopValue,int loopDepth) 
	{
															#line 1048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		stopVersionData = stopValue.present() ? BinaryReader::fromStringRef<Version>(stopValue.get(), Unversioned()) : -1;
															#line 1051 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (endVersion - beginVersion > deterministicRandom()->randomInt64(0, CLIENT_KNOBS->BACKUP_VERSION_DELAY))
															#line 8089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1052 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_CopyLogs") .detail("BeginVersion", beginVersion) .detail("ApplyVersion", applyVersion) .detail("EndVersion", endVersion) .detail("StopVersionData", stopVersionData) .detail("LogUID", task->params[BackupAgentBase::keyConfigLogUid]);
															#line 8093 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1060 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if ((stopVersionData == -1) || (stopVersionData >= applyVersion))
															#line 8097 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1061 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			allPartsDone = futureBucket->future(tr);
															#line 1062 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			std::vector<Future<Key>> addTaskVector;
															#line 1063 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			addTaskVector.push_back(CopyLogsTaskFunc::addTask( tr, taskBucket, task, beginVersion, endVersion, TaskCompletionKey::signal(onDone), allPartsDone));
															#line 1065 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int blockSize = std::max<int>( 1, ((endVersion - beginVersion) / CLIENT_KNOBS->BACKUP_COPY_TASKS) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(int64_t vblock = beginVersion / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock < (endVersion + CLIENT_KNOBS->BACKUP_BLOCK_SIZE - 1) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock += blockSize) {
															#line 1070 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(CopyLogRangeTaskFunc::addTask( tr, taskBucket, task, std::max(beginVersion, vblock * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), std::min(endVersion, (vblock + blockSize) * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), TaskCompletionKey::joinWith(allPartsDone)));
															#line 8111 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1080 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (prevBeginVersion > 0)
															#line 8115 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1081 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(EraseLogRangeTaskFunc::addTask( tr, taskBucket, task, beginVersion, TaskCompletionKey::joinWith(allPartsDone)));
															#line 8119 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = waitForAll(addTaskVector) && taskBucket->finish(tr, task);
															#line 1085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8125 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont9when1(__when_expr_7.get(), loopDepth); };
			static_cast<_finishActor4*>(this)->actor_wait_state = 8;
															#line 1085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 7, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8130 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 1087 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (appliedVersion < applyVersion)
															#line 8137 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_8 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 1088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont9when2(__when_expr_8.get(), loopDepth); };
				static_cast<_finishActor4*>(this)->actor_wait_state = 9;
															#line 1088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 8, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8148 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont15(loopDepth);
			}
		}

		return loopDepth;
	}
	int a_body1cont9(Optional<Value> && stopValue,int loopDepth) 
	{
															#line 1048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		stopVersionData = stopValue.present() ? BinaryReader::fromStringRef<Version>(stopValue.get(), Unversioned()) : -1;
															#line 1051 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (endVersion - beginVersion > deterministicRandom()->randomInt64(0, CLIENT_KNOBS->BACKUP_VERSION_DELAY))
															#line 8165 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1052 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_CopyLogs") .detail("BeginVersion", beginVersion) .detail("ApplyVersion", applyVersion) .detail("EndVersion", endVersion) .detail("StopVersionData", stopVersionData) .detail("LogUID", task->params[BackupAgentBase::keyConfigLogUid]);
															#line 8169 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1060 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if ((stopVersionData == -1) || (stopVersionData >= applyVersion))
															#line 8173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1061 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			allPartsDone = futureBucket->future(tr);
															#line 1062 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			std::vector<Future<Key>> addTaskVector;
															#line 1063 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			addTaskVector.push_back(CopyLogsTaskFunc::addTask( tr, taskBucket, task, beginVersion, endVersion, TaskCompletionKey::signal(onDone), allPartsDone));
															#line 1065 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int blockSize = std::max<int>( 1, ((endVersion - beginVersion) / CLIENT_KNOBS->BACKUP_COPY_TASKS) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(int64_t vblock = beginVersion / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock < (endVersion + CLIENT_KNOBS->BACKUP_BLOCK_SIZE - 1) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock += blockSize) {
															#line 1070 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(CopyLogRangeTaskFunc::addTask( tr, taskBucket, task, std::max(beginVersion, vblock * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), std::min(endVersion, (vblock + blockSize) * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), TaskCompletionKey::joinWith(allPartsDone)));
															#line 8187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1080 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (prevBeginVersion > 0)
															#line 8191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1081 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(EraseLogRangeTaskFunc::addTask( tr, taskBucket, task, beginVersion, TaskCompletionKey::joinWith(allPartsDone)));
															#line 8195 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = waitForAll(addTaskVector) && taskBucket->finish(tr, task);
															#line 1085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont9when1(__when_expr_7.get(), loopDepth); };
			static_cast<_finishActor4*>(this)->actor_wait_state = 8;
															#line 1085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 7, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 1087 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (appliedVersion < applyVersion)
															#line 8213 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_8 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 1088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8219 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont9when2(__when_expr_8.get(), loopDepth); };
				static_cast<_finishActor4*>(this)->actor_wait_state = 9;
															#line 1088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 8, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont15(loopDepth);
			}
		}

		return loopDepth;
	}
	int a_body1cont8when1(Optional<Value> const& stopValue,int loopDepth) 
	{
		loopDepth = a_body1cont9(stopValue, loopDepth);

		return loopDepth;
	}
	int a_body1cont8when1(Optional<Value> && stopValue,int loopDepth) 
	{
		loopDepth = a_body1cont9(std::move(stopValue), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 6, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 6, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont8when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 6, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont8when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< _finishActor4, 6, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont10(int loopDepth) 
	{
															#line 1099 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor4*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor4State(); static_cast<_finishActor4*>(this)->destroy(); return 0; }
															#line 8302 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor4*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor4State();
		static_cast<_finishActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont12(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1cont12(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1cont9when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont12(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont9when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont12(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont9when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont9when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< _finishActor4, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1cont15(int loopDepth) 
	{
															#line 1095 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_11 = onDone->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 1095 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8391 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_11.isReady()) { if (__when_expr_11.isError()) return a_body1Catch1(__when_expr_11.getError(), loopDepth); else return a_body1cont15when1(__when_expr_11.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 12;
															#line 1095 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_11.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 11, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8396 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont16(Void const& _,int loopDepth) 
	{
															#line 1089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_9 = success(CopyLogsTaskFunc::addTask( tr, taskBucket, task, prevBeginVersion, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8407 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1Catch1(__when_expr_9.getError(), loopDepth); else return a_body1cont16when1(__when_expr_9.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 10;
															#line 1089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 9, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8412 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont16(Void && _,int loopDepth) 
	{
															#line 1089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_9 = success(CopyLogsTaskFunc::addTask( tr, taskBucket, task, prevBeginVersion, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8423 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1Catch1(__when_expr_9.getError(), loopDepth); else return a_body1cont16when1(__when_expr_9.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 10;
															#line 1089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 9, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8428 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont9when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont16(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont9when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont16(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 8, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 8, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont9when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 8, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont9when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< _finishActor4, 8, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 8);

	}
	int a_body1cont16cont1(Void const& _,int loopDepth) 
	{
															#line 1091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_10 = taskBucket->finish(tr, task);
															#line 1091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8502 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1cont16cont1when1(__when_expr_10.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 11;
															#line 1091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 10, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8507 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont16cont1(Void && _,int loopDepth) 
	{
															#line 1091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_10 = taskBucket->finish(tr, task);
															#line 1091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8518 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1cont16cont1when1(__when_expr_10.get(), loopDepth); };
		static_cast<_finishActor4*>(this)->actor_wait_state = 11;
															#line 1091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< _finishActor4, 10, Void >*>(static_cast<_finishActor4*>(this)));
															#line 8523 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont16when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont16when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose10() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 9, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 9, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont16when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 9, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont16when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_error(ActorCallback< _finishActor4, 9, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 9);

	}
	int a_body1cont16cont2(Void const& _,int loopDepth) 
	{
															#line 1092 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor4*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor4State(); static_cast<_finishActor4*>(this)->destroy(); return 0; }
															#line 8595 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor4*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor4State();
		static_cast<_finishActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont16cont2(Void && _,int loopDepth) 
	{
															#line 1092 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor4*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor4State(); static_cast<_finishActor4*>(this)->destroy(); return 0; }
															#line 8607 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor4*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor4State();
		static_cast<_finishActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont16cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont16cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose11() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 10, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 10, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont16cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 10, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont16cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_error(ActorCallback< _finishActor4, 10, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 10);

	}
	int a_body1cont15cont1(Void const& _,int loopDepth) 
	{
															#line 1096 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(states.pack(DatabaseBackupAgent::keyStateStop), BinaryWriter::toValue(beginVersion, Unversioned()));
															#line 8682 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1cont15cont1(Void && _,int loopDepth) 
	{
															#line 1096 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(states.pack(DatabaseBackupAgent::keyStateStop), BinaryWriter::toValue(beginVersion, Unversioned()));
															#line 8691 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont10(loopDepth);

		return loopDepth;
	}
	int a_body1cont15when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont15cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont15when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont15cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose12() 
	{
		if (static_cast<_finishActor4*>(this)->actor_wait_state > 0) static_cast<_finishActor4*>(this)->actor_wait_state = 0;
		static_cast<_finishActor4*>(this)->ActorCallback< _finishActor4, 11, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor4, 11, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont15when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_fire(ActorCallback< _finishActor4, 11, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont15when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_error(ActorCallback< _finishActor4, 11, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 11);

	}
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace conf;
															#line 1007 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace states;
															#line 1012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 1014 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version prevBeginVersion;
															#line 1016 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> fStopValue;
															#line 1017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> fAppliedValue;
															#line 1022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 1024 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> onDone;
															#line 1035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version appliedVersion;
															#line 1038 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version applyVersion;
															#line 1048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version stopVersionData;
															#line 1061 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> allPartsDone;
															#line 8791 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor4 final : public Actor<Void>, public ActorCallback< _finishActor4, 0, Void >, public ActorCallback< _finishActor4, 1, Version >, public ActorCallback< _finishActor4, 2, Void >, public ActorCallback< _finishActor4, 3, Void >, public ActorCallback< _finishActor4, 4, Void >, public ActorCallback< _finishActor4, 5, Optional<Value> >, public ActorCallback< _finishActor4, 6, Optional<Value> >, public ActorCallback< _finishActor4, 7, Void >, public ActorCallback< _finishActor4, 8, Void >, public ActorCallback< _finishActor4, 9, Void >, public ActorCallback< _finishActor4, 10, Void >, public ActorCallback< _finishActor4, 11, Void >, public FastAllocated<_finishActor4>, public _finishActor4State<_finishActor4> {
															#line 8796 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor4>::operator new;
	using FastAllocated<_finishActor4>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor4, 0, Void >;
friend struct ActorCallback< _finishActor4, 1, Version >;
friend struct ActorCallback< _finishActor4, 2, Void >;
friend struct ActorCallback< _finishActor4, 3, Void >;
friend struct ActorCallback< _finishActor4, 4, Void >;
friend struct ActorCallback< _finishActor4, 5, Optional<Value> >;
friend struct ActorCallback< _finishActor4, 6, Optional<Value> >;
friend struct ActorCallback< _finishActor4, 7, Void >;
friend struct ActorCallback< _finishActor4, 8, Void >;
friend struct ActorCallback< _finishActor4, 9, Void >;
friend struct ActorCallback< _finishActor4, 10, Void >;
friend struct ActorCallback< _finishActor4, 11, Void >;
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor4(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 8818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor4State<_finishActor4>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor4, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor4, 1, Version >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor4, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _finishActor4, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _finishActor4, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< _finishActor4, 5, Optional<Value> >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< _finishActor4, 6, Optional<Value> >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< _finishActor4, 7, Void >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< _finishActor4, 8, Void >*)0, actor_cancelled()); break;
		case 10: this->a_callback_error((ActorCallback< _finishActor4, 9, Void >*)0, actor_cancelled()); break;
		case 11: this->a_callback_error((ActorCallback< _finishActor4, 10, Void >*)0, actor_cancelled()); break;
		case 12: this->a_callback_error((ActorCallback< _finishActor4, 11, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor4(tr, taskBucket, futureBucket, task));
															#line 8856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1101 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 8861 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor4>
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor4State {
															#line 8867 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor4State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& prevBeginVersion,Version const& beginVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   prevBeginVersion(prevBeginVersion),
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   beginVersion(beginVersion),
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 8886 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor4State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 1109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8903 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor4*>(this)->actor_wait_state = 1;
															#line 1109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor4, 0, Key >*>(static_cast<AddTaskActor4*>(this)));
															#line 8908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor4State();
		static_cast<AddTaskActor4*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 1110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(CopyLogsTaskFunc::name, CopyLogsTaskFunc::version, doneKey, 1);
															#line 1112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 1114 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyPrevBeginVersion] = BinaryWriter::toValue(prevBeginVersion, Unversioned());
															#line 1116 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 8939 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor4*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor4State(); static_cast<AddTaskActor4*>(this)->destroy(); return 0; }
															#line 8943 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor4*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor4State();
			static_cast<AddTaskActor4*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8953 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor4*>(this)->actor_wait_state = 2;
															#line 1123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor4, 1, Void >*>(static_cast<AddTaskActor4*>(this)));
															#line 8958 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 1110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(CopyLogsTaskFunc::name, CopyLogsTaskFunc::version, doneKey, 1);
															#line 1112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 1114 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyPrevBeginVersion] = BinaryWriter::toValue(prevBeginVersion, Unversioned());
															#line 1116 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 8975 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor4*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor4State(); static_cast<AddTaskActor4*>(this)->destroy(); return 0; }
															#line 8979 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor4*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor4State();
			static_cast<AddTaskActor4*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 8989 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor4*>(this)->actor_wait_state = 2;
															#line 1123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor4, 1, Void >*>(static_cast<AddTaskActor4*>(this)));
															#line 8994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor4*>(this)->actor_wait_state > 0) static_cast<AddTaskActor4*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor4*>(this)->ActorCallback< AddTaskActor4, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor4, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor4, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor4, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1128 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor4*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor4State(); static_cast<AddTaskActor4*>(this)->destroy(); return 0; }
															#line 9066 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor4*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor4State();
		static_cast<AddTaskActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1128 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor4*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor4State(); static_cast<AddTaskActor4*>(this)->destroy(); return 0; }
															#line 9078 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor4*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor4State();
		static_cast<AddTaskActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor4*>(this)->actor_wait_state > 0) static_cast<AddTaskActor4*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor4*>(this)->ActorCallback< AddTaskActor4, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor4, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor4, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor4, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version prevBeginVersion;
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 9163 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor4 final : public Actor<Key>, public ActorCallback< AddTaskActor4, 0, Key >, public ActorCallback< AddTaskActor4, 1, Void >, public FastAllocated<AddTaskActor4>, public AddTaskActor4State<AddTaskActor4> {
															#line 9168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor4>::operator new;
	using FastAllocated<AddTaskActor4>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor4, 0, Key >;
friend struct ActorCallback< AddTaskActor4, 1, Void >;
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor4(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& prevBeginVersion,Version const& beginVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 9180 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor4State<AddTaskActor4>(tr, taskBucket, parentTask, prevBeginVersion, beginVersion, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor4, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor4, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, Version const& prevBeginVersion, Version const& beginVersion, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 1102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor4(tr, taskBucket, parentTask, prevBeginVersion, beginVersion, completionKey, waitFor));
															#line 9208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1130 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return Void();
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef CopyLogsTaskFunc::name = LiteralStringRef("dr_copy_logs");
REGISTER_TASKFUNC(CopyLogsTaskFunc);

struct FinishedFullBackupTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;
	static const Key keyInsertTask;

	StringRef getName() const override { return name; };

																#line 9238 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor3>
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor3State {
															#line 9244 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor3State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1160 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   sourceStates(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keySourceStates) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 9259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor3State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1164 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, FinishedFullBackupTaskFunc::name, FinishedFullBackupTaskFunc::version);
															#line 1164 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 9276 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor3*>(this)->actor_wait_state = 1;
															#line 1164 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 0, Void >*>(static_cast<_executeActor3*>(this)));
															#line 9281 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor3State();
		static_cast<_executeActor3*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1166 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr2 = Transaction(cx);
															#line 1167 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 9306 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1166 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr2 = Transaction(cx);
															#line 1167 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 9317 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor3, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 1191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 1192 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUidValue = task->params[DatabaseBackupAgent::keyConfigLogUid];
															#line 1193 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destUidValue = task->params[BackupAgentBase::destUid];
															#line 1194 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupUid = BinaryReader::fromStringRef<Version>(task->params[BackupAgentBase::keyFolderId], Unversioned());
															#line 1197 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 9397 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
		try {
															#line 1169 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr2.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1170 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_1 = tr2.get(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsBeginRange.begin));
															#line 1170 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9418 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<_executeActor3*>(this)->actor_wait_state = 2;
															#line 1170 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 1, Optional<Value> >*>(static_cast<_executeActor3*>(this)));
															#line 9423 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = tr2.onError(e);
															#line 1187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 9460 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<_executeActor3*>(this)->actor_wait_state = 5;
															#line 1187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 4, Void >*>(static_cast<_executeActor3*>(this)));
															#line 9465 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Optional<Value> const& beginValue,int loopDepth) 
	{
															#line 1172 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		appliedVersion = beginValue.present() ? BinaryReader::fromStringRef<Version>(beginValue.get(), Unversioned()) : -1;
															#line 1174 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_2 = tr2.get(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsEndRange.begin));
															#line 1174 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9484 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor3*>(this)->actor_wait_state = 3;
															#line 1174 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 2, Optional<Value> >*>(static_cast<_executeActor3*>(this)));
															#line 9489 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Optional<Value> && beginValue,int loopDepth) 
	{
															#line 1172 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		appliedVersion = beginValue.present() ? BinaryReader::fromStringRef<Version>(beginValue.get(), Unversioned()) : -1;
															#line 1174 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_2 = tr2.get(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsEndRange.begin));
															#line 1174 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9502 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor3*>(this)->actor_wait_state = 3;
															#line 1174 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 2, Optional<Value> >*>(static_cast<_executeActor3*>(this)));
															#line 9507 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Value> const& beginValue,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(beginValue, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Value> && beginValue,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(std::move(beginValue), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 1, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 1, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 1, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor3, 1, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont3(Optional<Value> const& endValue,int loopDepth) 
	{
															#line 1176 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Version endVersion = endValue.present() ? BinaryReader::fromStringRef<Version>(endValue.get(), Unversioned()) : -1;
															#line 1180 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (appliedVersion < endVersion)
															#line 9581 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 1181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9587 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
			static_cast<_executeActor3*>(this)->actor_wait_state = 4;
															#line 1181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 3, Void >*>(static_cast<_executeActor3*>(this)));
															#line 9592 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont1loopBody1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(Optional<Value> && endValue,int loopDepth) 
	{
															#line 1176 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Version endVersion = endValue.present() ? BinaryReader::fromStringRef<Version>(endValue.get(), Unversioned()) : -1;
															#line 1180 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (appliedVersion < endVersion)
															#line 9608 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 1181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9614 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
			static_cast<_executeActor3*>(this)->actor_wait_state = 4;
															#line 1181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 3, Void >*>(static_cast<_executeActor3*>(this)));
															#line 9619 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont1loopBody1cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Optional<Value> const& endValue,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(endValue, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Optional<Value> && endValue,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(endValue), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 2, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 2, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 2, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _executeActor3, 2, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1cont4(int loopDepth) 
	{
		return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont5(Void const& _,int loopDepth) 
	{
															#line 1182 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[FinishedFullBackupTaskFunc::keyInsertTask] = StringRef();
															#line 1183 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor3*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor3State(); static_cast<_executeActor3*>(this)->destroy(); return 0; }
															#line 9704 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor3*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor3State();
		static_cast<_executeActor3*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont5(Void && _,int loopDepth) 
	{
															#line 1182 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[FinishedFullBackupTaskFunc::keyInsertTask] = StringRef();
															#line 1183 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor3*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor3State(); static_cast<_executeActor3*>(this)->destroy(); return 0; }
															#line 9718 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor3*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor3State();
		static_cast<_executeActor3*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _executeActor3, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _executeActor3, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1(int loopDepth) 
	{
		try {
															#line 1199 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 1200 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_5 = tr->get(sourceStates.pack(DatabaseBackupAgent::keyFolderId));
															#line 1201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9882 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont2loopBody1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont2loopBody1when1(__when_expr_5.get(), loopDepth); };
			static_cast<_executeActor3*>(this)->actor_wait_state = 6;
															#line 1201 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 5, Optional<Value> >*>(static_cast<_executeActor3*>(this)));
															#line 9887 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont2loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont2loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1211 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_8 = tr->onError(e);
															#line 1211 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 9911 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1Catch1(__when_expr_8.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1Catch1when1(__when_expr_8.get(), loopDepth); };
			static_cast<_executeActor3*>(this)->actor_wait_state = 9;
															#line 1211 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 8, Void >*>(static_cast<_executeActor3*>(this)));
															#line 9916 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2(Optional<Value> const& v,int loopDepth) 
	{
															#line 1202 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present() && BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) > BinaryReader::fromStringRef<Version>( task->params[DatabaseBackupAgent::keyFolderId], Unversioned()))
															#line 9931 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1205 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor3*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor3State(); static_cast<_executeActor3*>(this)->destroy(); return 0; }
															#line 9935 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor3*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor3State();
			static_cast<_executeActor3*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = eraseLogData(tr, logUidValue, destUidValue, Optional<Version>(), CheckBackupUID::True, backupUid);
															#line 1207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9945 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont2loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_6.get(), loopDepth); };
		static_cast<_executeActor3*>(this)->actor_wait_state = 7;
															#line 1207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 6, Void >*>(static_cast<_executeActor3*>(this)));
															#line 9950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2(Optional<Value> && v,int loopDepth) 
	{
															#line 1202 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present() && BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) > BinaryReader::fromStringRef<Version>( task->params[DatabaseBackupAgent::keyFolderId], Unversioned()))
															#line 9959 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1205 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor3*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor3State(); static_cast<_executeActor3*>(this)->destroy(); return 0; }
															#line 9963 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor3*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor3State();
			static_cast<_executeActor3*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = eraseLogData(tr, logUidValue, destUidValue, Optional<Version>(), CheckBackupUID::True, backupUid);
															#line 1207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 9973 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont2loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_6.get(), loopDepth); };
		static_cast<_executeActor3*>(this)->actor_wait_state = 7;
															#line 1207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 6, Void >*>(static_cast<_executeActor3*>(this)));
															#line 9978 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Optional<Value> const& v,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(v, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Optional<Value> && v,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 5, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 5, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 5, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< _executeActor3, 5, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont2loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 1208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_7 = tr->commit();
															#line 1208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 10052 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1cont2loopBody1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont2loopBody1cont3when1(__when_expr_7.get(), loopDepth); };
		static_cast<_executeActor3*>(this)->actor_wait_state = 8;
															#line 1208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 7, Void >*>(static_cast<_executeActor3*>(this)));
															#line 10057 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 1208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_7 = tr->commit();
															#line 1208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor3*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 10068 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1cont2loopBody1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont2loopBody1cont3when1(__when_expr_7.get(), loopDepth); };
		static_cast<_executeActor3*>(this)->actor_wait_state = 8;
															#line 1208 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _executeActor3, 7, Void >*>(static_cast<_executeActor3*>(this)));
															#line 10073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< _executeActor3, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont2loopBody1cont5(Void const& _,int loopDepth) 
	{
															#line 1209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor3*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor3State(); static_cast<_executeActor3*>(this)->destroy(); return 0; }
															#line 10145 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor3*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor3State();
		static_cast<_executeActor3*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont5(Void && _,int loopDepth) 
	{
															#line 1209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor3*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor3State(); static_cast<_executeActor3*>(this)->destroy(); return 0; }
															#line 10157 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor3*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor3State();
		static_cast<_executeActor3*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< _executeActor3, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1cont2loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<_executeActor3*>(this)->actor_wait_state > 0) static_cast<_executeActor3*>(this)->actor_wait_state = 0;
		static_cast<_executeActor3*>(this)->ActorCallback< _executeActor3, 8, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor3, 8, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< _executeActor3, 8, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< _executeActor3, 8, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1160 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace sourceStates;
															#line 1166 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Transaction tr2;
															#line 1172 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version appliedVersion;
															#line 1191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1192 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUidValue;
															#line 1193 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key destUidValue;
															#line 1194 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version backupUid;
															#line 10325 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor3 final : public Actor<Void>, public ActorCallback< _executeActor3, 0, Void >, public ActorCallback< _executeActor3, 1, Optional<Value> >, public ActorCallback< _executeActor3, 2, Optional<Value> >, public ActorCallback< _executeActor3, 3, Void >, public ActorCallback< _executeActor3, 4, Void >, public ActorCallback< _executeActor3, 5, Optional<Value> >, public ActorCallback< _executeActor3, 6, Void >, public ActorCallback< _executeActor3, 7, Void >, public ActorCallback< _executeActor3, 8, Void >, public FastAllocated<_executeActor3>, public _executeActor3State<_executeActor3> {
															#line 10330 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor3>::operator new;
	using FastAllocated<_executeActor3>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor3, 0, Void >;
friend struct ActorCallback< _executeActor3, 1, Optional<Value> >;
friend struct ActorCallback< _executeActor3, 2, Optional<Value> >;
friend struct ActorCallback< _executeActor3, 3, Void >;
friend struct ActorCallback< _executeActor3, 4, Void >;
friend struct ActorCallback< _executeActor3, 5, Optional<Value> >;
friend struct ActorCallback< _executeActor3, 6, Void >;
friend struct ActorCallback< _executeActor3, 7, Void >;
friend struct ActorCallback< _executeActor3, 8, Void >;
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor3(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 10349 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor3State<_executeActor3>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor3, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor3, 1, Optional<Value> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _executeActor3, 2, Optional<Value> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _executeActor3, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _executeActor3, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< _executeActor3, 5, Optional<Value> >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< _executeActor3, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< _executeActor3, 7, Void >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< _executeActor3, 8, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1156 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor3(cx, taskBucket, futureBucket, task));
															#line 10384 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1215 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 10389 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor5>
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor5State {
															#line 10395 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor5State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 10410 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor5State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1221 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 1221 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10427 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor5*>(this)->actor_wait_state = 1;
															#line 1221 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor5, 0, Key >*>(static_cast<AddTaskActor5*>(this)));
															#line 10432 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor5State();
		static_cast<AddTaskActor5*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 1222 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(FinishedFullBackupTaskFunc::name, FinishedFullBackupTaskFunc::version, doneKey);
															#line 1224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1226 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 10459 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor5*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor5State(); static_cast<AddTaskActor5*>(this)->destroy(); return 0; }
															#line 10463 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor5*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor5State();
			static_cast<AddTaskActor5*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10473 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor5*>(this)->actor_wait_state = 2;
															#line 1233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor5, 1, Void >*>(static_cast<AddTaskActor5*>(this)));
															#line 10478 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 1222 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(FinishedFullBackupTaskFunc::name, FinishedFullBackupTaskFunc::version, doneKey);
															#line 1224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1226 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 10491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor5*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor5State(); static_cast<AddTaskActor5*>(this)->destroy(); return 0; }
															#line 10495 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor5*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor5State();
			static_cast<AddTaskActor5*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor5*>(this)->actor_wait_state = 2;
															#line 1233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor5, 1, Void >*>(static_cast<AddTaskActor5*>(this)));
															#line 10510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor5*>(this)->actor_wait_state > 0) static_cast<AddTaskActor5*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor5*>(this)->ActorCallback< AddTaskActor5, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor5, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor5, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor5, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1238 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor5*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor5State(); static_cast<AddTaskActor5*>(this)->destroy(); return 0; }
															#line 10582 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor5*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor5State();
		static_cast<AddTaskActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1238 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor5*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor5State(); static_cast<AddTaskActor5*>(this)->destroy(); return 0; }
															#line 10594 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor5*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor5State();
		static_cast<AddTaskActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor5*>(this)->actor_wait_state > 0) static_cast<AddTaskActor5*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor5*>(this)->ActorCallback< AddTaskActor5, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor5, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor5, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor5, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 10675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor5 final : public Actor<Key>, public ActorCallback< AddTaskActor5, 0, Key >, public ActorCallback< AddTaskActor5, 1, Void >, public FastAllocated<AddTaskActor5>, public AddTaskActor5State<AddTaskActor5> {
															#line 10680 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor5>::operator new;
	using FastAllocated<AddTaskActor5>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor5, 0, Key >;
friend struct ActorCallback< AddTaskActor5, 1, Void >;
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor5(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 10692 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor5State<AddTaskActor5>(tr, taskBucket, parentTask, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor5, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor5, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 1216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor5(tr, taskBucket, parentTask, completionKey, waitFor));
															#line 10720 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1240 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 10725 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor5>
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor5State {
															#line 10731 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor5State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1245 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   conf(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[BackupAgentBase::keyConfigLogUid])),
															#line 1248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   states(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyStates) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 10748 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor5State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1252 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (task->params.find(FinishedFullBackupTaskFunc::keyInsertTask) != task->params.end())
															#line 10763 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1253 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				onDone = futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]);
															#line 1254 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_0 = success(FinishedFullBackupTaskFunc::addTask(tr, taskBucket, task, TaskCompletionKey::signal(onDone)));
															#line 1254 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10771 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<_finishActor5*>(this)->actor_wait_state = 1;
															#line 1254 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor5, 0, Void >*>(static_cast<_finishActor5*>(this)));
															#line 10776 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont1(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor5State();
		static_cast<_finishActor5*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 1259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::COMMIT_ON_FIRST_PROXY);
															#line 1260 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		UID logUid = BinaryReader::fromStringRef<UID>(task->params[DatabaseBackupAgent::keyConfigLogUid], Unversioned());
															#line 1262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Key logsPath = uidPrefixKey(applyLogKeys.begin, logUid);
															#line 1263 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(KeyRangeRef(logsPath, strinc(logsPath)));
															#line 1265 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(conf.range());
															#line 1266 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(states.pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_COMPLETED)));
															#line 1269 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = taskBucket->finish(tr, task);
															#line 1269 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when1(__when_expr_2.get(), loopDepth); };
		static_cast<_finishActor5*>(this)->actor_wait_state = 3;
															#line 1269 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor5, 2, Void >*>(static_cast<_finishActor5*>(this)));
															#line 10823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = taskBucket->finish(tr, task);
															#line 1255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10834 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor5*>(this)->actor_wait_state = 2;
															#line 1255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor5, 1, Void >*>(static_cast<_finishActor5*>(this)));
															#line 10839 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = taskBucket->finish(tr, task);
															#line 1255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 10850 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor5*>(this)->actor_wait_state = 2;
															#line 1255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor5, 1, Void >*>(static_cast<_finishActor5*>(this)));
															#line 10855 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor5*>(this)->actor_wait_state > 0) static_cast<_finishActor5*>(this)->actor_wait_state = 0;
		static_cast<_finishActor5*>(this)->ActorCallback< _finishActor5, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor5, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor5, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor5, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
															#line 1256 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor5State(); static_cast<_finishActor5*>(this)->destroy(); return 0; }
															#line 10927 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor5*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor5State();
		static_cast<_finishActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
															#line 1256 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor5State(); static_cast<_finishActor5*>(this)->destroy(); return 0; }
															#line 10939 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor5*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor5State();
		static_cast<_finishActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor5*>(this)->actor_wait_state > 0) static_cast<_finishActor5*>(this)->actor_wait_state = 0;
		static_cast<_finishActor5*>(this)->ActorCallback< _finishActor5, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor5, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor5, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor5, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
															#line 1270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor5State(); static_cast<_finishActor5*>(this)->destroy(); return 0; }
															#line 11014 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor5*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor5State();
		static_cast<_finishActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
															#line 1270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor5State(); static_cast<_finishActor5*>(this)->destroy(); return 0; }
															#line 11026 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor5*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor5State();
		static_cast<_finishActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor5*>(this)->actor_wait_state > 0) static_cast<_finishActor5*>(this)->actor_wait_state = 0;
		static_cast<_finishActor5*>(this)->ActorCallback< _finishActor5, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor5, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor5, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor5, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1245 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace conf;
															#line 1248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace states;
															#line 1253 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> onDone;
															#line 11111 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor5 final : public Actor<Void>, public ActorCallback< _finishActor5, 0, Void >, public ActorCallback< _finishActor5, 1, Void >, public ActorCallback< _finishActor5, 2, Void >, public FastAllocated<_finishActor5>, public _finishActor5State<_finishActor5> {
															#line 11116 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor5>::operator new;
	using FastAllocated<_finishActor5>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor5, 0, Void >;
friend struct ActorCallback< _finishActor5, 1, Void >;
friend struct ActorCallback< _finishActor5, 2, Void >;
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor5(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 11129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor5State<_finishActor5>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor5, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor5, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor5, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor5(tr, taskBucket, futureBucket, task));
															#line 11158 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1272 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef FinishedFullBackupTaskFunc::name = LiteralStringRef("dr_finished_full_backup");
const Key FinishedFullBackupTaskFunc::keyInsertTask = LiteralStringRef("insertTask");
REGISTER_TASKFUNC(FinishedFullBackupTaskFunc);

struct CopyDiffLogsTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 11184 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor6>
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor6State {
															#line 11190 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor6State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1298 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   conf(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[BackupAgentBase::keyConfigLogUid])),
															#line 1301 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   states(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyStates) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 11207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor6State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1304 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(tr, task, CopyDiffLogsTaskFunc::name, CopyDiffLogsTaskFunc::version);
															#line 1304 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor6*>(this)->actor_wait_state = 1;
															#line 1304 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 0, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor6State();
		static_cast<_finishActor6*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1306 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1308 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		prevBeginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyPrevBeginVersion], Unversioned());
															#line 1310 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fStopWhenDone = tr->get(conf.pack(DatabaseBackupAgent::keyConfigStopWhenDoneKey));
															#line 1312 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Transaction srcTr(taskBucket->src);
															#line 1313 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Version> __when_expr_1 = srcTr.getReadVersion();
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11264 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor6*>(this)->actor_wait_state = 2;
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 1, Version >*>(static_cast<_finishActor6*>(this)));
															#line 11269 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1306 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1308 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		prevBeginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyPrevBeginVersion], Unversioned());
															#line 1310 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fStopWhenDone = tr->get(conf.pack(DatabaseBackupAgent::keyConfigStopWhenDoneKey));
															#line 1312 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Transaction srcTr(taskBucket->src);
															#line 1313 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Version> __when_expr_1 = srcTr.getReadVersion();
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11290 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor6*>(this)->actor_wait_state = 2;
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 1, Version >*>(static_cast<_finishActor6*>(this)));
															#line 11295 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor6, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 1316 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		onDone = futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]);
															#line 1318 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (endVersion <= beginVersion)
															#line 11369 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1319 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_2 = delay(FLOW_KNOBS->PREVENT_FAST_SPIN_DELAY);
															#line 1319 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11375 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<_finishActor6*>(this)->actor_wait_state = 3;
															#line 1319 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 2, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11380 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1when1(Version const& __endVersion,int loopDepth) 
	{
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = __endVersion;
															#line 11394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Version && __endVersion,int loopDepth) 
	{
		endVersion = std::move(__endVersion);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 1, Version >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 1, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 1, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor6, 1, Version >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1326 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(task->params[BackupAgentBase::keyConfigLogUid].withPrefix(applyMutationsEndRange.begin), BinaryWriter::toValue(beginVersion, Unversioned()));
															#line 1328 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_5 = fStopWhenDone;
															#line 1328 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11465 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont3when1(__when_expr_5.get(), loopDepth); };
		static_cast<_finishActor6*>(this)->actor_wait_state = 6;
															#line 1328 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 5, Optional<Value> >*>(static_cast<_finishActor6*>(this)));
															#line 11470 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4(Void const& _,int loopDepth) 
	{
															#line 1320 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = success(CopyDiffLogsTaskFunc::addTask( tr, taskBucket, task, prevBeginVersion, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1320 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11481 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<_finishActor6*>(this)->actor_wait_state = 4;
															#line 1320 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 3, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11486 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4(Void && _,int loopDepth) 
	{
															#line 1320 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = success(CopyDiffLogsTaskFunc::addTask( tr, taskBucket, task, prevBeginVersion, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1320 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11497 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<_finishActor6*>(this)->actor_wait_state = 4;
															#line 1320 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 3, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11502 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor6, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
															#line 1322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = taskBucket->finish(tr, task);
															#line 1322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11576 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont5when1(__when_expr_4.get(), loopDepth); };
		static_cast<_finishActor6*>(this)->actor_wait_state = 5;
															#line 1322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 4, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11581 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
															#line 1322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = taskBucket->finish(tr, task);
															#line 1322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11592 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont5when1(__when_expr_4.get(), loopDepth); };
		static_cast<_finishActor6*>(this)->actor_wait_state = 5;
															#line 1322 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 4, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11597 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _finishActor6, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont6(Void const& _,int loopDepth) 
	{
															#line 1323 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor6State(); static_cast<_finishActor6*>(this)->destroy(); return 0; }
															#line 11669 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor6*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor6State();
		static_cast<_finishActor6*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6(Void && _,int loopDepth) 
	{
															#line 1323 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor6State(); static_cast<_finishActor6*>(this)->destroy(); return 0; }
															#line 11681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor6*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor6State();
		static_cast<_finishActor6*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont5when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _finishActor6, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont8(Optional<Value> const& stopWhenDone,int loopDepth) 
	{
															#line 1330 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (endVersion - beginVersion > deterministicRandom()->randomInt64(0, CLIENT_KNOBS->BACKUP_VERSION_DELAY))
															#line 11756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1331 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_CopyDiffLogs") .detail("BeginVersion", beginVersion) .detail("EndVersion", endVersion) .detail("LogUID", task->params[BackupAgentBase::keyConfigLogUid]);
															#line 11760 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1338 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(StringRef(states.pack(DatabaseBackupAgent::keyStateLogBeginVersion)), BinaryWriter::toValue(beginVersion, Unversioned()));
															#line 1341 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!stopWhenDone.present())
															#line 11766 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1342 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			allPartsDone = futureBucket->future(tr);
															#line 1343 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			std::vector<Future<Key>> addTaskVector;
															#line 1344 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			addTaskVector.push_back(CopyDiffLogsTaskFunc::addTask( tr, taskBucket, task, beginVersion, endVersion, TaskCompletionKey::signal(onDone), allPartsDone));
															#line 1346 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int blockSize = std::max<int>( 1, ((endVersion - beginVersion) / CLIENT_KNOBS->BACKUP_COPY_TASKS) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1348 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(int64_t vblock = beginVersion / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock < (endVersion + CLIENT_KNOBS->BACKUP_BLOCK_SIZE - 1) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock += blockSize) {
															#line 1351 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(CopyLogRangeTaskFunc::addTask( tr, taskBucket, task, std::max(beginVersion, vblock * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), std::min(endVersion, (vblock + blockSize) * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), TaskCompletionKey::joinWith(allPartsDone)));
															#line 11780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1360 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (prevBeginVersion > 0)
															#line 11784 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1361 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(EraseLogRangeTaskFunc::addTask( tr, taskBucket, task, beginVersion, TaskCompletionKey::joinWith(allPartsDone)));
															#line 11788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_6 = waitForAll(addTaskVector) && taskBucket->finish(tr, task);
															#line 1365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11794 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont8when1(__when_expr_6.get(), loopDepth); };
			static_cast<_finishActor6*>(this)->actor_wait_state = 7;
															#line 1365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 6, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11799 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 1367 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = onDone->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 1367 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11808 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont8when2(__when_expr_7.get(), loopDepth); };
			static_cast<_finishActor6*>(this)->actor_wait_state = 8;
															#line 1367 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 7, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11813 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont8(Optional<Value> && stopWhenDone,int loopDepth) 
	{
															#line 1330 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (endVersion - beginVersion > deterministicRandom()->randomInt64(0, CLIENT_KNOBS->BACKUP_VERSION_DELAY))
															#line 11823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1331 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_CopyDiffLogs") .detail("BeginVersion", beginVersion) .detail("EndVersion", endVersion) .detail("LogUID", task->params[BackupAgentBase::keyConfigLogUid]);
															#line 11827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1338 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(StringRef(states.pack(DatabaseBackupAgent::keyStateLogBeginVersion)), BinaryWriter::toValue(beginVersion, Unversioned()));
															#line 1341 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!stopWhenDone.present())
															#line 11833 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1342 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			allPartsDone = futureBucket->future(tr);
															#line 1343 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			std::vector<Future<Key>> addTaskVector;
															#line 1344 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			addTaskVector.push_back(CopyDiffLogsTaskFunc::addTask( tr, taskBucket, task, beginVersion, endVersion, TaskCompletionKey::signal(onDone), allPartsDone));
															#line 1346 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int blockSize = std::max<int>( 1, ((endVersion - beginVersion) / CLIENT_KNOBS->BACKUP_COPY_TASKS) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1348 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for(int64_t vblock = beginVersion / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock < (endVersion + CLIENT_KNOBS->BACKUP_BLOCK_SIZE - 1) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE;vblock += blockSize) {
															#line 1351 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(CopyLogRangeTaskFunc::addTask( tr, taskBucket, task, std::max(beginVersion, vblock * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), std::min(endVersion, (vblock + blockSize) * CLIENT_KNOBS->BACKUP_BLOCK_SIZE), TaskCompletionKey::joinWith(allPartsDone)));
															#line 11847 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1360 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (prevBeginVersion > 0)
															#line 11851 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1361 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				addTaskVector.push_back(EraseLogRangeTaskFunc::addTask( tr, taskBucket, task, beginVersion, TaskCompletionKey::joinWith(allPartsDone)));
															#line 11855 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_6 = waitForAll(addTaskVector) && taskBucket->finish(tr, task);
															#line 1365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11861 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont8when1(__when_expr_6.get(), loopDepth); };
			static_cast<_finishActor6*>(this)->actor_wait_state = 7;
															#line 1365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 6, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 1367 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = onDone->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 1367 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 11875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont8when2(__when_expr_7.get(), loopDepth); };
			static_cast<_finishActor6*>(this)->actor_wait_state = 8;
															#line 1367 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _finishActor6, 7, Void >*>(static_cast<_finishActor6*>(this)));
															#line 11880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont3when1(Optional<Value> const& stopWhenDone,int loopDepth) 
	{
		loopDepth = a_body1cont8(stopWhenDone, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Optional<Value> && stopWhenDone,int loopDepth) 
	{
		loopDepth = a_body1cont8(std::move(stopWhenDone), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 5, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 5, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 5, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< _finishActor6, 5, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont9(int loopDepth) 
	{
															#line 1369 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor6State(); static_cast<_finishActor6*>(this)->destroy(); return 0; }
															#line 11953 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor6*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor6State();
		static_cast<_finishActor6*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont11(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont11(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont8when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont8when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont8when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont8when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< _finishActor6, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont14(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont14(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont8when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont14(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont8when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont14(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<_finishActor6*>(this)->actor_wait_state > 0) static_cast<_finishActor6*>(this)->actor_wait_state = 0;
		static_cast<_finishActor6*>(this)->ActorCallback< _finishActor6, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor6, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont8when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< _finishActor6, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont8when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< _finishActor6, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 7);

	}
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1298 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace conf;
															#line 1301 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace states;
															#line 1306 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 1308 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version prevBeginVersion;
															#line 1310 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> fStopWhenDone;
															#line 1314 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 1316 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> onDone;
															#line 1342 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> allPartsDone;
															#line 12135 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor6 final : public Actor<Void>, public ActorCallback< _finishActor6, 0, Void >, public ActorCallback< _finishActor6, 1, Version >, public ActorCallback< _finishActor6, 2, Void >, public ActorCallback< _finishActor6, 3, Void >, public ActorCallback< _finishActor6, 4, Void >, public ActorCallback< _finishActor6, 5, Optional<Value> >, public ActorCallback< _finishActor6, 6, Void >, public ActorCallback< _finishActor6, 7, Void >, public FastAllocated<_finishActor6>, public _finishActor6State<_finishActor6> {
															#line 12140 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor6>::operator new;
	using FastAllocated<_finishActor6>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor6, 0, Void >;
friend struct ActorCallback< _finishActor6, 1, Version >;
friend struct ActorCallback< _finishActor6, 2, Void >;
friend struct ActorCallback< _finishActor6, 3, Void >;
friend struct ActorCallback< _finishActor6, 4, Void >;
friend struct ActorCallback< _finishActor6, 5, Optional<Value> >;
friend struct ActorCallback< _finishActor6, 6, Void >;
friend struct ActorCallback< _finishActor6, 7, Void >;
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor6(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 12158 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor6State<_finishActor6>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor6, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor6, 1, Version >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor6, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _finishActor6, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _finishActor6, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< _finishActor6, 5, Optional<Value> >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< _finishActor6, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< _finishActor6, 7, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor6(tr, taskBucket, futureBucket, task));
															#line 12192 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1371 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 12197 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor6>
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor6State {
															#line 12203 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor6State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& prevBeginVersion,Version const& beginVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   prevBeginVersion(prevBeginVersion),
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   beginVersion(beginVersion),
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 12222 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor6State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1379 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 1379 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12239 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor6*>(this)->actor_wait_state = 1;
															#line 1379 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor6, 0, Key >*>(static_cast<AddTaskActor6*>(this)));
															#line 12244 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor6State();
		static_cast<AddTaskActor6*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 1380 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(CopyDiffLogsTaskFunc::name, CopyDiffLogsTaskFunc::version, doneKey, 1);
															#line 1382 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1384 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 1385 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyPrevBeginVersion] = BinaryWriter::toValue(prevBeginVersion, Unversioned());
															#line 1387 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 12275 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1388 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor6*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor6State(); static_cast<AddTaskActor6*>(this)->destroy(); return 0; }
															#line 12279 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor6*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor6State();
			static_cast<AddTaskActor6*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12289 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor6*>(this)->actor_wait_state = 2;
															#line 1394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor6, 1, Void >*>(static_cast<AddTaskActor6*>(this)));
															#line 12294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 1380 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(CopyDiffLogsTaskFunc::name, CopyDiffLogsTaskFunc::version, doneKey, 1);
															#line 1382 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1384 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 1385 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyPrevBeginVersion] = BinaryWriter::toValue(prevBeginVersion, Unversioned());
															#line 1387 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 12311 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1388 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor6*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor6State(); static_cast<AddTaskActor6*>(this)->destroy(); return 0; }
															#line 12315 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor6*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor6State();
			static_cast<AddTaskActor6*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12325 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor6*>(this)->actor_wait_state = 2;
															#line 1394 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor6, 1, Void >*>(static_cast<AddTaskActor6*>(this)));
															#line 12330 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor6*>(this)->actor_wait_state > 0) static_cast<AddTaskActor6*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor6*>(this)->ActorCallback< AddTaskActor6, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor6, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor6, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor6, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1399 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor6*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor6State(); static_cast<AddTaskActor6*>(this)->destroy(); return 0; }
															#line 12402 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor6*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor6State();
		static_cast<AddTaskActor6*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1399 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor6*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor6State(); static_cast<AddTaskActor6*>(this)->destroy(); return 0; }
															#line 12414 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor6*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor6State();
		static_cast<AddTaskActor6*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor6*>(this)->actor_wait_state > 0) static_cast<AddTaskActor6*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor6*>(this)->ActorCallback< AddTaskActor6, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor6, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor6, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor6, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version prevBeginVersion;
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 12499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor6 final : public Actor<Key>, public ActorCallback< AddTaskActor6, 0, Key >, public ActorCallback< AddTaskActor6, 1, Void >, public FastAllocated<AddTaskActor6>, public AddTaskActor6State<AddTaskActor6> {
															#line 12504 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor6>::operator new;
	using FastAllocated<AddTaskActor6>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor6, 0, Key >;
friend struct ActorCallback< AddTaskActor6, 1, Void >;
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor6(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& prevBeginVersion,Version const& beginVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 12516 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor6State<AddTaskActor6>(tr, taskBucket, parentTask, prevBeginVersion, beginVersion, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor6, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor6, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, Version const& prevBeginVersion, Version const& beginVersion, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 1372 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor6(tr, taskBucket, parentTask, prevBeginVersion, beginVersion, completionKey, waitFor));
															#line 12544 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1401 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return Void();
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef CopyDiffLogsTaskFunc::name = LiteralStringRef("dr_copy_diff_logs");
REGISTER_TASKFUNC(CopyDiffLogsTaskFunc);

// Skip unneeded EraseLogRangeTaskFunc in 5.1
struct SkipOldEraseLogRangeTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 12572 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor7>
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor7State {
															#line 12578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor7State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1429 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskFuture(futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]))
															#line 12593 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor7State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1430 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = taskFuture->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 1430 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor7*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 12610 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor7*>(this)->actor_wait_state = 1;
															#line 1430 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor7, 0, Void >*>(static_cast<_finishActor7*>(this)));
															#line 12615 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor7State();
		static_cast<_finishActor7*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1431 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor7*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor7State(); static_cast<_finishActor7*>(this)->destroy(); return 0; }
															#line 12638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor7*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor7State();
		static_cast<_finishActor7*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1431 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor7*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor7State(); static_cast<_finishActor7*>(this)->destroy(); return 0; }
															#line 12650 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor7*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor7State();
		static_cast<_finishActor7*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor7*>(this)->actor_wait_state > 0) static_cast<_finishActor7*>(this)->actor_wait_state = 0;
		static_cast<_finishActor7*>(this)->ActorCallback< _finishActor7, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor7, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor7, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor7, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1429 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> taskFuture;
															#line 12731 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor7 final : public Actor<Void>, public ActorCallback< _finishActor7, 0, Void >, public FastAllocated<_finishActor7>, public _finishActor7State<_finishActor7> {
															#line 12736 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor7>::operator new;
	using FastAllocated<_finishActor7>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor7, 0, Void >;
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor7(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 12747 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor7State<_finishActor7>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor7, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor7(tr, taskBucket, futureBucket, task));
															#line 12774 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1433 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return Void();
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef SkipOldEraseLogRangeTaskFunc::name = LiteralStringRef("dr_skip_legacy_task");
REGISTER_TASKFUNC(SkipOldEraseLogRangeTaskFunc);
REGISTER_TASKFUNC_ALIAS(SkipOldEraseLogRangeTaskFunc, db_erase_log_range);

// This is almost the same as CopyLogRangeTaskFunc in 5.1. The only purpose is to support DR upgrade
struct OldCopyLogRangeTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

	static struct {
		static TaskParam<int64_t> bytesWritten() { return LiteralStringRef(__FUNCTION__); }
	} Params;

	static const Key keyNextBeginVersion;

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};

																#line 12824 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via dumpData()
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class DumpDataActor1>
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class DumpDataActor1State {
															#line 12830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DumpDataActor1State(Database const& cx,Reference<Task> const& task,PromiseStream<RCGroup> const& results,FlowLock* const& lock,Reference<TaskBucket> const& tb) 
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   results(results),
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lock(lock),
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tb(tb),
															#line 1484 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endOfStream(false),
															#line 1485 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   conf(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[BackupAgentBase::keyConfigLogUid])),
															#line 1489 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   nextMutations(),
															#line 1490 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   nextMutationSize(0)
															#line 12853 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("dumpData", reinterpret_cast<unsigned long>(this));

	}
	~DumpDataActor1State() 
	{
		fdb_probe_actor_destroy("dumpData", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			;
															#line 12868 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DumpDataActor1State();
		static_cast<DumpDataActor1*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 1493 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (endOfStream && !nextMutationSize)
															#line 12899 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1494 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (!static_cast<DumpDataActor1*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DumpDataActor1State(); static_cast<DumpDataActor1*>(this)->destroy(); return 0; }
															#line 12903 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				new (&static_cast<DumpDataActor1*>(this)->SAV< Void >::value()) Void(Void());
				this->~DumpDataActor1State();
				static_cast<DumpDataActor1*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 1497 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			mutations = std::move(nextMutations);
															#line 1498 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			mutationSize = nextMutationSize;
															#line 1499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutations = std::vector<RangeResult>();
															#line 1500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutationSize = 0;
															#line 1502 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!endOfStream)
															#line 12919 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1503 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				;
															#line 12923 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = a_body1loopBody1loopHead1(loopDepth);
			}
			else
			{
				loopDepth = a_body1loopBody1cont2(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (e.code() == error_code_actor_cancelled || e.code() == error_code_backup_error)
															#line 12950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1564 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1Catch1(e, std::max(0, loopDepth - 1));
															#line 12954 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 1566 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			err = e;
															#line 1567 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = logError(cx, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyErrors) .pack(task->params[BackupAgentBase::keyConfigLogUid]), format("ERROR: Failed to dump mutations because of error %s", err.what()));
															#line 1567 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor1*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 12962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<DumpDataActor1*>(this)->actor_wait_state = 5;
															#line 1567 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor1, 4, Void >*>(static_cast<DumpDataActor1*>(this)));
															#line 12967 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(int loopDepth) 
	{
															#line 1530 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Transaction(cx);
															#line 1532 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 12984 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1(int loopDepth) 
	{
		try {
															#line 1505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			FutureStream<RCGroup> __when_expr_0 = results.getFuture();
															#line 1505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor1*>(this)->actor_wait_state < 0) return a_body1loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 13009 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1loopBody1when1(__when_expr_0.pop(), loopDepth); };
			static_cast<DumpDataActor1*>(this)->actor_wait_state = 1;
															#line 1505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorSingleCallback< DumpDataActor1, 0, RCGroup >*>(static_cast<DumpDataActor1*>(this)));
															#line 13014 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			error = e;
															#line 1520 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (e.code() == error_code_end_of_stream)
															#line 13051 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1521 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				endOfStream = true;
															#line 13055 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				return a_body1loopBody1break1(loopDepth==0?0:loopDepth-1); // break
			}
															#line 1525 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
															#line 13060 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1loopBody1cont2(RCGroup const& group,int loopDepth) 
	{
															#line 1506 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		lock->release(group.items.expectedSize());
															#line 1508 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int vecSize = group.items.expectedSize();
															#line 1509 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (mutationSize + vecSize >= CLIENT_KNOBS->BACKUP_LOG_WRITE_BATCH_MAX_SIZE)
															#line 13078 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1511 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutations.push_back(group.items);
															#line 1512 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutationSize = vecSize;
															#line 13084 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			return a_body1loopBody1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 1516 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutations.push_back(group.items);
															#line 1517 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutationSize += vecSize;
															#line 13091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1cont2(RCGroup && group,int loopDepth) 
	{
															#line 1506 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		lock->release(group.items.expectedSize());
															#line 1508 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int vecSize = group.items.expectedSize();
															#line 1509 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (mutationSize + vecSize >= CLIENT_KNOBS->BACKUP_LOG_WRITE_BATCH_MAX_SIZE)
															#line 13104 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1511 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutations.push_back(group.items);
															#line 1512 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			nextMutationSize = vecSize;
															#line 13110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			return a_body1loopBody1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 1516 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutations.push_back(group.items);
															#line 1517 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mutationSize += vecSize;
															#line 13117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1when1(RCGroup const& group,int loopDepth) 
	{
		loopDepth = a_body1loopBody1loopBody1cont2(group, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1loopBody1when1(RCGroup && group,int loopDepth) 
	{
		loopDepth = a_body1loopBody1loopBody1cont2(std::move(group), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DumpDataActor1*>(this)->actor_wait_state > 0) static_cast<DumpDataActor1*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor1*>(this)->ActorSingleCallback< DumpDataActor1, 0, RCGroup >::remove();

	}
	void a_callback_fire(ActorSingleCallback< DumpDataActor1, 0, RCGroup >*,RCGroup const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorSingleCallback< DumpDataActor1, 0, RCGroup >*,RCGroup && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorSingleCallback< DumpDataActor1, 0, RCGroup >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1loopBody1cont5(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1(int loopDepth) 
	{
		try {
															#line 1534 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1535 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr.trState->options.sizeLimit = 2 * CLIENT_KNOBS->TRANSACTION_SIZE_LIMIT;
															#line 1536 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_1 = checkDatabaseLock(&tr, BinaryReader::fromStringRef<UID>( task->params[BackupAgentBase::keyConfigLogUid], Unversioned()));
															#line 1536 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor1*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 13222 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1cont2loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<DumpDataActor1*>(this)->actor_wait_state = 2;
															#line 1536 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor1, 1, Void >*>(static_cast<DumpDataActor1*>(this)));
															#line 13227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1cont2loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1cont2loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2break1(int loopDepth) 
	{
		try {
			return a_body1loopBody1cont5(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopBody1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr.onError(e);
															#line 1559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DumpDataActor1*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 13264 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1cont2loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<DumpDataActor1*>(this)->actor_wait_state = 4;
															#line 1559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor1, 3, Void >*>(static_cast<DumpDataActor1*>(this)));
															#line 13269 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 1539 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bytesSet = 0;
															#line 1541 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool first = true;
															#line 1542 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto m : mutations ) {
															#line 1543 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto kv : m ) {
															#line 1544 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (first)
															#line 13292 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 1545 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					tr.addReadConflictRange(singleKeyRange(kv.key));
															#line 1546 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					first = false;
															#line 13298 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
															#line 1548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr.set(kv.key.removePrefix(backupLogKeys.begin).withPrefix(applyLogKeys.begin), kv.value);
															#line 1550 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				bytesSet += kv.expectedSize() - backupLogKeys.begin.expectedSize() + applyLogKeys.begin.expectedSize();
															#line 13304 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 1555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr.commit();
															#line 1555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<DumpDataActor1*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 13311 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont2loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<DumpDataActor1*>(this)->actor_wait_state = 3;
															#line 1555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor1, 2, Void >*>(static_cast<DumpDataActor1*>(this)));
															#line 13316 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 1539 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bytesSet = 0;
															#line 1541 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool first = true;
															#line 1542 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto m : mutations ) {
															#line 1543 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto kv : m ) {
															#line 1544 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (first)
															#line 13333 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 1545 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					tr.addReadConflictRange(singleKeyRange(kv.key));
															#line 1546 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					first = false;
															#line 13339 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
															#line 1548 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr.set(kv.key.removePrefix(backupLogKeys.begin).withPrefix(applyLogKeys.begin), kv.value);
															#line 1550 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				bytesSet += kv.expectedSize() - backupLogKeys.begin.expectedSize() + applyLogKeys.begin.expectedSize();
															#line 13345 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 1555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr.commit();
															#line 1555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<DumpDataActor1*>(this)->actor_wait_state < 0) return a_body1loopBody1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 13352 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1cont2loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont2loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<DumpDataActor1*>(this)->actor_wait_state = 3;
															#line 1555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DumpDataActor1, 2, Void >*>(static_cast<DumpDataActor1*>(this)));
															#line 13357 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DumpDataActor1*>(this)->actor_wait_state > 0) static_cast<DumpDataActor1*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor1*>(this)->ActorCallback< DumpDataActor1, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DumpDataActor1, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont2loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 1556 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Params.bytesWritten().set(task, Params.bytesWritten().getOrDefault(task) + bytesSet);
															#line 13429 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 1556 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Params.bytesWritten().set(task, Params.bytesWritten().getOrDefault(task) + bytesSet);
															#line 13438 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1loopBody1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<DumpDataActor1*>(this)->actor_wait_state > 0) static_cast<DumpDataActor1*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor1*>(this)->ActorCallback< DumpDataActor1, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< DumpDataActor1, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont2loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<DumpDataActor1*>(this)->actor_wait_state > 0) static_cast<DumpDataActor1*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor1*>(this)->ActorCallback< DumpDataActor1, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont2loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont2loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< DumpDataActor1, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont6(int loopDepth) 
	{
		try {
			loopDepth = a_body1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
															#line 1573 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 1));
															#line 13598 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
															#line 1573 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		return a_body1Catch1(err, std::max(0, loopDepth - 1));
															#line 13606 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<DumpDataActor1*>(this)->actor_wait_state > 0) static_cast<DumpDataActor1*>(this)->actor_wait_state = 0;
		static_cast<DumpDataActor1*>(this)->ActorCallback< DumpDataActor1, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< DumpDataActor1, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< DumpDataActor1, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	PromiseStream<RCGroup> results;
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	FlowLock* lock;
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> tb;
															#line 1484 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	bool endOfStream;
															#line 1485 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace conf;
															#line 1489 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<RangeResult> nextMutations;
															#line 1490 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t nextMutationSize;
															#line 1497 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<RangeResult> mutations;
															#line 1498 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t mutationSize;
															#line 1519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Error error;
															#line 1530 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Transaction tr;
															#line 1539 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int64_t bytesSet;
															#line 1566 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Error err;
															#line 13703 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via dumpData()
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class DumpDataActor1 final : public Actor<Void>, public ActorSingleCallback< DumpDataActor1, 0, RCGroup >, public ActorCallback< DumpDataActor1, 1, Void >, public ActorCallback< DumpDataActor1, 2, Void >, public ActorCallback< DumpDataActor1, 3, Void >, public ActorCallback< DumpDataActor1, 4, Void >, public FastAllocated<DumpDataActor1>, public DumpDataActor1State<DumpDataActor1> {
															#line 13708 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<DumpDataActor1>::operator new;
	using FastAllocated<DumpDataActor1>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorSingleCallback< DumpDataActor1, 0, RCGroup >;
friend struct ActorCallback< DumpDataActor1, 1, Void >;
friend struct ActorCallback< DumpDataActor1, 2, Void >;
friend struct ActorCallback< DumpDataActor1, 3, Void >;
friend struct ActorCallback< DumpDataActor1, 4, Void >;
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DumpDataActor1(Database const& cx,Reference<Task> const& task,PromiseStream<RCGroup> const& results,FlowLock* const& lock,Reference<TaskBucket> const& tb) 
															#line 13723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   DumpDataActor1State<DumpDataActor1>(cx, task, results, lock, tb)
	{
		fdb_probe_actor_enter("dumpData", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("dumpData");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("dumpData", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorSingleCallback< DumpDataActor1, 0, RCGroup >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DumpDataActor1, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< DumpDataActor1, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< DumpDataActor1, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< DumpDataActor1, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> dumpData( Database const& cx, Reference<Task> const& task, PromiseStream<RCGroup> const& results, FlowLock* const& lock, Reference<TaskBucket> const& tb ) {
															#line 1479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new DumpDataActor1(cx, task, results, lock, tb));
															#line 13754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1577 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 13759 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor4>
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor4State {
															#line 13765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor4State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1582 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lock(new FlowLock(CLIENT_KNOBS->BACKUP_LOCK_BYTES))
															#line 13780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor4State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1584 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, OldCopyLogRangeTaskFunc::name, OldCopyLogRangeTaskFunc::version);
															#line 1584 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor4*>(this)->actor_wait_state = 1;
															#line 1584 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor4, 0, Void >*>(static_cast<_executeActor4*>(this)));
															#line 13802 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor4State();
		static_cast<_executeActor4*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1588 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyEndVersion], Unversioned());
															#line 1590 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		newEndVersion = std::min(endVersion, (((beginVersion - 1) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE) + 2 + (g_network->isSimulated() ? CLIENT_KNOBS->BACKUP_SIM_COPY_LOG_RANGES : 0)) * CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1596 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		ranges = getLogRanges(beginVersion, newEndVersion, task->params[BackupAgentBase::keyConfigLogUid], CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1600 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		results = std::vector<PromiseStream<RCGroup>>();
															#line 1601 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rc = std::vector<Future<Void>>();
															#line 1602 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		dump = std::vector<Future<Void>>();
															#line 1604 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for(int i = 0;i < ranges.size();++i) {
															#line 1605 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			results.push_back(PromiseStream<RCGroup>());
															#line 1606 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rc.push_back(readCommitted(taskBucket->src, results[i], Future<Void>(Void()), lock, ranges[i], decodeBKMutationLogKey, Terminator::True, AccessSystemKeys::True, LockAware::True));
															#line 1615 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			dump.push_back(dumpData(cx, task, results[i], lock.getPtr(), taskBucket));
															#line 13845 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1618 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitForAll(dump);
															#line 1618 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13851 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_executeActor4*>(this)->actor_wait_state = 2;
															#line 1618 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor4, 1, Void >*>(static_cast<_executeActor4*>(this)));
															#line 13856 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1588 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyEndVersion], Unversioned());
															#line 1590 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		newEndVersion = std::min(endVersion, (((beginVersion - 1) / CLIENT_KNOBS->BACKUP_BLOCK_SIZE) + 2 + (g_network->isSimulated() ? CLIENT_KNOBS->BACKUP_SIM_COPY_LOG_RANGES : 0)) * CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1596 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		ranges = getLogRanges(beginVersion, newEndVersion, task->params[BackupAgentBase::keyConfigLogUid], CLIENT_KNOBS->BACKUP_BLOCK_SIZE);
															#line 1600 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		results = std::vector<PromiseStream<RCGroup>>();
															#line 1601 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		rc = std::vector<Future<Void>>();
															#line 1602 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		dump = std::vector<Future<Void>>();
															#line 1604 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for(int i = 0;i < ranges.size();++i) {
															#line 1605 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			results.push_back(PromiseStream<RCGroup>());
															#line 1606 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rc.push_back(readCommitted(taskBucket->src, results[i], Future<Void>(Void()), lock, ranges[i], decodeBKMutationLogKey, Terminator::True, AccessSystemKeys::True, LockAware::True));
															#line 1615 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			dump.push_back(dumpData(cx, task, results[i], lock.getPtr(), taskBucket));
															#line 13885 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1618 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitForAll(dump);
															#line 1618 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor4*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 13891 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_executeActor4*>(this)->actor_wait_state = 2;
															#line 1618 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor4, 1, Void >*>(static_cast<_executeActor4*>(this)));
															#line 13896 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor4*>(this)->actor_wait_state > 0) static_cast<_executeActor4*>(this)->actor_wait_state = 0;
		static_cast<_executeActor4*>(this)->ActorCallback< _executeActor4, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor4, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor4, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor4, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1620 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (newEndVersion < endVersion)
															#line 13968 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1621 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			task->params[OldCopyLogRangeTaskFunc::keyNextBeginVersion] = BinaryWriter::toValue(newEndVersion, Unversioned());
															#line 13972 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1625 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor4*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor4State(); static_cast<_executeActor4*>(this)->destroy(); return 0; }
															#line 13976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor4*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor4State();
		static_cast<_executeActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1620 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (newEndVersion < endVersion)
															#line 13988 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1621 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			task->params[OldCopyLogRangeTaskFunc::keyNextBeginVersion] = BinaryWriter::toValue(newEndVersion, Unversioned());
															#line 13992 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 1625 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor4*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor4State(); static_cast<_executeActor4*>(this)->destroy(); return 0; }
															#line 13996 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor4*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor4State();
		static_cast<_executeActor4*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor4*>(this)->actor_wait_state > 0) static_cast<_executeActor4*>(this)->actor_wait_state = 0;
		static_cast<_executeActor4*>(this)->ActorCallback< _executeActor4, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor4, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor4, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor4, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1582 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FlowLock> lock;
															#line 1586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 1588 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 1590 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version newEndVersion;
															#line 1596 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> ranges;
															#line 1600 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<PromiseStream<RCGroup>> results;
															#line 1601 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<Future<Void>> rc;
															#line 1602 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<Future<Void>> dump;
															#line 14091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor4 final : public Actor<Void>, public ActorCallback< _executeActor4, 0, Void >, public ActorCallback< _executeActor4, 1, Void >, public FastAllocated<_executeActor4>, public _executeActor4State<_executeActor4> {
															#line 14096 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor4>::operator new;
	using FastAllocated<_executeActor4>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor4, 0, Void >;
friend struct ActorCallback< _executeActor4, 1, Void >;
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor4(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 14108 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor4State<_executeActor4>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor4, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor4, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor4(cx, taskBucket, futureBucket, task));
															#line 14136 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1627 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 14141 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor7>
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor7State {
															#line 14147 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor7State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& beginVersion,Version const& endVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   beginVersion(beginVersion),
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endVersion(endVersion),
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 14166 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor7State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 1635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor7*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14183 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor7*>(this)->actor_wait_state = 1;
															#line 1635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor7, 0, Key >*>(static_cast<AddTaskActor7*>(this)));
															#line 14188 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor7State();
		static_cast<AddTaskActor7*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 1636 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(OldCopyLogRangeTaskFunc::name, OldCopyLogRangeTaskFunc::version, doneKey, 1);
															#line 1638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1640 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 1641 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyEndVersion] = BinaryWriter::toValue(endVersion, Unversioned());
															#line 1643 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 14219 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1644 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor7*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor7State(); static_cast<AddTaskActor7*>(this)->destroy(); return 0; }
															#line 14223 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor7*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor7State();
			static_cast<AddTaskActor7*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1650 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1650 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor7*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor7*>(this)->actor_wait_state = 2;
															#line 1650 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor7, 1, Void >*>(static_cast<AddTaskActor7*>(this)));
															#line 14238 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 1636 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(OldCopyLogRangeTaskFunc::name, OldCopyLogRangeTaskFunc::version, doneKey, 1);
															#line 1638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1640 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyBeginVersion] = BinaryWriter::toValue(beginVersion, Unversioned());
															#line 1641 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyEndVersion] = BinaryWriter::toValue(endVersion, Unversioned());
															#line 1643 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 14255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1644 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor7*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor7State(); static_cast<AddTaskActor7*>(this)->destroy(); return 0; }
															#line 14259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor7*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor7State();
			static_cast<AddTaskActor7*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1650 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1650 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor7*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14269 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor7*>(this)->actor_wait_state = 2;
															#line 1650 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor7, 1, Void >*>(static_cast<AddTaskActor7*>(this)));
															#line 14274 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor7*>(this)->actor_wait_state > 0) static_cast<AddTaskActor7*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor7*>(this)->ActorCallback< AddTaskActor7, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor7, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor7, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor7, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1655 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor7*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor7State(); static_cast<AddTaskActor7*>(this)->destroy(); return 0; }
															#line 14346 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor7*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor7State();
		static_cast<AddTaskActor7*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1655 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor7*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor7State(); static_cast<AddTaskActor7*>(this)->destroy(); return 0; }
															#line 14358 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor7*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor7State();
		static_cast<AddTaskActor7*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor7*>(this)->actor_wait_state > 0) static_cast<AddTaskActor7*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor7*>(this)->ActorCallback< AddTaskActor7, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor7, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor7, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor7, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 14443 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor7 final : public Actor<Key>, public ActorCallback< AddTaskActor7, 0, Key >, public ActorCallback< AddTaskActor7, 1, Void >, public FastAllocated<AddTaskActor7>, public AddTaskActor7State<AddTaskActor7> {
															#line 14448 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor7>::operator new;
	using FastAllocated<AddTaskActor7>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor7, 0, Key >;
friend struct ActorCallback< AddTaskActor7, 1, Void >;
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor7(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,Version const& beginVersion,Version const& endVersion,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 14460 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor7State<AddTaskActor7>(tr, taskBucket, parentTask, beginVersion, endVersion, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor7, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor7, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, Version const& beginVersion, Version const& endVersion, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 1628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor7(tr, taskBucket, parentTask, beginVersion, endVersion, completionKey, waitFor));
															#line 14488 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1657 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 14493 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor8>
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor8State {
															#line 14499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor8State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1663 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   endVersion(BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyEndVersion], Unversioned())),
															#line 1665 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskFuture(futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]))
															#line 14516 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor8State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1669 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			DRConfig config(task);
															#line 1670 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			int64_t bytesWritten = Params.bytesWritten().getOrDefault(task);
															#line 1671 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			config.logBytesWritten().atomicOp(tr, bytesWritten, MutationRef::AddValue);
															#line 1673 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (task->params.find(OldCopyLogRangeTaskFunc::keyNextBeginVersion) != task->params.end())
															#line 14537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1674 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				nextVersion = BinaryReader::fromStringRef<Version>( task->params[OldCopyLogRangeTaskFunc::keyNextBeginVersion], Unversioned());
															#line 1676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_0 = success(OldCopyLogRangeTaskFunc::addTask( tr, taskBucket, task, nextVersion, endVersion, TaskCompletionKey::signal(taskFuture->key))) && taskBucket->finish(tr, task);
															#line 1676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14545 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
				static_cast<_finishActor8*>(this)->actor_wait_state = 1;
															#line 1676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor8, 0, Void >*>(static_cast<_finishActor8*>(this)));
															#line 14550 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
															#line 1680 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<Void> __when_expr_1 = taskFuture->set(tr, taskBucket) && taskBucket->finish(tr, task);
															#line 1680 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_finishActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1when2(__when_expr_1.get(), loopDepth); };
				static_cast<_finishActor8*>(this)->actor_wait_state = 2;
															#line 1680 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor8, 1, Void >*>(static_cast<_finishActor8*>(this)));
															#line 14564 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor8State();
		static_cast<_finishActor8*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 1683 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor8*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor8State(); static_cast<_finishActor8*>(this)->destroy(); return 0; }
															#line 14588 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor8*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor8State();
		static_cast<_finishActor8*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor8*>(this)->actor_wait_state > 0) static_cast<_finishActor8*>(this)->actor_wait_state = 0;
		static_cast<_finishActor8*>(this)->ActorCallback< _finishActor8, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor8, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor8, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor8, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor8*>(this)->actor_wait_state > 0) static_cast<_finishActor8*>(this)->actor_wait_state = 0;
		static_cast<_finishActor8*>(this)->ActorCallback< _finishActor8, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor8, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor8, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor8, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1663 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 1665 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> taskFuture;
															#line 1674 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version nextVersion;
															#line 14760 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor8 final : public Actor<Void>, public ActorCallback< _finishActor8, 0, Void >, public ActorCallback< _finishActor8, 1, Void >, public FastAllocated<_finishActor8>, public _finishActor8State<_finishActor8> {
															#line 14765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor8>::operator new;
	using FastAllocated<_finishActor8>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor8, 0, Void >;
friend struct ActorCallback< _finishActor8, 1, Void >;
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor8(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 14777 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor8State<_finishActor8>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor8, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor8, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor8(tr, taskBucket, futureBucket, task));
															#line 14805 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1685 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
};
StringRef OldCopyLogRangeTaskFunc::name = LiteralStringRef("db_copy_log_range");
const Key OldCopyLogRangeTaskFunc::keyNextBeginVersion = LiteralStringRef("nextBeginVersion");
REGISTER_TASKFUNC(OldCopyLogRangeTaskFunc);

struct AbortOldBackupTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 14818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor5>
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor5State {
															#line 14824 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor5State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   srcDrAgent(taskBucket->src),
															#line 1699 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(new ReadYourWritesTransaction(cx)),
															#line 1700 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagNameKey()
															#line 14843 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor5State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1702 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			;
															#line 14858 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor5State();
		static_cast<_executeActor5*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 1720 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_AbortOldBackup").detail("TagName", tagNameKey.printable());
															#line 1721 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = srcDrAgent.abortBackup(cx, tagNameKey, PartialBackup::False, AbortOldBackup::True);
															#line 1721 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 14885 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor5*>(this)->actor_wait_state = 3;
															#line 1721 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor5, 2, Void >*>(static_cast<_executeActor5*>(this)));
															#line 14890 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 1704 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 1705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1706 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Key tagPath = srcDrAgent.states.get(task->params[DatabaseBackupAgent::keyConfigLogUid]) .pack(BackupAgentBase::keyConfigBackupTag);
															#line 1708 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Key>> __when_expr_0 = tr->get(tagPath);
															#line 1708 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor5*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 14915 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor5*>(this)->actor_wait_state = 1;
															#line 1708 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor5, 0, Optional<Key> >*>(static_cast<_executeActor5*>(this)));
															#line 14920 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1716 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_1 = tr->onError(e);
															#line 1716 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor5*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 14957 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_1.get(), loopDepth); };
			static_cast<_executeActor5*>(this)->actor_wait_state = 2;
															#line 1716 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor5, 1, Void >*>(static_cast<_executeActor5*>(this)));
															#line 14962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Key> const& tagName,int loopDepth) 
	{
															#line 1709 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!tagName.present())
															#line 14977 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1710 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor5State(); static_cast<_executeActor5*>(this)->destroy(); return 0; }
															#line 14981 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor5*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor5State();
			static_cast<_executeActor5*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1713 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tagNameKey = tagName.get();
															#line 14989 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont2(Optional<Key> && tagName,int loopDepth) 
	{
															#line 1709 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!tagName.present())
															#line 14998 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1710 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor5State(); static_cast<_executeActor5*>(this)->destroy(); return 0; }
															#line 15002 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor5*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor5State();
			static_cast<_executeActor5*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1713 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tagNameKey = tagName.get();
															#line 15010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Key> const& tagName,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(tagName, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Optional<Key> && tagName,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(tagName), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor5*>(this)->actor_wait_state > 0) static_cast<_executeActor5*>(this)->actor_wait_state = 0;
		static_cast<_executeActor5*>(this)->ActorCallback< _executeActor5, 0, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor5, 0, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor5, 0, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor5, 0, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor5*>(this)->actor_wait_state > 0) static_cast<_executeActor5*>(this)->actor_wait_state = 0;
		static_cast<_executeActor5*>(this)->ActorCallback< _executeActor5, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor5, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor5, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor5, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor5State(); static_cast<_executeActor5*>(this)->destroy(); return 0; }
															#line 15157 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor5*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor5State();
		static_cast<_executeActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor5*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor5State(); static_cast<_executeActor5*>(this)->destroy(); return 0; }
															#line 15169 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor5*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor5State();
		static_cast<_executeActor5*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_executeActor5*>(this)->actor_wait_state > 0) static_cast<_executeActor5*>(this)->actor_wait_state = 0;
		static_cast<_executeActor5*>(this)->ActorCallback< _executeActor5, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor5, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _executeActor5, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _executeActor5, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent srcDrAgent;
															#line 1699 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1700 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagNameKey;
															#line 15254 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor5 final : public Actor<Void>, public ActorCallback< _executeActor5, 0, Optional<Key> >, public ActorCallback< _executeActor5, 1, Void >, public ActorCallback< _executeActor5, 2, Void >, public FastAllocated<_executeActor5>, public _executeActor5State<_executeActor5> {
															#line 15259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor5>::operator new;
	using FastAllocated<_executeActor5>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor5, 0, Optional<Key> >;
friend struct ActorCallback< _executeActor5, 1, Void >;
friend struct ActorCallback< _executeActor5, 2, Void >;
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor5(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 15272 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor5State<_executeActor5>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor5, 0, Optional<Key> >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor5, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _executeActor5, 2, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor5(cx, taskBucket, futureBucket, task));
															#line 15301 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1725 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 15306 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor9>
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor9State {
															#line 15312 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor9State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task)
															#line 15325 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor9State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = taskBucket->finish(tr, task);
															#line 1730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor9*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15342 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor9*>(this)->actor_wait_state = 1;
															#line 1730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor9, 0, Void >*>(static_cast<_finishActor9*>(this)));
															#line 15347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor9State();
		static_cast<_finishActor9*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1731 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor9*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor9State(); static_cast<_finishActor9*>(this)->destroy(); return 0; }
															#line 15370 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor9*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor9State();
		static_cast<_finishActor9*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1731 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor9*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor9State(); static_cast<_finishActor9*>(this)->destroy(); return 0; }
															#line 15382 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor9*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor9State();
		static_cast<_finishActor9*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor9*>(this)->actor_wait_state > 0) static_cast<_finishActor9*>(this)->actor_wait_state = 0;
		static_cast<_finishActor9*>(this)->ActorCallback< _finishActor9, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor9, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor9, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor9, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 15461 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor9 final : public Actor<Void>, public ActorCallback< _finishActor9, 0, Void >, public FastAllocated<_finishActor9>, public _finishActor9State<_finishActor9> {
															#line 15466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor9>::operator new;
	using FastAllocated<_finishActor9>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor9, 0, Void >;
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor9(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 15477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor9State<_finishActor9>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor9, 0, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1726 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor9(tr, taskBucket, futureBucket, task));
															#line 15504 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1733 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 15509 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor8>
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor8State {
															#line 15515 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor8State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 15530 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor8State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1739 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 1739 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor8*>(this)->actor_wait_state = 1;
															#line 1739 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor8, 0, Key >*>(static_cast<AddTaskActor8*>(this)));
															#line 15552 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor8State();
		static_cast<AddTaskActor8*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 1740 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(AbortOldBackupTaskFunc::name, AbortOldBackupTaskFunc::version, doneKey, 1);
															#line 1742 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1744 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 15579 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1745 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor8*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor8State(); static_cast<AddTaskActor8*>(this)->destroy(); return 0; }
															#line 15583 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor8*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor8State();
			static_cast<AddTaskActor8*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15593 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor8*>(this)->actor_wait_state = 2;
															#line 1751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor8, 1, Void >*>(static_cast<AddTaskActor8*>(this)));
															#line 15598 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 1740 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(AbortOldBackupTaskFunc::name, AbortOldBackupTaskFunc::version, doneKey, 1);
															#line 1742 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 1744 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 15611 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1745 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor8*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor8State(); static_cast<AddTaskActor8*>(this)->destroy(); return 0; }
															#line 15615 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor8*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor8State();
			static_cast<AddTaskActor8*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 1751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15625 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor8*>(this)->actor_wait_state = 2;
															#line 1751 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor8, 1, Void >*>(static_cast<AddTaskActor8*>(this)));
															#line 15630 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor8*>(this)->actor_wait_state > 0) static_cast<AddTaskActor8*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor8*>(this)->ActorCallback< AddTaskActor8, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor8, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor8, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor8, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 1756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor8*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor8State(); static_cast<AddTaskActor8*>(this)->destroy(); return 0; }
															#line 15702 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor8*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor8State();
		static_cast<AddTaskActor8*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 1756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor8*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor8State(); static_cast<AddTaskActor8*>(this)->destroy(); return 0; }
															#line 15714 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor8*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor8State();
		static_cast<AddTaskActor8*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor8*>(this)->actor_wait_state > 0) static_cast<AddTaskActor8*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor8*>(this)->ActorCallback< AddTaskActor8, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor8, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor8, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor8, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 15795 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor8 final : public Actor<Key>, public ActorCallback< AddTaskActor8, 0, Key >, public ActorCallback< AddTaskActor8, 1, Void >, public FastAllocated<AddTaskActor8>, public AddTaskActor8State<AddTaskActor8> {
															#line 15800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor8>::operator new;
	using FastAllocated<AddTaskActor8>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor8, 0, Key >;
friend struct ActorCallback< AddTaskActor8, 1, Void >;
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor8(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 15812 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor8State<AddTaskActor8>(tr, taskBucket, parentTask, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor8, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor8, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 1734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor8(tr, taskBucket, parentTask, completionKey, waitFor));
															#line 15840 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1758 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef AbortOldBackupTaskFunc::name = LiteralStringRef("dr_abort_legacy_backup");
REGISTER_TASKFUNC(AbortOldBackupTaskFunc);
REGISTER_TASKFUNC_ALIAS(AbortOldBackupTaskFunc, db_backup_range);
REGISTER_TASKFUNC_ALIAS(AbortOldBackupTaskFunc, db_finish_full_backup);
REGISTER_TASKFUNC_ALIAS(AbortOldBackupTaskFunc, db_copy_logs);
REGISTER_TASKFUNC_ALIAS(AbortOldBackupTaskFunc, db_finished_full_backup);
REGISTER_TASKFUNC_ALIAS(AbortOldBackupTaskFunc, db_backup_restorable);
REGISTER_TASKFUNC_ALIAS(AbortOldBackupTaskFunc, db_start_full_backup);

// Upgrade DR from 5.1
struct CopyDiffLogsUpgradeTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 15874 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor6>
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor6State {
															#line 15880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor6State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1792 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUidValue(task->params[DatabaseBackupAgent::keyConfigLogUid]),
															#line 1793 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   sourceStates(Subspace(databaseBackupPrefixRange.begin).get(BackupAgentBase::keySourceStates).get(logUidValue)),
															#line 1795 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   config(Subspace(databaseBackupPrefixRange.begin).get(BackupAgentBase::keyConfig).get(logUidValue))
															#line 15899 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor6State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, CopyDiffLogsUpgradeTaskFunc::name, CopyDiffLogsUpgradeTaskFunc::version);
															#line 1797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 15916 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor6*>(this)->actor_wait_state = 1;
															#line 1797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 0, Void >*>(static_cast<_executeActor6*>(this)));
															#line 15921 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor6State();
		static_cast<_executeActor6*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = Standalone<VectorRef<KeyRangeRef>>();
															#line 1801 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(cx));
															#line 1802 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 15948 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = Standalone<VectorRef<KeyRangeRef>>();
															#line 1801 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(cx));
															#line 1802 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 15961 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor6, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 1823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destUidValue = Key(logUidValue);
															#line 1824 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 1825 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 16037 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
		try {
															#line 1804 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1805 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 1806 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Future<Void> verified = taskBucket->keepRunning(tr, task);
															#line 1807 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_1 = verified;
															#line 1807 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16062 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<_executeActor6*>(this)->actor_wait_state = 2;
															#line 1807 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 1, Void >*>(static_cast<_executeActor6*>(this)));
															#line 16067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr->onError(e);
															#line 1818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 16104 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<_executeActor6*>(this)->actor_wait_state = 4;
															#line 1818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 3, Void >*>(static_cast<_executeActor6*>(this)));
															#line 16109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 1809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_2 = tr->get(config.pack(BackupAgentBase::keyConfigBackupRanges));
															#line 1809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16126 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor6*>(this)->actor_wait_state = 3;
															#line 1809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 2, Optional<Key> >*>(static_cast<_executeActor6*>(this)));
															#line 16131 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 1809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_2 = tr->get(config.pack(BackupAgentBase::keyConfigBackupRanges));
															#line 1809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16142 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor6*>(this)->actor_wait_state = 3;
															#line 1809 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 2, Optional<Key> >*>(static_cast<_executeActor6*>(this)));
															#line 16147 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor6, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont3(Optional<Key> const& backupKeysPacked,int loopDepth) 
	{
															#line 1810 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!backupKeysPacked.present())
															#line 16219 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1811 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor6State(); static_cast<_executeActor6*>(this)->destroy(); return 0; }
															#line 16223 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor6*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor6State();
			static_cast<_executeActor6*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1814 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		BinaryReader br(backupKeysPacked.get(), IncludeVersion());
															#line 1815 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		br >> backupRanges;
															#line 16233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(Optional<Key> && backupKeysPacked,int loopDepth) 
	{
															#line 1810 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!backupKeysPacked.present())
															#line 16242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1811 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor6State(); static_cast<_executeActor6*>(this)->destroy(); return 0; }
															#line 16246 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor6*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor6State();
			static_cast<_executeActor6*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1814 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		BinaryReader br(backupKeysPacked.get(), IncludeVersion());
															#line 1815 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		br >> backupRanges;
															#line 16256 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Optional<Key> const& backupKeysPacked,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(backupKeysPacked, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Optional<Key> && backupKeysPacked,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(backupKeysPacked), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 2, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 2, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 2, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _executeActor6, 2, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _executeActor6, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1873 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::destUid] = destUidValue;
															#line 1874 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		ASSERT(destUidValue == logUidValue);
															#line 1876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor6State(); static_cast<_executeActor6*>(this)->destroy(); return 0; }
															#line 16407 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor6*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor6State();
		static_cast<_executeActor6*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1(int loopDepth) 
	{
		try {
															#line 1827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1828 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 1830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_4 = srcTr->get(sourceStates.pack(DatabaseBackupAgent::keyFolderId));
															#line 1830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16433 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1cont2loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont2loopBody1when1(__when_expr_4.get(), loopDepth); };
			static_cast<_executeActor6*>(this)->actor_wait_state = 5;
															#line 1830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 4, Optional<Value> >*>(static_cast<_executeActor6*>(this)));
															#line 16438 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont2loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont2loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2break1(int loopDepth) 
	{
		try {
			return a_body1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1869 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = srcTr->onError(e);
															#line 1869 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 16475 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1Catch1when1(__when_expr_7.get(), loopDepth); };
			static_cast<_executeActor6*>(this)->actor_wait_state = 8;
															#line 1869 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 7, Void >*>(static_cast<_executeActor6*>(this)));
															#line 16480 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2(int loopDepth) 
	{
															#line 1831 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present() && BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) > BinaryReader::fromStringRef<Version>( task->params[DatabaseBackupAgent::keyFolderId], Unversioned()))
															#line 16495 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1834 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor6State(); static_cast<_executeActor6*>(this)->destroy(); return 0; }
															#line 16499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor6*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor6State();
			static_cast<_executeActor6*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1837 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupRanges.size() == 1)
															#line 16507 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1838 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<RangeResult> __when_expr_5 = srcTr->getRange( KeyRangeRef(destUidLookupPrefix, strinc(destUidLookupPrefix)), CLIENT_KNOBS->TOO_MANY);
															#line 1838 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16513 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont2loopBody1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_5.get(), loopDepth); };
			static_cast<_executeActor6*>(this)->actor_wait_state = 6;
															#line 1838 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 5, RangeResult >*>(static_cast<_executeActor6*>(this)));
															#line 16518 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont2loopBody1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Optional<Value> const& __v,int loopDepth) 
	{
															#line 1830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		v = __v;
															#line 16532 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Optional<Value> && __v,int loopDepth) 
	{
		v = std::move(__v);
		loopDepth = a_body1cont2loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 4, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 4, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 4, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _executeActor6, 4, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont2loopBody1cont3(int loopDepth) 
	{
															#line 1864 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Key versionKey = logUidValue.withPrefix(destUidValue).withPrefix(backupLatestVersionsPrefix);
															#line 1865 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr->set(versionKey, task->params[DatabaseBackupAgent::keyBeginVersion]);
															#line 1866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = srcTr->commit();
															#line 1866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor6*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 16605 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont2loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont2loopBody1cont3when1(__when_expr_6.get(), loopDepth); };
		static_cast<_executeActor6*>(this)->actor_wait_state = 7;
															#line 1866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _executeActor6, 6, Void >*>(static_cast<_executeActor6*>(this)));
															#line 16610 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont5(RangeResult const& existingDestUidValues,int loopDepth) 
	{
															#line 1840 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool found = false;
															#line 1841 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto it : existingDestUidValues ) {
															#line 1842 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (BinaryReader::fromStringRef<KeyRange>(it.key.removePrefix(destUidLookupPrefix), IncludeVersion()) == backupRanges[0])
															#line 16623 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1844 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (destUidValue != it.value)
															#line 16627 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 1846 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					if (!static_cast<_executeActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor6State(); static_cast<_executeActor6*>(this)->destroy(); return 0; }
															#line 16631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					new (&static_cast<_executeActor6*>(this)->SAV< Void >::value()) Void(Void());
					this->~_executeActor6State();
					static_cast<_executeActor6*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
				else
				{
															#line 1849 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					found = true;
															#line 16641 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					break;
				}
			}
		}
															#line 1854 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (found)
															#line 16648 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 1858 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr->set( BinaryWriter::toValue(backupRanges[0], IncludeVersion(ProtocolVersion::withSharedMutations())) .withPrefix(destUidLookupPrefix), destUidValue);
															#line 16654 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont5(RangeResult && existingDestUidValues,int loopDepth) 
	{
															#line 1840 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool found = false;
															#line 1841 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto it : existingDestUidValues ) {
															#line 1842 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (BinaryReader::fromStringRef<KeyRange>(it.key.removePrefix(destUidLookupPrefix), IncludeVersion()) == backupRanges[0])
															#line 16667 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 1844 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (destUidValue != it.value)
															#line 16671 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				{
															#line 1846 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					if (!static_cast<_executeActor6*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor6State(); static_cast<_executeActor6*>(this)->destroy(); return 0; }
															#line 16675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					new (&static_cast<_executeActor6*>(this)->SAV< Void >::value()) Void(Void());
					this->~_executeActor6State();
					static_cast<_executeActor6*>(this)->finishSendAndDelPromiseRef();
					return 0;
				}
				else
				{
															#line 1849 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					found = true;
															#line 16685 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
					break;
				}
			}
		}
															#line 1854 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (found)
															#line 16692 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 1858 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr->set( BinaryWriter::toValue(backupRanges[0], IncludeVersion(ProtocolVersion::withSharedMutations())) .withPrefix(destUidLookupPrefix), destUidValue);
															#line 16698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(RangeResult const& existingDestUidValues,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont5(existingDestUidValues, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(RangeResult && existingDestUidValues,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont5(std::move(existingDestUidValues), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 5, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 5, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 5, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< _executeActor6, 5, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont2loopBody1cont12(Void const& _,int loopDepth) 
	{
		return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont2loopBody1cont12(Void && _,int loopDepth) 
	{
		return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont12(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont12(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< _executeActor6, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont2loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<_executeActor6*>(this)->actor_wait_state > 0) static_cast<_executeActor6*>(this)->actor_wait_state = 0;
		static_cast<_executeActor6*>(this)->ActorCallback< _executeActor6, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor6, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< _executeActor6, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< _executeActor6, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1792 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUidValue;
															#line 1793 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace sourceStates;
															#line 1795 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace config;
															#line 1800 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> backupRanges;
															#line 1801 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key destUidValue;
															#line 1824 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> srcTr;
															#line 1830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> v;
															#line 16940 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor6 final : public Actor<Void>, public ActorCallback< _executeActor6, 0, Void >, public ActorCallback< _executeActor6, 1, Void >, public ActorCallback< _executeActor6, 2, Optional<Key> >, public ActorCallback< _executeActor6, 3, Void >, public ActorCallback< _executeActor6, 4, Optional<Value> >, public ActorCallback< _executeActor6, 5, RangeResult >, public ActorCallback< _executeActor6, 6, Void >, public ActorCallback< _executeActor6, 7, Void >, public FastAllocated<_executeActor6>, public _executeActor6State<_executeActor6> {
															#line 16945 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor6>::operator new;
	using FastAllocated<_executeActor6>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor6, 0, Void >;
friend struct ActorCallback< _executeActor6, 1, Void >;
friend struct ActorCallback< _executeActor6, 2, Optional<Key> >;
friend struct ActorCallback< _executeActor6, 3, Void >;
friend struct ActorCallback< _executeActor6, 4, Optional<Value> >;
friend struct ActorCallback< _executeActor6, 5, RangeResult >;
friend struct ActorCallback< _executeActor6, 6, Void >;
friend struct ActorCallback< _executeActor6, 7, Void >;
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor6(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 16963 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor6State<_executeActor6>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor6, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor6, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _executeActor6, 2, Optional<Key> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _executeActor6, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _executeActor6, 4, Optional<Value> >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< _executeActor6, 5, RangeResult >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< _executeActor6, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< _executeActor6, 7, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor6(cx, taskBucket, futureBucket, task));
															#line 16997 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1878 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 17002 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor10>
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor10State {
															#line 17008 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor10State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task)
															#line 17021 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor10State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(tr, task, CopyDiffLogsUpgradeTaskFunc::name, CopyDiffLogsUpgradeTaskFunc::version);
															#line 1883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17038 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor10*>(this)->actor_wait_state = 1;
															#line 1883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor10, 0, Void >*>(static_cast<_finishActor10*>(this)));
															#line 17043 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor10State();
		static_cast<_finishActor10*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		onDone = futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]);
															#line 1886 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (task->params[BackupAgentBase::destUid].size() == 0)
															#line 17068 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1887 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_CopyDiffLogsUpgradeTaskFuncAbortInUpgrade").log();
															#line 1888 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_1 = success(AbortOldBackupTaskFunc::addTask(tr, taskBucket, task, TaskCompletionKey::signal(onDone)));
															#line 1888 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17076 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<_finishActor10*>(this)->actor_wait_state = 2;
															#line 1888 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor10, 1, Void >*>(static_cast<_finishActor10*>(this)));
															#line 17081 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 1890 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Subspace config = Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[DatabaseBackupAgent::keyConfigLogUid]);
															#line 1895 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(config.pack(BackupAgentBase::destUid), task->params[BackupAgentBase::destUid]);
															#line 1896 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(config.pack(BackupAgentBase::keyDrVersion), BinaryWriter::toValue(DatabaseBackupAgent::LATEST_DR_VERSION, Unversioned()));
															#line 1898 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_2 = success(CopyDiffLogsTaskFunc::addTask( tr, taskBucket, task, 0, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1898 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17098 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when2(__when_expr_2.get(), loopDepth); };
			static_cast<_finishActor10*>(this)->actor_wait_state = 3;
															#line 1898 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor10, 2, Void >*>(static_cast<_finishActor10*>(this)));
															#line 17103 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		onDone = futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]);
															#line 1886 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (task->params[BackupAgentBase::destUid].size() == 0)
															#line 17115 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1887 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_CopyDiffLogsUpgradeTaskFuncAbortInUpgrade").log();
															#line 1888 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_1 = success(AbortOldBackupTaskFunc::addTask(tr, taskBucket, task, TaskCompletionKey::signal(onDone)));
															#line 1888 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
			static_cast<_finishActor10*>(this)->actor_wait_state = 2;
															#line 1888 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor10, 1, Void >*>(static_cast<_finishActor10*>(this)));
															#line 17128 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 1890 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version beginVersion = BinaryReader::fromStringRef<Version>(task->params[DatabaseBackupAgent::keyBeginVersion], Unversioned());
															#line 1892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Subspace config = Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[DatabaseBackupAgent::keyConfigLogUid]);
															#line 1895 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(config.pack(BackupAgentBase::destUid), task->params[BackupAgentBase::destUid]);
															#line 1896 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(config.pack(BackupAgentBase::keyDrVersion), BinaryWriter::toValue(DatabaseBackupAgent::LATEST_DR_VERSION, Unversioned()));
															#line 1898 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_2 = success(CopyDiffLogsTaskFunc::addTask( tr, taskBucket, task, 0, beginVersion, TaskCompletionKey::signal(onDone)));
															#line 1898 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17145 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1when2(__when_expr_2.get(), loopDepth); };
			static_cast<_finishActor10*>(this)->actor_wait_state = 3;
															#line 1898 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor10, 2, Void >*>(static_cast<_finishActor10*>(this)));
															#line 17150 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor10*>(this)->actor_wait_state > 0) static_cast<_finishActor10*>(this)->actor_wait_state = 0;
		static_cast<_finishActor10*>(this)->ActorCallback< _finishActor10, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor10, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor10, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor10, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 1902 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = taskBucket->finish(tr, task);
															#line 1902 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17225 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont2when1(__when_expr_3.get(), loopDepth); };
		static_cast<_finishActor10*>(this)->actor_wait_state = 4;
															#line 1902 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor10, 3, Void >*>(static_cast<_finishActor10*>(this)));
															#line 17230 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor10*>(this)->actor_wait_state > 0) static_cast<_finishActor10*>(this)->actor_wait_state = 0;
		static_cast<_finishActor10*>(this)->ActorCallback< _finishActor10, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor10, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor10, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor10, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor10*>(this)->actor_wait_state > 0) static_cast<_finishActor10*>(this)->actor_wait_state = 0;
		static_cast<_finishActor10*>(this)->ActorCallback< _finishActor10, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor10, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor10, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor10, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
															#line 1903 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor10*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor10State(); static_cast<_finishActor10*>(this)->destroy(); return 0; }
															#line 17389 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor10*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor10State();
		static_cast<_finishActor10*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
															#line 1903 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor10*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor10State(); static_cast<_finishActor10*>(this)->destroy(); return 0; }
															#line 17401 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor10*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor10State();
		static_cast<_finishActor10*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_finishActor10*>(this)->actor_wait_state > 0) static_cast<_finishActor10*>(this)->actor_wait_state = 0;
		static_cast<_finishActor10*>(this)->ActorCallback< _finishActor10, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor10, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _finishActor10, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _finishActor10, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> onDone;
															#line 17482 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor10 final : public Actor<Void>, public ActorCallback< _finishActor10, 0, Void >, public ActorCallback< _finishActor10, 1, Void >, public ActorCallback< _finishActor10, 2, Void >, public ActorCallback< _finishActor10, 3, Void >, public FastAllocated<_finishActor10>, public _finishActor10State<_finishActor10> {
															#line 17487 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor10>::operator new;
	using FastAllocated<_finishActor10>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor10, 0, Void >;
friend struct ActorCallback< _finishActor10, 1, Void >;
friend struct ActorCallback< _finishActor10, 2, Void >;
friend struct ActorCallback< _finishActor10, 3, Void >;
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor10(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 17501 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor10State<_finishActor10>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor10, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor10, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor10, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _finishActor10, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor10(tr, taskBucket, futureBucket, task));
															#line 17531 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1905 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef CopyDiffLogsUpgradeTaskFunc::name = LiteralStringRef("db_copy_diff_logs");
REGISTER_TASKFUNC(CopyDiffLogsUpgradeTaskFunc);

struct BackupRestorableTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 17558 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor7>
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor7State {
															#line 17564 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor7State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1932 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   sourceStates(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keySourceStates) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 17579 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor7State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1935 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, BackupRestorableTaskFunc::name, BackupRestorableTaskFunc::version);
															#line 1935 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor7*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 17596 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor7*>(this)->actor_wait_state = 1;
															#line 1935 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor7, 0, Void >*>(static_cast<_executeActor7*>(this)));
															#line 17601 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor7State();
		static_cast<_executeActor7*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1936 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Transaction(taskBucket->src);
															#line 1937 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 17626 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1936 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Transaction(taskBucket->src);
															#line 1937 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 17637 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor7*>(this)->actor_wait_state > 0) static_cast<_executeActor7*>(this)->actor_wait_state = 0;
		static_cast<_executeActor7*>(this)->ActorCallback< _executeActor7, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor7, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor7, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor7, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
		try {
															#line 1939 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 1940 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr.addReadConflictRange(singleKeyRange(sourceStates.pack(DatabaseBackupAgent::keyStateStatus)));
															#line 1941 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr.set(sourceStates.pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_RUNNING_DIFFERENTIAL)));
															#line 1944 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Key versionKey = task->params[DatabaseBackupAgent::keyConfigLogUid] .withPrefix(task->params[BackupAgentBase::destUid]) .withPrefix(backupLatestVersionsPrefix);
															#line 1947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Key>> __when_expr_1 = tr.get(versionKey);
															#line 1947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor7*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 17727 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<_executeActor7*>(this)->actor_wait_state = 2;
															#line 1947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor7, 1, Optional<Key> >*>(static_cast<_executeActor7*>(this)));
															#line 17732 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 1957 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = tr.onError(e);
															#line 1957 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor7*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 17756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_3.get(), loopDepth); };
			static_cast<_executeActor7*>(this)->actor_wait_state = 4;
															#line 1957 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor7, 3, Void >*>(static_cast<_executeActor7*>(this)));
															#line 17761 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Optional<Key> const& prevBeginVersion,int loopDepth) 
	{
															#line 1948 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!prevBeginVersion.present())
															#line 17776 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1949 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor7*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor7State(); static_cast<_executeActor7*>(this)->destroy(); return 0; }
															#line 17780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor7*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor7State();
			static_cast<_executeActor7*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1952 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyPrevBeginVersion] = prevBeginVersion.get();
															#line 1954 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr.commit();
															#line 1954 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor7*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 17792 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor7*>(this)->actor_wait_state = 3;
															#line 1954 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor7, 2, Void >*>(static_cast<_executeActor7*>(this)));
															#line 17797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Optional<Key> && prevBeginVersion,int loopDepth) 
	{
															#line 1948 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!prevBeginVersion.present())
															#line 17806 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1949 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor7*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor7State(); static_cast<_executeActor7*>(this)->destroy(); return 0; }
															#line 17810 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor7*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor7State();
			static_cast<_executeActor7*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 1952 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyPrevBeginVersion] = prevBeginVersion.get();
															#line 1954 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr.commit();
															#line 1954 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor7*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 17822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor7*>(this)->actor_wait_state = 3;
															#line 1954 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor7, 2, Void >*>(static_cast<_executeActor7*>(this)));
															#line 17827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Key> const& prevBeginVersion,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(prevBeginVersion, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Key> && prevBeginVersion,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(std::move(prevBeginVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor7*>(this)->actor_wait_state > 0) static_cast<_executeActor7*>(this)->actor_wait_state = 0;
		static_cast<_executeActor7*>(this)->ActorCallback< _executeActor7, 1, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor7, 1, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor7, 1, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor7, 1, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 1955 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor7*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor7State(); static_cast<_executeActor7*>(this)->destroy(); return 0; }
															#line 17899 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor7*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor7State();
		static_cast<_executeActor7*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 1955 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor7*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor7State(); static_cast<_executeActor7*>(this)->destroy(); return 0; }
															#line 17911 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor7*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor7State();
		static_cast<_executeActor7*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_executeActor7*>(this)->actor_wait_state > 0) static_cast<_executeActor7*>(this)->actor_wait_state = 0;
		static_cast<_executeActor7*>(this)->ActorCallback< _executeActor7, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor7, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _executeActor7, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _executeActor7, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_executeActor7*>(this)->actor_wait_state > 0) static_cast<_executeActor7*>(this)->actor_wait_state = 0;
		static_cast<_executeActor7*>(this)->ActorCallback< _executeActor7, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor7, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _executeActor7, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _executeActor7, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1932 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace sourceStates;
															#line 1936 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Transaction tr;
															#line 18069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor7 final : public Actor<Void>, public ActorCallback< _executeActor7, 0, Void >, public ActorCallback< _executeActor7, 1, Optional<Key> >, public ActorCallback< _executeActor7, 2, Void >, public ActorCallback< _executeActor7, 3, Void >, public FastAllocated<_executeActor7>, public _executeActor7State<_executeActor7> {
															#line 18074 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor7>::operator new;
	using FastAllocated<_executeActor7>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor7, 0, Void >;
friend struct ActorCallback< _executeActor7, 1, Optional<Key> >;
friend struct ActorCallback< _executeActor7, 2, Void >;
friend struct ActorCallback< _executeActor7, 3, Void >;
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor7(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 18088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor7State<_executeActor7>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor7, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor7, 1, Optional<Key> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _executeActor7, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _executeActor7, 3, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor7(cx, taskBucket, futureBucket, task));
															#line 18118 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 1961 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 18123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor11>
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor11State {
															#line 18129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor11State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 1966 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   conf(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(task->params[BackupAgentBase::keyConfigLogUid])),
															#line 1969 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   states(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyStates) .get(task->params[BackupAgentBase::keyConfigLogUid]))
															#line 18146 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor11State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 1972 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(tr, task, BackupRestorableTaskFunc::name, BackupRestorableTaskFunc::version);
															#line 1972 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18163 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_finishActor11*>(this)->actor_wait_state = 1;
															#line 1972 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 0, Void >*>(static_cast<_finishActor11*>(this)));
															#line 18168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor11State();
		static_cast<_finishActor11*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 1974 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		onDone = futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]);
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_1 = tr->get(states.pack(DatabaseBackupAgent::keyStateStop));
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18195 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor11*>(this)->actor_wait_state = 2;
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 1, Optional<Value> >*>(static_cast<_finishActor11*>(this)));
															#line 18200 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 1974 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		onDone = futureBucket->unpack(task->params[Task::reservedTaskParamKeyDone]);
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_1 = tr->get(states.pack(DatabaseBackupAgent::keyStateStop));
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18213 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor11*>(this)->actor_wait_state = 2;
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 1, Optional<Value> >*>(static_cast<_finishActor11*>(this)));
															#line 18218 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor11*>(this)->actor_wait_state > 0) static_cast<_finishActor11*>(this)->actor_wait_state = 0;
		static_cast<_finishActor11*>(this)->ActorCallback< _finishActor11, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor11, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor11, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor11, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 1977 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		restoreVersion = stopValue.present() ? BinaryReader::fromStringRef<Version>(stopValue.get(), Unversioned()) : -1;
															#line 1980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_2 = tr->get(conf.pack(DatabaseBackupAgent::keyConfigStopWhenDoneKey));
															#line 1980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_finishActor11*>(this)->actor_wait_state = 3;
															#line 1980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 2, Optional<Value> >*>(static_cast<_finishActor11*>(this)));
															#line 18299 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(Optional<Value> const& __stopValue,int loopDepth) 
	{
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		stopValue = __stopValue;
															#line 18308 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Optional<Value> && __stopValue,int loopDepth) 
	{
		stopValue = std::move(__stopValue);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor11*>(this)->actor_wait_state > 0) static_cast<_finishActor11*>(this)->actor_wait_state = 0;
		static_cast<_finishActor11*>(this)->ActorCallback< _finishActor11, 1, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor11, 1, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor11, 1, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor11, 1, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 1981 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		allPartsDone = Reference<TaskFuture>();
															#line 1983 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_Complete") .detail("RestoreVersion", restoreVersion) .detail("Differential", stopWhenDone.present()) .detail("LogUID", task->params[BackupAgentBase::keyConfigLogUid]);
															#line 1989 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (stopWhenDone.present())
															#line 18379 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 1991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = success(FinishedFullBackupTaskFunc::addTask(tr, taskBucket, task, TaskCompletionKey::noSignal()));
															#line 1991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18385 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont3when1(__when_expr_3.get(), loopDepth); };
			static_cast<_finishActor11*>(this)->actor_wait_state = 4;
															#line 1991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 3, Void >*>(static_cast<_finishActor11*>(this)));
															#line 18390 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 1993 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(states.pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_RUNNING_DIFFERENTIAL)));
															#line 1996 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			allPartsDone = futureBucket->future(tr);
															#line 1998 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version prevBeginVersion = BinaryReader::fromStringRef<Version>( task->params[DatabaseBackupAgent::keyPrevBeginVersion], Unversioned());
															#line 2000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = success(CopyDiffLogsTaskFunc::addTask( tr, taskBucket, task, prevBeginVersion, restoreVersion, TaskCompletionKey::joinWith(allPartsDone)));
															#line 2000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18405 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont3when2(__when_expr_4.get(), loopDepth); };
			static_cast<_finishActor11*>(this)->actor_wait_state = 5;
															#line 2000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 4, Void >*>(static_cast<_finishActor11*>(this)));
															#line 18410 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont2when1(Optional<Value> const& __stopWhenDone,int loopDepth) 
	{
															#line 1980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		stopWhenDone = __stopWhenDone;
															#line 18420 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Optional<Value> && __stopWhenDone,int loopDepth) 
	{
		stopWhenDone = std::move(__stopWhenDone);
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor11*>(this)->actor_wait_state > 0) static_cast<_finishActor11*>(this)->actor_wait_state = 0;
		static_cast<_finishActor11*>(this)->ActorCallback< _finishActor11, 2, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor11, 2, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor11, 2, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor11, 2, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont4(int loopDepth) 
	{
															#line 2008 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = taskBucket->finish(tr, task);
															#line 2008 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18489 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont4when1(__when_expr_6.get(), loopDepth); };
		static_cast<_finishActor11*>(this)->actor_wait_state = 7;
															#line 2008 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 6, Void >*>(static_cast<_finishActor11*>(this)));
															#line 18494 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_finishActor11*>(this)->actor_wait_state > 0) static_cast<_finishActor11*>(this)->actor_wait_state = 0;
		static_cast<_finishActor11*>(this)->ActorCallback< _finishActor11, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor11, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _finishActor11, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _finishActor11, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont6(Void const& _,int loopDepth) 
	{
															#line 2004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_5 = success(FinishedFullBackupTaskFunc::addTask( tr, taskBucket, task, TaskCompletionKey::noSignal(), allPartsDone));
															#line 2004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18580 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont6when1(__when_expr_5.get(), loopDepth); };
		static_cast<_finishActor11*>(this)->actor_wait_state = 6;
															#line 2004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 5, Void >*>(static_cast<_finishActor11*>(this)));
															#line 18585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont6(Void && _,int loopDepth) 
	{
															#line 2004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_5 = success(FinishedFullBackupTaskFunc::addTask( tr, taskBucket, task, TaskCompletionKey::noSignal(), allPartsDone));
															#line 2004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor11*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18596 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont6when1(__when_expr_5.get(), loopDepth); };
		static_cast<_finishActor11*>(this)->actor_wait_state = 6;
															#line 2004 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _finishActor11, 5, Void >*>(static_cast<_finishActor11*>(this)));
															#line 18601 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_finishActor11*>(this)->actor_wait_state > 0) static_cast<_finishActor11*>(this)->actor_wait_state = 0;
		static_cast<_finishActor11*>(this)->ActorCallback< _finishActor11, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor11, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _finishActor11, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _finishActor11, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont7(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont7(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<_finishActor11*>(this)->actor_wait_state > 0) static_cast<_finishActor11*>(this)->actor_wait_state = 0;
		static_cast<_finishActor11*>(this)->ActorCallback< _finishActor11, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor11, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont6when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< _finishActor11, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont6when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< _finishActor11, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont8(Void const& _,int loopDepth) 
	{
															#line 2009 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor11*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor11State(); static_cast<_finishActor11*>(this)->destroy(); return 0; }
															#line 18748 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor11*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor11State();
		static_cast<_finishActor11*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont8(Void && _,int loopDepth) 
	{
															#line 2009 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor11*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor11State(); static_cast<_finishActor11*>(this)->destroy(); return 0; }
															#line 18760 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor11*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor11State();
		static_cast<_finishActor11*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont8(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont8(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<_finishActor11*>(this)->actor_wait_state > 0) static_cast<_finishActor11*>(this)->actor_wait_state = 0;
		static_cast<_finishActor11*>(this)->ActorCallback< _finishActor11, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor11, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< _finishActor11, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< _finishActor11, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 6);

	}
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 1966 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace conf;
															#line 1969 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace states;
															#line 1974 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> onDone;
															#line 1976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> stopValue;
															#line 1977 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version restoreVersion;
															#line 1980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> stopWhenDone;
															#line 1981 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> allPartsDone;
															#line 18853 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor11 final : public Actor<Void>, public ActorCallback< _finishActor11, 0, Void >, public ActorCallback< _finishActor11, 1, Optional<Value> >, public ActorCallback< _finishActor11, 2, Optional<Value> >, public ActorCallback< _finishActor11, 3, Void >, public ActorCallback< _finishActor11, 4, Void >, public ActorCallback< _finishActor11, 5, Void >, public ActorCallback< _finishActor11, 6, Void >, public FastAllocated<_finishActor11>, public _finishActor11State<_finishActor11> {
															#line 18858 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor11>::operator new;
	using FastAllocated<_finishActor11>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor11, 0, Void >;
friend struct ActorCallback< _finishActor11, 1, Optional<Value> >;
friend struct ActorCallback< _finishActor11, 2, Optional<Value> >;
friend struct ActorCallback< _finishActor11, 3, Void >;
friend struct ActorCallback< _finishActor11, 4, Void >;
friend struct ActorCallback< _finishActor11, 5, Void >;
friend struct ActorCallback< _finishActor11, 6, Void >;
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor11(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 18875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor11State<_finishActor11>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor11, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor11, 1, Optional<Value> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor11, 2, Optional<Value> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _finishActor11, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _finishActor11, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< _finishActor11, 5, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< _finishActor11, 6, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 1962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor11(tr, taskBucket, futureBucket, task));
															#line 18908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2011 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 18913 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor9>
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor9State {
															#line 18919 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor9State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   parentTask(parentTask),
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor)
															#line 18934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor9State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 2017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor9*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18951 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor9*>(this)->actor_wait_state = 1;
															#line 2017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor9, 0, Key >*>(static_cast<AddTaskActor9*>(this)));
															#line 18956 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor9State();
		static_cast<AddTaskActor9*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 2018 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(BackupRestorableTaskFunc::name, BackupRestorableTaskFunc::version, doneKey);
															#line 2020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 2022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 18983 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2023 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor9*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor9State(); static_cast<AddTaskActor9*>(this)->destroy(); return 0; }
															#line 18987 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor9*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor9State();
			static_cast<AddTaskActor9*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 2029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor9*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 18997 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor9*>(this)->actor_wait_state = 2;
															#line 2029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor9, 1, Void >*>(static_cast<AddTaskActor9*>(this)));
															#line 19002 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 2018 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(BackupRestorableTaskFunc::name, BackupRestorableTaskFunc::version, doneKey);
															#line 2020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		copyDefaultParameters(parentTask, task);
															#line 2022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 19015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2023 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor9*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor9State(); static_cast<AddTaskActor9*>(this)->destroy(); return 0; }
															#line 19019 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor9*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor9State();
			static_cast<AddTaskActor9*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, parentTask->params[Task::reservedTaskParamValidKey], task->params[BackupAgentBase::keyFolderId]);
															#line 2029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor9*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 19029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor9*>(this)->actor_wait_state = 2;
															#line 2029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor9, 1, Void >*>(static_cast<AddTaskActor9*>(this)));
															#line 19034 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor9*>(this)->actor_wait_state > 0) static_cast<AddTaskActor9*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor9*>(this)->ActorCallback< AddTaskActor9, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor9, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor9, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor9, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 2034 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor9*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor9State(); static_cast<AddTaskActor9*>(this)->destroy(); return 0; }
															#line 19106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor9*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor9State();
		static_cast<AddTaskActor9*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 2034 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor9*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor9State(); static_cast<AddTaskActor9*>(this)->destroy(); return 0; }
															#line 19118 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor9*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor9State();
		static_cast<AddTaskActor9*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor9*>(this)->actor_wait_state > 0) static_cast<AddTaskActor9*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor9*>(this)->ActorCallback< AddTaskActor9, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor9, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor9, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor9, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> parentTask;
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 19199 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor9 final : public Actor<Key>, public ActorCallback< AddTaskActor9, 0, Key >, public ActorCallback< AddTaskActor9, 1, Void >, public FastAllocated<AddTaskActor9>, public AddTaskActor9State<AddTaskActor9> {
															#line 19204 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor9>::operator new;
	using FastAllocated<AddTaskActor9>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor9, 0, Key >;
friend struct ActorCallback< AddTaskActor9, 1, Void >;
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor9(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<Task> const& parentTask,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>()) 
															#line 19216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor9State<AddTaskActor9>(tr, taskBucket, parentTask, completionKey, waitFor)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor9, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor9, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<Task> const& parentTask, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>() ) {
															#line 2012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor9(tr, taskBucket, parentTask, completionKey, waitFor));
															#line 19244 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2036 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef BackupRestorableTaskFunc::name = LiteralStringRef("dr_backup_restorable");
REGISTER_TASKFUNC(BackupRestorableTaskFunc);

struct StartFullBackupTaskFunc : TaskFuncBase {
	static StringRef name;
	static constexpr uint32_t version = 1;

																#line 19271 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _execute()
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _executeActor8>
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor8State {
															#line 19277 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor8State(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : cx(cx),
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 2063 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUidValue(task->params[DatabaseBackupAgent::keyConfigLogUid]),
															#line 2064 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   sourceStates(Subspace(databaseBackupPrefixRange.begin).get(BackupAgentBase::keySourceStates).get(logUidValue))
															#line 19294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_execute", reinterpret_cast<unsigned long>(this));

	}
	~_executeActor8State() 
	{
		fdb_probe_actor_destroy("_execute", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2066 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = checkTaskVersion(cx, task, StartFullBackupTaskFunc::name, StartFullBackupTaskFunc::version);
															#line 2066 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 19311 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 1;
															#line 2066 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 0, Void >*>(static_cast<_executeActor8*>(this)));
															#line 19316 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_executeActor8State();
		static_cast<_executeActor8*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Void const& _,int loopDepth) 
	{
															#line 2067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destUidValue = Key(logUidValue);
															#line 2069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = BinaryReader::fromStringRef<Standalone<VectorRef<KeyRangeRef>>>( task->params[DatabaseBackupAgent::keyConfigBackupRanges], IncludeVersion());
															#line 2072 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersionKey = Key();
															#line 2074 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 2075 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 19347 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1(Void && _,int loopDepth) 
	{
															#line 2067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destUidValue = Key(logUidValue);
															#line 2069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = BinaryReader::fromStringRef<Standalone<VectorRef<KeyRangeRef>>>( task->params[DatabaseBackupAgent::keyConfigBackupRanges], IncludeVersion());
															#line 2072 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersionKey = Key();
															#line 2074 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 2075 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 19364 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _executeActor8, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 2120 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 19436 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
		try {
															#line 2077 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2078 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2081 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (backupRanges.size() == 1)
															#line 19457 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2082 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				StrictFuture<RangeResult> __when_expr_1 = srcTr->getRange( KeyRangeRef(destUidLookupPrefix, strinc(destUidLookupPrefix)), CLIENT_KNOBS->TOO_MANY);
															#line 2082 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 19463 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
				static_cast<_executeActor8*>(this)->actor_wait_state = 2;
															#line 2082 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 1, RangeResult >*>(static_cast<_executeActor8*>(this)));
															#line 19468 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = 0;
			}
			else
			{
				loopDepth = a_body1cont1loopBody1cont2(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2116 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_5 = srcTr->onError(e);
															#line 2116 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 19510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_5.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 6;
															#line 2116 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 5, Void >*>(static_cast<_executeActor8*>(this)));
															#line 19515 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(int loopDepth) 
	{
															#line 2102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Version> __when_expr_2 = srcTr->getReadVersion();
															#line 2102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 19532 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 3;
															#line 2102 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 2, Version >*>(static_cast<_executeActor8*>(this)));
															#line 19537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(RangeResult const& existingDestUidValues,int loopDepth) 
	{
															#line 2084 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool found = false;
															#line 2085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto it : existingDestUidValues ) {
															#line 2086 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (BinaryReader::fromStringRef<KeyRange>(it.key.removePrefix(destUidLookupPrefix), IncludeVersion()) == backupRanges[0])
															#line 19550 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				destUidValue = it.value;
															#line 2089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				found = true;
															#line 19556 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				break;
			}
		}
															#line 2093 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!found)
															#line 19562 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2094 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			destUidValue = BinaryWriter::toValue(deterministicRandom()->randomUniqueID(), Unversioned());
															#line 2095 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(BinaryWriter::toValue(backupRanges[0], IncludeVersion(ProtocolVersion::withSharedMutations())) .withPrefix(destUidLookupPrefix), destUidValue);
															#line 19568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(RangeResult && existingDestUidValues,int loopDepth) 
	{
															#line 2084 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bool found = false;
															#line 2085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto it : existingDestUidValues ) {
															#line 2086 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (BinaryReader::fromStringRef<KeyRange>(it.key.removePrefix(destUidLookupPrefix), IncludeVersion()) == backupRanges[0])
															#line 19582 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2088 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				destUidValue = it.value;
															#line 2089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				found = true;
															#line 19588 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				break;
			}
		}
															#line 2093 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!found)
															#line 19594 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2094 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			destUidValue = BinaryWriter::toValue(deterministicRandom()->randomUniqueID(), Unversioned());
															#line 2095 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(BinaryWriter::toValue(backupRanges[0], IncludeVersion(ProtocolVersion::withSharedMutations())) .withPrefix(destUidLookupPrefix), destUidValue);
															#line 19600 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(RangeResult const& existingDestUidValues,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(existingDestUidValues, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(RangeResult && existingDestUidValues,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(existingDestUidValues), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 1, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 1, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 1, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _executeActor8, 1, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont8(Version const& bVersion,int loopDepth) 
	{
															#line 2103 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersionKey = BinaryWriter::toValue(bVersion, Unversioned());
															#line 2105 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		versionKey = logUidValue.withPrefix(destUidValue).withPrefix(backupLatestVersionsPrefix);
															#line 2106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_3 = srcTr->get(versionKey);
															#line 2106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 19679 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont8when1(__when_expr_3.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 4;
															#line 2106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 3, Optional<Key> >*>(static_cast<_executeActor8*>(this)));
															#line 19684 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont8(Version && bVersion,int loopDepth) 
	{
															#line 2103 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		beginVersionKey = BinaryWriter::toValue(bVersion, Unversioned());
															#line 2105 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		versionKey = logUidValue.withPrefix(destUidValue).withPrefix(backupLatestVersionsPrefix);
															#line 2106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_3 = srcTr->get(versionKey);
															#line 2106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 19699 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont8when1(__when_expr_3.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 4;
															#line 2106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 3, Optional<Key> >*>(static_cast<_executeActor8*>(this)));
															#line 19704 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Version const& bVersion,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont8(bVersion, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Version && bVersion,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont8(std::move(bVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 2, Version >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 2, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 2, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _executeActor8, 2, Version >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1cont9(Optional<Key> const& versionRecord,int loopDepth) 
	{
															#line 2107 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!versionRecord.present())
															#line 19776 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2108 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(versionKey, beginVersionKey);
															#line 19780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2111 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::destUid] = destUidValue;
															#line 2113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = srcTr->commit();
															#line 2113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 19788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1cont1loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont1loopBody1cont9when1(__when_expr_4.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 5;
															#line 2113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 4, Void >*>(static_cast<_executeActor8*>(this)));
															#line 19793 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont9(Optional<Key> && versionRecord,int loopDepth) 
	{
															#line 2107 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!versionRecord.present())
															#line 19802 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2108 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(versionKey, beginVersionKey);
															#line 19806 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2111 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::destUid] = destUidValue;
															#line 2113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = srcTr->commit();
															#line 2113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 19814 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1cont1loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont1loopBody1cont9when1(__when_expr_4.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 5;
															#line 2113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 4, Void >*>(static_cast<_executeActor8*>(this)));
															#line 19819 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont8when1(Optional<Key> const& versionRecord,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont9(versionRecord, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont8when1(Optional<Key> && versionRecord,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont9(std::move(versionRecord), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 3, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 3, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont8when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 3, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont8when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _executeActor8, 3, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1cont10(Void const& _,int loopDepth) 
	{
		return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont10(Void && _,int loopDepth) 
	{
		return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont9when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont10(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont9when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont10(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont9when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1cont9when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _executeActor8, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< _executeActor8, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 2151 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr2 = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 2152 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 20043 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont3loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1(int loopDepth) 
	{
															#line 2121 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(cx));
															#line 20059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		try {
															#line 2123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2125 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			verified = taskBucket->keepRunning(tr, task);
															#line 2126 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_6 = verified;
															#line 2126 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20071 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont2loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont2loopBody1when1(__when_expr_6.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 7;
															#line 2126 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 6, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20076 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont2loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont2loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2break1(int loopDepth) 
	{
		try {
			return a_body1cont3(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2146 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("SetDestUidOrBeginVersionError").errorUnsuppressed(e);
															#line 2147 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_9 = tr->onError(e);
															#line 2147 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 20115 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1Catch1(__when_expr_9.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1Catch1when1(__when_expr_9.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 10;
															#line 2147 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 9, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20120 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 2129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		config = Subspace(databaseBackupPrefixRange.begin).get(BackupAgentBase::keyConfig).get(logUidValue);
															#line 2131 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(config.pack(BackupAgentBase::destUid), task->params[BackupAgentBase::destUid]);
															#line 2134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_7 = tr->get(config.pack(BackupAgentBase::backupStartVersion));
															#line 2134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20141 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1cont2loopBody1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_7.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 8;
															#line 2134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 7, Optional<Key> >*>(static_cast<_executeActor8*>(this)));
															#line 20146 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 2129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		config = Subspace(databaseBackupPrefixRange.begin).get(BackupAgentBase::keyConfig).get(logUidValue);
															#line 2131 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(config.pack(BackupAgentBase::destUid), task->params[BackupAgentBase::destUid]);
															#line 2134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_7 = tr->get(config.pack(BackupAgentBase::backupStartVersion));
															#line 2134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20161 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1cont2loopBody1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_7.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 8;
															#line 2134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 7, Optional<Key> >*>(static_cast<_executeActor8*>(this)));
															#line 20166 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< _executeActor8, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont2loopBody1cont3(Optional<Key> const& backupStartVersion,int loopDepth) 
	{
															#line 2135 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupStartVersion.present())
															#line 20238 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2136 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			beginVersionKey = backupStartVersion.get();
															#line 20242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
															#line 2138 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(config.pack(BackupAgentBase::backupStartVersion), beginVersionKey);
															#line 20248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2141 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyBeginVersion] = beginVersionKey;
															#line 2143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_8 = tr->commit();
															#line 2143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20256 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1cont2loopBody1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont2loopBody1cont3when1(__when_expr_8.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 9;
															#line 2143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 8, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20261 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3(Optional<Key> && backupStartVersion,int loopDepth) 
	{
															#line 2135 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupStartVersion.present())
															#line 20270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2136 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			beginVersionKey = backupStartVersion.get();
															#line 20274 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
															#line 2138 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(config.pack(BackupAgentBase::backupStartVersion), beginVersionKey);
															#line 20280 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2141 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyBeginVersion] = beginVersionKey;
															#line 2143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_8 = tr->commit();
															#line 2143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20288 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1cont2loopBody1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont2loopBody1cont3when1(__when_expr_8.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 9;
															#line 2143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 8, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20293 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Optional<Key> const& backupStartVersion,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont3(backupStartVersion, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Optional<Key> && backupStartVersion,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont3(std::move(backupStartVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 7, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 7, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 7, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< _executeActor8, 7, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1cont2loopBody1cont4(Void const& _,int loopDepth) 
	{
		return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont2loopBody1cont4(Void && _,int loopDepth) 
	{
		return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 8, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 8, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 8, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< _executeActor8, 8, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 8);

	}
	int a_body1cont2loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose10() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 9, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 9, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont2loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 9, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont2loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_error(ActorCallback< _executeActor8, 9, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 9);

	}
	int a_body1cont4(int loopDepth) 
	{
															#line 2188 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr3 = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(taskBucket->src));
															#line 2189 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 20517 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont4loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont3loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1(int loopDepth) 
	{
		try {
															#line 2154 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr2->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2155 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr2->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2157 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_10 = srcTr2->get(sourceStates.pack(DatabaseBackupAgent::keyFolderId));
															#line 2157 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20540 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1cont3loopBody1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1cont3loopBody1when1(__when_expr_10.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 11;
															#line 2157 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 10, Optional<Value> >*>(static_cast<_executeActor8*>(this)));
															#line 20545 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont3loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont3loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3break1(int loopDepth) 
	{
		try {
			return a_body1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2184 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_12 = srcTr2->onError(e);
															#line 2184 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 20582 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_12.isReady()) { if (__when_expr_12.isError()) return a_body1Catch1(__when_expr_12.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1Catch1when1(__when_expr_12.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 13;
															#line 2184 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_12.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 12, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20587 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2(int loopDepth) 
	{
															#line 2159 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present() && BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) >= BinaryReader::fromStringRef<Version>( task->params[DatabaseBackupAgent::keyFolderId], Unversioned()))
															#line 20602 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2162 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<_executeActor8*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor8State(); static_cast<_executeActor8*>(this)->destroy(); return 0; }
															#line 20606 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<_executeActor8*>(this)->SAV< Void >::value()) Void(Void());
			this->~_executeActor8State();
			static_cast<_executeActor8*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2164 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr2->set(Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keySourceTagName) .pack(task->params[BackupAgentBase::keyTagName]), logUidValue);
															#line 2168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr2->set(sourceStates.pack(DatabaseBackupAgent::keyFolderId), task->params[DatabaseBackupAgent::keyFolderId]);
															#line 2170 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr2->set(sourceStates.pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_RUNNING)));
															#line 2173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destPath = destUidValue.withPrefix(backupLogKeys.begin);
															#line 2175 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto& backupRange : backupRanges ) {
															#line 2176 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr2->set(logRangesEncodeKey(backupRange.begin, BinaryReader::fromStringRef<UID>(destUidValue, Unversioned())), logRangesEncodeValue(backupRange.end, destPath));
															#line 20624 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_11 = srcTr2->commit();
															#line 2181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20630 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_11.isReady()) { if (__when_expr_11.isError()) return a_body1cont3loopBody1Catch1(__when_expr_11.getError(), loopDepth); else return a_body1cont3loopBody1cont2when1(__when_expr_11.get(), loopDepth); };
		static_cast<_executeActor8*>(this)->actor_wait_state = 12;
															#line 2181 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_11.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 11, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1when1(Optional<Value> const& __v,int loopDepth) 
	{
															#line 2157 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		v = __v;
															#line 20644 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont3loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1when1(Optional<Value> && __v,int loopDepth) 
	{
		v = std::move(__v);
		loopDepth = a_body1cont3loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose11() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 10, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 10, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont3loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 10, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont3loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_error(ActorCallback< _executeActor8, 10, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont3loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 10);

	}
	int a_body1cont3loopBody1cont3(Void const& _,int loopDepth) 
	{
		return a_body1cont3break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont3loopBody1cont3(Void && _,int loopDepth) 
	{
		return a_body1cont3break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose12() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 11, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 11, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont3loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 11, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont3loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_error(ActorCallback< _executeActor8, 11, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont3loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 11);

	}
	int a_body1cont3loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose13() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 12, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 12, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1cont3loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 12, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1cont3loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_error(ActorCallback< _executeActor8, 12, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 12);

	}
	int a_body1cont5(int loopDepth) 
	{
															#line 2203 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_executeActor8*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_executeActor8State(); static_cast<_executeActor8*>(this)->destroy(); return 0; }
															#line 20861 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_executeActor8*>(this)->SAV< Void >::value()) Void(Void());
		this->~_executeActor8State();
		static_cast<_executeActor8*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont4loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont4loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1(int loopDepth) 
	{
		try {
															#line 2191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr3->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2192 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr3->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2194 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr3->atomicOp(metadataVersionKey, metadataVersionRequiredValue, MutationRef::SetVersionstampedValue);
															#line 2196 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_13 = srcTr3->commit();
															#line 2196 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1cont4loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 20889 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_13.isReady()) { if (__when_expr_13.isError()) return a_body1cont4loopBody1Catch1(__when_expr_13.getError(), loopDepth); else return a_body1cont4loopBody1when1(__when_expr_13.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 14;
															#line 2196 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_13.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 13, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20894 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont4loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont4loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont4break1(int loopDepth) 
	{
		try {
			return a_body1cont5(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont4loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont4loopHead1(0);

		return loopDepth;
	}
	int a_body1cont4loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2199 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_14 = srcTr3->onError(e);
															#line 2199 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<_executeActor8*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 20931 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_14.isReady()) { if (__when_expr_14.isError()) return a_body1Catch1(__when_expr_14.getError(), std::max(0, loopDepth - 1)); else return a_body1cont4loopBody1Catch1when1(__when_expr_14.get(), loopDepth); };
			static_cast<_executeActor8*>(this)->actor_wait_state = 15;
															#line 2199 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_14.addCallbackAndClear(static_cast<ActorCallback< _executeActor8, 14, Void >*>(static_cast<_executeActor8*>(this)));
															#line 20936 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont4loopBody1cont2(Void const& _,int loopDepth) 
	{
		return a_body1cont4break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont4loopBody1cont2(Void && _,int loopDepth) 
	{
		return a_body1cont4break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont4loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose14() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 13, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 13, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont4loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 13);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 13, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont4loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 13);

	}
	void a_callback_error(ActorCallback< _executeActor8, 13, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont4loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 13);

	}
	int a_body1cont4loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont4loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose15() 
	{
		if (static_cast<_executeActor8*>(this)->actor_wait_state > 0) static_cast<_executeActor8*>(this)->actor_wait_state = 0;
		static_cast<_executeActor8*>(this)->ActorCallback< _executeActor8, 14, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _executeActor8, 14, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1cont4loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 14);

	}
	void a_callback_fire(ActorCallback< _executeActor8, 14, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1cont4loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 14);

	}
	void a_callback_error(ActorCallback< _executeActor8, 14, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), 14);

	}
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 2063 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUidValue;
															#line 2064 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace sourceStates;
															#line 2067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key destUidValue;
															#line 2069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> backupRanges;
															#line 2072 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key beginVersionKey;
															#line 2074 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> srcTr;
															#line 2105 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key versionKey;
															#line 2121 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2125 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> verified;
															#line 2129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace config;
															#line 2151 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> srcTr2;
															#line 2157 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> v;
															#line 2173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key destPath;
															#line 2188 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> srcTr3;
															#line 21133 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _execute()
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _executeActor8 final : public Actor<Void>, public ActorCallback< _executeActor8, 0, Void >, public ActorCallback< _executeActor8, 1, RangeResult >, public ActorCallback< _executeActor8, 2, Version >, public ActorCallback< _executeActor8, 3, Optional<Key> >, public ActorCallback< _executeActor8, 4, Void >, public ActorCallback< _executeActor8, 5, Void >, public ActorCallback< _executeActor8, 6, Void >, public ActorCallback< _executeActor8, 7, Optional<Key> >, public ActorCallback< _executeActor8, 8, Void >, public ActorCallback< _executeActor8, 9, Void >, public ActorCallback< _executeActor8, 10, Optional<Value> >, public ActorCallback< _executeActor8, 11, Void >, public ActorCallback< _executeActor8, 12, Void >, public ActorCallback< _executeActor8, 13, Void >, public ActorCallback< _executeActor8, 14, Void >, public FastAllocated<_executeActor8>, public _executeActor8State<_executeActor8> {
															#line 21138 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_executeActor8>::operator new;
	using FastAllocated<_executeActor8>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _executeActor8, 0, Void >;
friend struct ActorCallback< _executeActor8, 1, RangeResult >;
friend struct ActorCallback< _executeActor8, 2, Version >;
friend struct ActorCallback< _executeActor8, 3, Optional<Key> >;
friend struct ActorCallback< _executeActor8, 4, Void >;
friend struct ActorCallback< _executeActor8, 5, Void >;
friend struct ActorCallback< _executeActor8, 6, Void >;
friend struct ActorCallback< _executeActor8, 7, Optional<Key> >;
friend struct ActorCallback< _executeActor8, 8, Void >;
friend struct ActorCallback< _executeActor8, 9, Void >;
friend struct ActorCallback< _executeActor8, 10, Optional<Value> >;
friend struct ActorCallback< _executeActor8, 11, Void >;
friend struct ActorCallback< _executeActor8, 12, Void >;
friend struct ActorCallback< _executeActor8, 13, Void >;
friend struct ActorCallback< _executeActor8, 14, Void >;
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_executeActor8(Database const& cx,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 21163 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _executeActor8State<_executeActor8>(cx, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_execute", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_execute");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_execute", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _executeActor8, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _executeActor8, 1, RangeResult >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _executeActor8, 2, Version >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _executeActor8, 3, Optional<Key> >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _executeActor8, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< _executeActor8, 5, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< _executeActor8, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< _executeActor8, 7, Optional<Key> >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< _executeActor8, 8, Void >*)0, actor_cancelled()); break;
		case 10: this->a_callback_error((ActorCallback< _executeActor8, 9, Void >*)0, actor_cancelled()); break;
		case 11: this->a_callback_error((ActorCallback< _executeActor8, 10, Optional<Value> >*)0, actor_cancelled()); break;
		case 12: this->a_callback_error((ActorCallback< _executeActor8, 11, Void >*)0, actor_cancelled()); break;
		case 13: this->a_callback_error((ActorCallback< _executeActor8, 12, Void >*)0, actor_cancelled()); break;
		case 14: this->a_callback_error((ActorCallback< _executeActor8, 13, Void >*)0, actor_cancelled()); break;
		case 15: this->a_callback_error((ActorCallback< _executeActor8, 14, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _execute( Database const& cx, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 2059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _executeActor8(cx, taskBucket, futureBucket, task));
															#line 21204 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2205 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 21209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via _finish()
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class _finishActor12>
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor12State {
															#line 21215 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor12State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   futureBucket(futureBucket),
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   task(task),
															#line 2210 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUidValue(task->params[BackupAgentBase::keyConfigLogUid]),
															#line 2211 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   states(Subspace(databaseBackupPrefixRange.begin).get(BackupAgentBase::keyStates).get(logUidValue)),
															#line 2213 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   config(Subspace(databaseBackupPrefixRange.begin).get(BackupAgentBase::keyConfig).get(logUidValue)),
															#line 2216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   beginVersion(BinaryReader::fromStringRef<Version>(task->params[BackupAgentBase::keyBeginVersion], Unversioned())),
															#line 2218 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backupRanges(BinaryReader::fromStringRef<Standalone<VectorRef<KeyRangeRef>>>( task->params[DatabaseBackupAgent::keyConfigBackupRanges], IncludeVersion()))
															#line 21238 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("_finish", reinterpret_cast<unsigned long>(this));

	}
	~_finishActor12State() 
	{
		fdb_probe_actor_destroy("_finish", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2222 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(logUidValue.withPrefix(applyMutationsBeginRange.begin), BinaryWriter::toValue(beginVersion, Unversioned()));
															#line 2224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(logUidValue.withPrefix(applyMutationsEndRange.begin), BinaryWriter::toValue(beginVersion, Unversioned()));
															#line 2226 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(states.pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_RUNNING)));
															#line 2229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			kvBackupRangeComplete = futureBucket->future(tr);
															#line 2230 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			kvBackupComplete = futureBucket->future(tr);
															#line 2231 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			rangeCount = 0;
															#line 2233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (task->params[DatabaseBackupAgent::keyDatabasesInSync] != std::string("t"))
															#line 21265 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2234 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				;
															#line 21269 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = a_body1loopHead1(loopDepth);
			}
			else
			{
															#line 2243 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				kvBackupRangeComplete->set(tr, taskBucket);
															#line 21276 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				loopDepth = a_body1cont1(loopDepth);
			}
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~_finishActor12State();
		static_cast<_finishActor12*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = success(FinishFullBackupTaskFunc::addTask( tr, taskBucket, task, TaskCompletionKey::noSignal(), kvBackupRangeComplete));
															#line 2247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21302 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 2;
															#line 2247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 1, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21307 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2(int loopDepth) 
	{
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
															#line 2234 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!(rangeCount < backupRanges.size()))
															#line 21329 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 2235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_0 = success(BackupRangeTaskFunc::addTask(tr, taskBucket, task, backupRanges[rangeCount].begin, backupRanges[rangeCount].end, TaskCompletionKey::joinWith(kvBackupRangeComplete)));
															#line 2235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 21337 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 1;
															#line 2235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 0, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21342 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void const& _,int loopDepth) 
	{
															#line 2234 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		++rangeCount;
															#line 21364 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1cont1(Void && _,int loopDepth) 
	{
															#line 2234 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		++rangeCount;
															#line 21373 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<_finishActor12*>(this)->actor_wait_state > 0) static_cast<_finishActor12*>(this)->actor_wait_state = 0;
		static_cast<_finishActor12*>(this)->ActorCallback< _finishActor12, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor12, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< _finishActor12, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< _finishActor12, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont4(Void const& _,int loopDepth) 
	{
															#line 2251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = success(CopyLogsTaskFunc::addTask( tr, taskBucket, task, 0, beginVersion, TaskCompletionKey::joinWith(kvBackupComplete)));
															#line 2251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21447 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont4when1(__when_expr_2.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 3;
															#line 2251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 2, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4(Void && _,int loopDepth) 
	{
															#line 2251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = success(CopyLogsTaskFunc::addTask( tr, taskBucket, task, 0, beginVersion, TaskCompletionKey::joinWith(kvBackupComplete)));
															#line 2251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21463 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont4when1(__when_expr_2.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 3;
															#line 2251 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 2, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21468 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<_finishActor12*>(this)->actor_wait_state > 0) static_cast<_finishActor12*>(this)->actor_wait_state = 0;
		static_cast<_finishActor12*>(this)->ActorCallback< _finishActor12, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor12, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< _finishActor12, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< _finishActor12, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont5(Void const& _,int loopDepth) 
	{
															#line 2255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = success( BackupRestorableTaskFunc::addTask(tr, taskBucket, task, TaskCompletionKey::noSignal(), kvBackupComplete));
															#line 2255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21542 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont5when1(__when_expr_3.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 4;
															#line 2255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 3, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5(Void && _,int loopDepth) 
	{
															#line 2255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = success( BackupRestorableTaskFunc::addTask(tr, taskBucket, task, TaskCompletionKey::noSignal(), kvBackupComplete));
															#line 2255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21558 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont5when1(__when_expr_3.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 4;
															#line 2255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 3, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21563 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<_finishActor12*>(this)->actor_wait_state > 0) static_cast<_finishActor12*>(this)->actor_wait_state = 0;
		static_cast<_finishActor12*>(this)->ActorCallback< _finishActor12, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor12, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< _finishActor12, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< _finishActor12, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont6(Void const& _,int loopDepth) 
	{
															#line 2258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = taskBucket->finish(tr, task);
															#line 2258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21637 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont6when1(__when_expr_4.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 5;
															#line 2258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 4, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21642 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont6(Void && _,int loopDepth) 
	{
															#line 2258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_4 = taskBucket->finish(tr, task);
															#line 2258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<_finishActor12*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21653 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont6when1(__when_expr_4.get(), loopDepth); };
		static_cast<_finishActor12*>(this)->actor_wait_state = 5;
															#line 2258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< _finishActor12, 4, Void >*>(static_cast<_finishActor12*>(this)));
															#line 21658 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<_finishActor12*>(this)->actor_wait_state > 0) static_cast<_finishActor12*>(this)->actor_wait_state = 0;
		static_cast<_finishActor12*>(this)->ActorCallback< _finishActor12, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor12, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< _finishActor12, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< _finishActor12, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont7(Void const& _,int loopDepth) 
	{
															#line 2259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor12*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor12State(); static_cast<_finishActor12*>(this)->destroy(); return 0; }
															#line 21730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor12*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor12State();
		static_cast<_finishActor12*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont7(Void && _,int loopDepth) 
	{
															#line 2259 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<_finishActor12*>(this)->SAV<Void>::futures) { (void)(Void()); this->~_finishActor12State(); static_cast<_finishActor12*>(this)->destroy(); return 0; }
															#line 21742 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<_finishActor12*>(this)->SAV< Void >::value()) Void(Void());
		this->~_finishActor12State();
		static_cast<_finishActor12*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont6when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<_finishActor12*>(this)->actor_wait_state > 0) static_cast<_finishActor12*>(this)->actor_wait_state = 0;
		static_cast<_finishActor12*>(this)->ActorCallback< _finishActor12, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< _finishActor12, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< _finishActor12, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< _finishActor12, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<FutureBucket> futureBucket;
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<Task> task;
															#line 2210 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUidValue;
															#line 2211 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace states;
															#line 2213 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Subspace config;
															#line 2216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 2218 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> backupRanges;
															#line 2229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> kvBackupRangeComplete;
															#line 2230 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> kvBackupComplete;
															#line 2231 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int rangeCount;
															#line 21837 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via _finish()
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class _finishActor12 final : public Actor<Void>, public ActorCallback< _finishActor12, 0, Void >, public ActorCallback< _finishActor12, 1, Void >, public ActorCallback< _finishActor12, 2, Void >, public ActorCallback< _finishActor12, 3, Void >, public ActorCallback< _finishActor12, 4, Void >, public FastAllocated<_finishActor12>, public _finishActor12State<_finishActor12> {
															#line 21842 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<_finishActor12>::operator new;
	using FastAllocated<_finishActor12>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< _finishActor12, 0, Void >;
friend struct ActorCallback< _finishActor12, 1, Void >;
friend struct ActorCallback< _finishActor12, 2, Void >;
friend struct ActorCallback< _finishActor12, 3, Void >;
friend struct ActorCallback< _finishActor12, 4, Void >;
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	_finishActor12(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Reference<FutureBucket> const& futureBucket,Reference<Task> const& task) 
															#line 21857 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   _finishActor12State<_finishActor12>(tr, taskBucket, futureBucket, task)
	{
		fdb_probe_actor_enter("_finish", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("_finish");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("_finish", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< _finishActor12, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< _finishActor12, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< _finishActor12, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< _finishActor12, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< _finishActor12, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> _finish( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Reference<FutureBucket> const& futureBucket, Reference<Task> const& task ) {
															#line 2206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new _finishActor12(tr, taskBucket, futureBucket, task));
															#line 21888 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2261 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 21893 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via addTask()
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AddTaskActor10>
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor10State {
															#line 21899 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor10State(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Key const& logUid,Key const& backupUid,Key const& keyAddPrefix,Key const& keyRemovePrefix,Key const& keyConfigBackupRanges,Key const& tagName,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>(),DatabaseBackupAgent::PreBackupAction const& backupAction = DatabaseBackupAgent::PreBackupAction::VERIFY) 
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : tr(tr),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   taskBucket(taskBucket),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUid(logUid),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backupUid(backupUid),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   keyAddPrefix(keyAddPrefix),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   keyRemovePrefix(keyRemovePrefix),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   keyConfigBackupRanges(keyConfigBackupRanges),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   completionKey(completionKey),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitFor(waitFor),
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backupAction(backupAction)
															#line 21926 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("addTask", reinterpret_cast<unsigned long>(this));

	}
	~AddTaskActor10State() 
	{
		fdb_probe_actor_destroy("addTask", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2274 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Key> __when_expr_0 = completionKey.get(tr, taskBucket);
															#line 2274 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AddTaskActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 21943 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AddTaskActor10*>(this)->actor_wait_state = 1;
															#line 2274 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor10, 0, Key >*>(static_cast<AddTaskActor10*>(this)));
															#line 21948 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AddTaskActor10State();
		static_cast<AddTaskActor10*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key const& doneKey,int loopDepth) 
	{
															#line 2275 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(StartFullBackupTaskFunc::name, StartFullBackupTaskFunc::version, doneKey);
															#line 2277 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyFolderId] = backupUid;
															#line 2278 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyConfigLogUid] = logUid;
															#line 2279 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyAddPrefix] = keyAddPrefix;
															#line 2280 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyRemovePrefix] = keyRemovePrefix;
															#line 2281 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyConfigBackupRanges] = keyConfigBackupRanges;
															#line 2282 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyTagName] = tagName;
															#line 2283 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyDatabasesInSync] = backupAction == DatabaseBackupAgent::PreBackupAction::NONE ? LiteralStringRef("t") : LiteralStringRef("f");
															#line 2286 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 21987 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2287 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor10*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(logUid) .pack(BackupAgentBase::keyFolderId), task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor10State(); static_cast<AddTaskActor10*>(this)->destroy(); return 0; }
															#line 21991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor10*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(logUid) .pack(BackupAgentBase::keyFolderId), task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor10State();
			static_cast<AddTaskActor10*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(logUid) .pack(BackupAgentBase::keyFolderId), task->params[BackupAgentBase::keyFolderId]);
															#line 2296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22001 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor10*>(this)->actor_wait_state = 2;
															#line 2296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor10, 1, Void >*>(static_cast<AddTaskActor10*>(this)));
															#line 22006 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Key && doneKey,int loopDepth) 
	{
															#line 2275 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		auto task = makeReference<Task>(StartFullBackupTaskFunc::name, StartFullBackupTaskFunc::version, doneKey);
															#line 2277 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyFolderId] = backupUid;
															#line 2278 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyConfigLogUid] = logUid;
															#line 2279 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyAddPrefix] = keyAddPrefix;
															#line 2280 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyRemovePrefix] = keyRemovePrefix;
															#line 2281 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyConfigBackupRanges] = keyConfigBackupRanges;
															#line 2282 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[BackupAgentBase::keyTagName] = tagName;
															#line 2283 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		task->params[DatabaseBackupAgent::keyDatabasesInSync] = backupAction == DatabaseBackupAgent::PreBackupAction::NONE ? LiteralStringRef("t") : LiteralStringRef("f");
															#line 2286 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!waitFor)
															#line 22031 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2287 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AddTaskActor10*>(this)->SAV<Key>::futures) { (void)(taskBucket->addTask(tr, task, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(logUid) .pack(BackupAgentBase::keyFolderId), task->params[BackupAgentBase::keyFolderId])); this->~AddTaskActor10State(); static_cast<AddTaskActor10*>(this)->destroy(); return 0; }
															#line 22035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AddTaskActor10*>(this)->SAV< Key >::value()) Key(taskBucket->addTask(tr, task, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(logUid) .pack(BackupAgentBase::keyFolderId), task->params[BackupAgentBase::keyFolderId]));
			this->~AddTaskActor10State();
			static_cast<AddTaskActor10*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = waitFor->onSetAddTask(tr, taskBucket, task, Subspace(databaseBackupPrefixRange.begin) .get(BackupAgentBase::keyConfig) .get(logUid) .pack(BackupAgentBase::keyFolderId), task->params[BackupAgentBase::keyFolderId]);
															#line 2296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AddTaskActor10*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22045 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AddTaskActor10*>(this)->actor_wait_state = 2;
															#line 2296 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AddTaskActor10, 1, Void >*>(static_cast<AddTaskActor10*>(this)));
															#line 22050 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(Key const& doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(doneKey, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Key && doneKey,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(doneKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AddTaskActor10*>(this)->actor_wait_state > 0) static_cast<AddTaskActor10*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor10*>(this)->ActorCallback< AddTaskActor10, 0, Key >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor10, 0, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AddTaskActor10, 0, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AddTaskActor10, 0, Key >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 2304 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor10*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor10State(); static_cast<AddTaskActor10*>(this)->destroy(); return 0; }
															#line 22122 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor10*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor10State();
		static_cast<AddTaskActor10*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 2304 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AddTaskActor10*>(this)->SAV<Key>::futures) { (void)(LiteralStringRef("OnSetAddTask")); this->~AddTaskActor10State(); static_cast<AddTaskActor10*>(this)->destroy(); return 0; }
															#line 22134 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AddTaskActor10*>(this)->SAV< Key >::value()) Key(LiteralStringRef("OnSetAddTask"));
		this->~AddTaskActor10State();
		static_cast<AddTaskActor10*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AddTaskActor10*>(this)->actor_wait_state > 0) static_cast<AddTaskActor10*>(this)->actor_wait_state = 0;
		static_cast<AddTaskActor10*>(this)->ActorCallback< AddTaskActor10, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AddTaskActor10, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AddTaskActor10, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AddTaskActor10, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskBucket> taskBucket;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUid;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key backupUid;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key keyAddPrefix;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key keyRemovePrefix;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key keyConfigBackupRanges;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	TaskCompletionKey completionKey;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<TaskFuture> waitFor;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent::PreBackupAction backupAction;
															#line 22227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via addTask()
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AddTaskActor10 final : public Actor<Key>, public ActorCallback< AddTaskActor10, 0, Key >, public ActorCallback< AddTaskActor10, 1, Void >, public FastAllocated<AddTaskActor10>, public AddTaskActor10State<AddTaskActor10> {
															#line 22232 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AddTaskActor10>::operator new;
	using FastAllocated<AddTaskActor10>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Key>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AddTaskActor10, 0, Key >;
friend struct ActorCallback< AddTaskActor10, 1, Void >;
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AddTaskActor10(Reference<ReadYourWritesTransaction> const& tr,Reference<TaskBucket> const& taskBucket,Key const& logUid,Key const& backupUid,Key const& keyAddPrefix,Key const& keyRemovePrefix,Key const& keyConfigBackupRanges,Key const& tagName,TaskCompletionKey const& completionKey,Reference<TaskFuture> const& waitFor = Reference<TaskFuture>(),DatabaseBackupAgent::PreBackupAction const& backupAction = DatabaseBackupAgent::PreBackupAction::VERIFY) 
															#line 22244 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Key>(),
		   AddTaskActor10State<AddTaskActor10>(tr, taskBucket, logUid, backupUid, keyAddPrefix, keyRemovePrefix, keyConfigBackupRanges, tagName, completionKey, waitFor, backupAction)
	{
		fdb_probe_actor_enter("addTask", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("addTask");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("addTask", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AddTaskActor10, 0, Key >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AddTaskActor10, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Key> addTask( Reference<ReadYourWritesTransaction> const& tr, Reference<TaskBucket> const& taskBucket, Key const& logUid, Key const& backupUid, Key const& keyAddPrefix, Key const& keyRemovePrefix, Key const& keyConfigBackupRanges, Key const& tagName, TaskCompletionKey const& completionKey, Reference<TaskFuture> const& waitFor = Reference<TaskFuture>(), DatabaseBackupAgent::PreBackupAction const& backupAction = DatabaseBackupAgent::PreBackupAction::VERIFY ) {
															#line 2262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Key>(new AddTaskActor10(tr, taskBucket, logUid, backupUid, keyAddPrefix, keyRemovePrefix, keyConfigBackupRanges, tagName, completionKey, waitFor, backupAction));
															#line 22272 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2306 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	StringRef getName() const override { return name; };

	Future<Void> execute(Database cx,
	                     Reference<TaskBucket> tb,
	                     Reference<FutureBucket> fb,
	                     Reference<Task> task) override {
		return _execute(cx, tb, fb, task);
	};
	Future<Void> finish(Reference<ReadYourWritesTransaction> tr,
	                    Reference<TaskBucket> tb,
	                    Reference<FutureBucket> fb,
	                    Reference<Task> task) override {
		return _finish(tr, tb, fb, task);
	};
};
StringRef StartFullBackupTaskFunc::name = LiteralStringRef("dr_start_full_backup");
REGISTER_TASKFUNC(StartFullBackupTaskFunc);
} // namespace dbBackup

std::set<std::string> getDRAgentsIds(StatusObjectReader statusObj, const char* context) {
	std::set<std::string> drBackupAgents;
	try {
		StatusObjectReader statusObjLayers;
		statusObj.get("cluster.layers", statusObjLayers);
		StatusObjectReader instances;
		std::string path = format("%s.instances", context);
		if (statusObjLayers.tryGet(path, instances)) {
			for (auto itr : instances.obj()) {
				drBackupAgents.insert(itr.first);
			}
		}
	} catch (std::runtime_error& e) {
		TraceEvent(SevWarn, "DBA_GetDRAgentsIdsFail").detail("Error", e.what());
		throw backup_error();
	}
	return drBackupAgents;
}

std::string getDRMutationStreamId(StatusObjectReader statusObj, const char* context, Key tagName) {
	try {
		StatusObjectReader statusObjLayers;
		statusObj.get("cluster.layers", statusObjLayers);
		StatusObjectReader tags;
		std::string path = format("%s.tags", context);
		if (statusObjLayers.tryGet(path, tags)) {
			for (auto itr : tags.obj()) {
				if (itr.first == tagName.toString()) {
					JSONDoc tag(itr.second);
					return tag["mutation_stream_id"].get_str();
				}
			}
		}
		TraceEvent(SevWarn, "DBA_TagNotPresentInStatus").detail("Tag", tagName).detail("Context", context);
		throw backup_error();
	} catch (std::runtime_error& e) {
		TraceEvent(SevWarn, "DBA_GetDRMutationStreamIdFail").detail("Error", e.what());
		throw backup_error();
	}
}

bool getLockedStatus(StatusObjectReader statusObj) {
	try {
		StatusObjectReader statusObjCluster = statusObj["cluster"].get_obj();
		return statusObjCluster["database_lock_state.locked"].get_bool();
	} catch (std::runtime_error& e) {
		TraceEvent(SevWarn, "DBA_GetLockedStatusFail").detail("Error", e.what());
		throw backup_error();
	}
}

void checkAtomicSwitchOverConfig(StatusObjectReader srcStatus, StatusObjectReader destStatus, Key tagName) {

	try {
		// Check if src is unlocked and dest is locked
		if (getLockedStatus(srcStatus) != false) {
			TraceEvent(SevWarn, "DBA_AtomicSwitchOverSrcLocked").log();
			throw backup_error();
		}
		if (getLockedStatus(destStatus) != true) {
			TraceEvent(SevWarn, "DBA_AtomicSwitchOverDestUnlocked").log();
			throw backup_error();
		}
		// Check if mutation-stream-id matches
		if (getDRMutationStreamId(srcStatus, "dr_backup", tagName) !=
		    getDRMutationStreamId(destStatus, "dr_backup_dest", tagName)) {
			TraceEvent(SevWarn, "DBA_AtomicSwitchOverMutationIdMismatch")
			    .detail("SourceMutationId", getDRMutationStreamId(srcStatus, "dr_backup", tagName))
			    .detail("DestMutationId", getDRMutationStreamId(destStatus, "dr_back_dest", tagName));
			throw backup_error();
		}
		// Check if there are agents set up with src as its destination cluster and dest as its source cluster
		auto srcDRAgents = getDRAgentsIds(srcStatus, "dr_backup_dest");
		auto destDRAgents = getDRAgentsIds(destStatus, "dr_backup");
		std::set<std::string> intersectingAgents;
		std::set_intersection(srcDRAgents.begin(),
		                      srcDRAgents.end(),
		                      destDRAgents.begin(),
		                      destDRAgents.end(),
		                      std::inserter(intersectingAgents, intersectingAgents.begin()));
		if (intersectingAgents.empty()) {
			TraceEvent(SevWarn, "DBA_SwitchOverPossibleDRAgentsIncorrectSetup").log();
			throw backup_error();
		}
	} catch (std::runtime_error& e) {
		TraceEvent(SevWarn, "DBA_UnableToCheckAtomicSwitchOverConfig").detail("RunTimeError", e.what());
		throw backup_error();
	}
	return;
}

class DatabaseBackupAgentImpl {
public:
	static constexpr int MAX_RESTORABLE_FILE_METASECTION_BYTES = 1024 * 8;

																#line 22391 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via waitUpgradeToLatestDrVersion()
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class WaitUpgradeToLatestDrVersionActor>
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class WaitUpgradeToLatestDrVersionActorState {
															#line 22397 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	WaitUpgradeToLatestDrVersionActorState(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName) 
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   cx(cx),
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName)
															#line 22408 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this));

	}
	~WaitUpgradeToLatestDrVersionActorState() 
	{
		fdb_probe_actor_destroy("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2422 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(cx, tagName);
															#line 2422 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 22425 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 1;
															#line 2422 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >*>(static_cast<WaitUpgradeToLatestDrVersionActor*>(this)));
															#line 22430 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitUpgradeToLatestDrVersionActorState();
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2423 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		drVersionKey = backupAgent->config.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(DatabaseBackupAgent::keyDrVersion);
															#line 2426 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DRU_WatchLatestDrVersion") .detail("DrVersionKey", drVersionKey.printable()) .detail("LogUid", BinaryWriter::toValue(logUid, Unversioned()).printable());
															#line 2430 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 22457 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID const& __logUid,int loopDepth) 
	{
															#line 2422 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = __logUid;
															#line 22466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID && __logUid,int loopDepth) 
	{
		logUid = std::move(__logUid);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 2431 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(cx));
															#line 2433 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 22542 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1(int loopDepth) 
	{
		try {
															#line 2435 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2436 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2437 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_1 = tr->get(drVersionKey);
															#line 2437 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 22571 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 2;
															#line 2437 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >*>(static_cast<WaitUpgradeToLatestDrVersionActor*>(this)));
															#line 22576 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1break1(int loopDepth) 
	{
		try {
			return a_body1cont1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopBody1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2455 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = tr->onError(e);
															#line 2455 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 2));
															#line 22613 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 2)); else return a_body1cont1loopBody1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 5;
															#line 2455 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >*>(static_cast<WaitUpgradeToLatestDrVersionActor*>(this)));
															#line 22618 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 2));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 2));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont2(Optional<Value> const& drVersion,int loopDepth) 
	{
															#line 2439 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DRU_VersionCheck") .detail("Current", drVersion.present() ? BinaryReader::fromStringRef<int>(drVersion.get(), Unversioned()) : -1) .detail("Expected", DatabaseBackupAgent::LATEST_DR_VERSION) .detail("LogUid", BinaryWriter::toValue(logUid, Unversioned()).printable());
															#line 2445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (drVersion.present() && BinaryReader::fromStringRef<int>(drVersion.get(), Unversioned()) == DatabaseBackupAgent::LATEST_DR_VERSION)
															#line 22635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2447 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WaitUpgradeToLatestDrVersionActorState(); static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->destroy(); return 0; }
															#line 22639 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~WaitUpgradeToLatestDrVersionActorState();
			static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2450 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		watchDrVersionFuture = tr->watch(drVersionKey);
															#line 2451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 2451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 22651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 3;
															#line 2451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >*>(static_cast<WaitUpgradeToLatestDrVersionActor*>(this)));
															#line 22656 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont2(Optional<Value> && drVersion,int loopDepth) 
	{
															#line 2439 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DRU_VersionCheck") .detail("Current", drVersion.present() ? BinaryReader::fromStringRef<int>(drVersion.get(), Unversioned()) : -1) .detail("Expected", DatabaseBackupAgent::LATEST_DR_VERSION) .detail("LogUid", BinaryWriter::toValue(logUid, Unversioned()).printable());
															#line 2445 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (drVersion.present() && BinaryReader::fromStringRef<int>(drVersion.get(), Unversioned()) == DatabaseBackupAgent::LATEST_DR_VERSION)
															#line 22667 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2447 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~WaitUpgradeToLatestDrVersionActorState(); static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->destroy(); return 0; }
															#line 22671 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~WaitUpgradeToLatestDrVersionActorState();
			static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2450 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		watchDrVersionFuture = tr->watch(drVersionKey);
															#line 2451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 2451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 22683 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 3;
															#line 2451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >*>(static_cast<WaitUpgradeToLatestDrVersionActor*>(this)));
															#line 22688 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1when1(Optional<Value> const& drVersion,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont2(drVersion, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1when1(Optional<Value> && drVersion,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont2(std::move(drVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 2452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = watchDrVersionFuture;
															#line 2452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 22762 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 4;
															#line 2452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >*>(static_cast<WaitUpgradeToLatestDrVersionActor*>(this)));
															#line 22767 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 2452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = watchDrVersionFuture;
															#line 2452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 22778 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 4;
															#line 2452 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >*>(static_cast<WaitUpgradeToLatestDrVersionActor*>(this)));
															#line 22783 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1loopBody1cont5(Void const& _,int loopDepth) 
	{
		return a_body1cont1loopBody1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont5(Void && _,int loopDepth) 
	{
		return a_body1cont1loopBody1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state > 0) static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->actor_wait_state = 0;
		static_cast<WaitUpgradeToLatestDrVersionActor*>(this)->ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2422 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 2423 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key drVersionKey;
															#line 2431 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2450 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> watchDrVersionFuture;
															#line 23015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via waitUpgradeToLatestDrVersion()
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class WaitUpgradeToLatestDrVersionActor final : public Actor<Void>, public ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >, public ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >, public ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >, public ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >, public ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >, public FastAllocated<WaitUpgradeToLatestDrVersionActor>, public WaitUpgradeToLatestDrVersionActorState<WaitUpgradeToLatestDrVersionActor> {
															#line 23020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<WaitUpgradeToLatestDrVersionActor>::operator new;
	using FastAllocated<WaitUpgradeToLatestDrVersionActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >;
friend struct ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >;
friend struct ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >;
friend struct ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >;
friend struct ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >;
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	WaitUpgradeToLatestDrVersionActor(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName) 
															#line 23035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   WaitUpgradeToLatestDrVersionActorState<WaitUpgradeToLatestDrVersionActor>(backupAgent, cx, tagName)
	{
		fdb_probe_actor_enter("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitUpgradeToLatestDrVersion");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitUpgradeToLatestDrVersion", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitUpgradeToLatestDrVersionActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WaitUpgradeToLatestDrVersionActor, 1, Optional<Value> >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WaitUpgradeToLatestDrVersionActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< WaitUpgradeToLatestDrVersionActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< WaitUpgradeToLatestDrVersionActor, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> waitUpgradeToLatestDrVersion( DatabaseBackupAgent* const& backupAgent, Database const& cx, Key const& tagName ) {
															#line 2421 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new WaitUpgradeToLatestDrVersionActor(backupAgent, cx, tagName));
															#line 23066 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2460 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	// This method will return the final status of the backup
																#line 23072 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via waitBackup()
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class WaitBackupActor>
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class WaitBackupActorState {
															#line 23078 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	WaitBackupActorState(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName,StopWhenDone const& stopWhenDone) 
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   cx(cx),
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName),
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   stopWhenDone(stopWhenDone),
															#line 2466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backTrace()
															#line 23093 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("waitBackup", reinterpret_cast<unsigned long>(this));

	}
	~WaitBackupActorState() 
	{
		fdb_probe_actor_destroy("waitBackup", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2467 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(cx, tagName);
															#line 2467 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 23110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WaitBackupActor*>(this)->actor_wait_state = 1;
															#line 2467 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitBackupActor, 0, UID >*>(static_cast<WaitBackupActor*>(this)));
															#line 23115 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitBackupActorState();
		static_cast<WaitBackupActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2468 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusKey = backupAgent->states.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(DatabaseBackupAgent::keyStateStatus);
															#line 2471 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 23140 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID const& __logUid,int loopDepth) 
	{
															#line 2467 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = __logUid;
															#line 23149 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID && __logUid,int loopDepth) 
	{
		logUid = std::move(__logUid);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state > 0) static_cast<WaitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<WaitBackupActor*>(this)->ActorCallback< WaitBackupActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitBackupActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 2472 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(cx));
															#line 2473 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2474 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 23227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		try {
															#line 2477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<EBackupState> __when_expr_1 = backupAgent->getStateValue(tr, logUid);
															#line 2477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitBackupActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 23233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<WaitBackupActor*>(this)->actor_wait_state = 2;
															#line 2477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitBackupActor, 1, EBackupState >*>(static_cast<WaitBackupActor*>(this)));
															#line 23238 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2493 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = tr->onError(e);
															#line 2493 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 23262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<WaitBackupActor*>(this)->actor_wait_state = 5;
															#line 2493 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< WaitBackupActor, 4, Void >*>(static_cast<WaitBackupActor*>(this)));
															#line 23267 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(int loopDepth) 
	{
															#line 2480 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!DatabaseBackupAgent::isRunnable(status) || EBackupState::STATE_PARTIALLY_ABORTED == status)
															#line 23282 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2481 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<WaitBackupActor*>(this)->SAV<EBackupState>::futures) { (void)(status); this->~WaitBackupActorState(); static_cast<WaitBackupActor*>(this)->destroy(); return 0; }
															#line 23286 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<WaitBackupActor*>(this)->SAV< EBackupState >::value()) EBackupState(std::move(status)); // state_var_RVO
			this->~WaitBackupActorState();
			static_cast<WaitBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2485 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if ((!stopWhenDone) && (EBackupState::STATE_RUNNING_DIFFERENTIAL == status))
															#line 23294 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2486 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<WaitBackupActor*>(this)->SAV<EBackupState>::futures) { (void)(status); this->~WaitBackupActorState(); static_cast<WaitBackupActor*>(this)->destroy(); return 0; }
															#line 23298 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<WaitBackupActor*>(this)->SAV< EBackupState >::value()) EBackupState(std::move(status)); // state_var_RVO
			this->~WaitBackupActorState();
			static_cast<WaitBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2489 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		watchFuture = tr->watch(statusKey);
															#line 2490 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 2490 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 23310 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitBackupActor*>(this)->actor_wait_state = 3;
															#line 2490 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitBackupActor, 2, Void >*>(static_cast<WaitBackupActor*>(this)));
															#line 23315 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(EBackupState const& __status,int loopDepth) 
	{
															#line 2477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		status = __status;
															#line 23324 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(EBackupState && __status,int loopDepth) 
	{
		status = std::move(__status);
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state > 0) static_cast<WaitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<WaitBackupActor*>(this)->ActorCallback< WaitBackupActor, 1, EBackupState >::remove();

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 1, EBackupState >*,EBackupState const& value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 1, EBackupState >*,EBackupState && value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitBackupActor, 1, EBackupState >*,Error err) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 2491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = watchFuture;
															#line 2491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 23393 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<WaitBackupActor*>(this)->actor_wait_state = 4;
															#line 2491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitBackupActor, 3, Void >*>(static_cast<WaitBackupActor*>(this)));
															#line 23398 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 2491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = watchFuture;
															#line 2491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 23409 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<WaitBackupActor*>(this)->actor_wait_state = 4;
															#line 2491 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitBackupActor, 3, Void >*>(static_cast<WaitBackupActor*>(this)));
															#line 23414 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state > 0) static_cast<WaitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<WaitBackupActor*>(this)->ActorCallback< WaitBackupActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WaitBackupActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1cont6(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont6(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont7(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state > 0) static_cast<WaitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<WaitBackupActor*>(this)->ActorCallback< WaitBackupActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WaitBackupActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1cont7(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<WaitBackupActor*>(this)->actor_wait_state > 0) static_cast<WaitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<WaitBackupActor*>(this)->ActorCallback< WaitBackupActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< WaitBackupActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< WaitBackupActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	StopWhenDone stopWhenDone;
															#line 2466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::string backTrace;
															#line 2467 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 2468 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key statusKey;
															#line 2472 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2477 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	EBackupState status;
															#line 2489 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> watchFuture;
															#line 23665 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via waitBackup()
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class WaitBackupActor final : public Actor<EBackupState>, public ActorCallback< WaitBackupActor, 0, UID >, public ActorCallback< WaitBackupActor, 1, EBackupState >, public ActorCallback< WaitBackupActor, 2, Void >, public ActorCallback< WaitBackupActor, 3, Void >, public ActorCallback< WaitBackupActor, 4, Void >, public FastAllocated<WaitBackupActor>, public WaitBackupActorState<WaitBackupActor> {
															#line 23670 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<WaitBackupActor>::operator new;
	using FastAllocated<WaitBackupActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<EBackupState>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitBackupActor, 0, UID >;
friend struct ActorCallback< WaitBackupActor, 1, EBackupState >;
friend struct ActorCallback< WaitBackupActor, 2, Void >;
friend struct ActorCallback< WaitBackupActor, 3, Void >;
friend struct ActorCallback< WaitBackupActor, 4, Void >;
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	WaitBackupActor(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName,StopWhenDone const& stopWhenDone) 
															#line 23685 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<EBackupState>(),
		   WaitBackupActorState<WaitBackupActor>(backupAgent, cx, tagName, stopWhenDone)
	{
		fdb_probe_actor_enter("waitBackup", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitBackup");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitBackup", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitBackupActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WaitBackupActor, 1, EBackupState >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WaitBackupActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< WaitBackupActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< WaitBackupActor, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<EBackupState> waitBackup( DatabaseBackupAgent* const& backupAgent, Database const& cx, Key const& tagName, StopWhenDone const& stopWhenDone ) {
															#line 2462 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<EBackupState>(new WaitBackupActor(backupAgent, cx, tagName, stopWhenDone));
															#line 23716 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2497 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

	// This method will return the final status of the backup
																#line 23722 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via waitSubmitted()
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class WaitSubmittedActor>
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class WaitSubmittedActorState {
															#line 23728 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	WaitSubmittedActorState(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName) 
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   cx(cx),
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName)
															#line 23739 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("waitSubmitted", reinterpret_cast<unsigned long>(this));

	}
	~WaitSubmittedActorState() 
	{
		fdb_probe_actor_destroy("waitSubmitted", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(cx, tagName);
															#line 2500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 23756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 1;
															#line 2500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< WaitSubmittedActor, 0, UID >*>(static_cast<WaitSubmittedActor*>(this)));
															#line 23761 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~WaitSubmittedActorState();
		static_cast<WaitSubmittedActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2501 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusKey = backupAgent->states.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(DatabaseBackupAgent::keyStateStatus);
															#line 2504 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 23786 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID const& __logUid,int loopDepth) 
	{
															#line 2500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = __logUid;
															#line 23795 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID && __logUid,int loopDepth) 
	{
		logUid = std::move(__logUid);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state > 0) static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 0;
		static_cast<WaitSubmittedActor*>(this)->ActorCallback< WaitSubmittedActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< WaitSubmittedActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 2505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(cx));
															#line 2506 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2507 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 23873 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		try {
															#line 2510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<EBackupState> __when_expr_1 = backupAgent->getStateValue(tr, logUid);
															#line 2510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 23879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1cont1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_1.get(), loopDepth); };
			static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 2;
															#line 2510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< WaitSubmittedActor, 1, EBackupState >*>(static_cast<WaitSubmittedActor*>(this)));
															#line 23884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2521 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = tr->onError(e);
															#line 2521 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 23908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 5;
															#line 2521 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< WaitSubmittedActor, 4, Void >*>(static_cast<WaitSubmittedActor*>(this)));
															#line 23913 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(int loopDepth) 
	{
															#line 2513 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (EBackupState::STATE_SUBMITTED != status)
															#line 23928 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2514 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<WaitSubmittedActor*>(this)->SAV<EBackupState>::futures) { (void)(status); this->~WaitSubmittedActorState(); static_cast<WaitSubmittedActor*>(this)->destroy(); return 0; }
															#line 23932 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<WaitSubmittedActor*>(this)->SAV< EBackupState >::value()) EBackupState(std::move(status)); // state_var_RVO
			this->~WaitSubmittedActorState();
			static_cast<WaitSubmittedActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2517 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		watchFuture = tr->watch(statusKey);
															#line 2518 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_2 = tr->commit();
															#line 2518 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 23944 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1cont1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 3;
															#line 2518 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< WaitSubmittedActor, 2, Void >*>(static_cast<WaitSubmittedActor*>(this)));
															#line 23949 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(EBackupState const& __status,int loopDepth) 
	{
															#line 2510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		status = __status;
															#line 23958 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(EBackupState && __status,int loopDepth) 
	{
		status = std::move(__status);
		loopDepth = a_body1cont1loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state > 0) static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 0;
		static_cast<WaitSubmittedActor*>(this)->ActorCallback< WaitSubmittedActor, 1, EBackupState >::remove();

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 1, EBackupState >*,EBackupState const& value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 1, EBackupState >*,EBackupState && value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< WaitSubmittedActor, 1, EBackupState >*,Error err) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 2519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = watchFuture;
															#line 2519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 24027 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 4;
															#line 2519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitSubmittedActor, 3, Void >*>(static_cast<WaitSubmittedActor*>(this)));
															#line 24032 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 2519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = watchFuture;
															#line 2519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 24043 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1cont1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont1loopBody1cont3when1(__when_expr_3.get(), loopDepth); };
		static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 4;
															#line 2519 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< WaitSubmittedActor, 3, Void >*>(static_cast<WaitSubmittedActor*>(this)));
															#line 24048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state > 0) static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 0;
		static_cast<WaitSubmittedActor*>(this)->ActorCallback< WaitSubmittedActor, 2, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 2, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 2, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< WaitSubmittedActor, 2, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont1loopBody1cont5(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont5(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state > 0) static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 0;
		static_cast<WaitSubmittedActor*>(this)->ActorCallback< WaitSubmittedActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< WaitSubmittedActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont1loopBody1cont6(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont1loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<WaitSubmittedActor*>(this)->actor_wait_state > 0) static_cast<WaitSubmittedActor*>(this)->actor_wait_state = 0;
		static_cast<WaitSubmittedActor*>(this)->ActorCallback< WaitSubmittedActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< WaitSubmittedActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< WaitSubmittedActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), 4);

	}
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2500 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 2501 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key statusKey;
															#line 2505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	EBackupState status;
															#line 2517 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> watchFuture;
															#line 24295 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via waitSubmitted()
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class WaitSubmittedActor final : public Actor<EBackupState>, public ActorCallback< WaitSubmittedActor, 0, UID >, public ActorCallback< WaitSubmittedActor, 1, EBackupState >, public ActorCallback< WaitSubmittedActor, 2, Void >, public ActorCallback< WaitSubmittedActor, 3, Void >, public ActorCallback< WaitSubmittedActor, 4, Void >, public FastAllocated<WaitSubmittedActor>, public WaitSubmittedActorState<WaitSubmittedActor> {
															#line 24300 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<WaitSubmittedActor>::operator new;
	using FastAllocated<WaitSubmittedActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<EBackupState>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< WaitSubmittedActor, 0, UID >;
friend struct ActorCallback< WaitSubmittedActor, 1, EBackupState >;
friend struct ActorCallback< WaitSubmittedActor, 2, Void >;
friend struct ActorCallback< WaitSubmittedActor, 3, Void >;
friend struct ActorCallback< WaitSubmittedActor, 4, Void >;
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	WaitSubmittedActor(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName) 
															#line 24315 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<EBackupState>(),
		   WaitSubmittedActorState<WaitSubmittedActor>(backupAgent, cx, tagName)
	{
		fdb_probe_actor_enter("waitSubmitted", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("waitSubmitted");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("waitSubmitted", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< WaitSubmittedActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< WaitSubmittedActor, 1, EBackupState >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< WaitSubmittedActor, 2, Void >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< WaitSubmittedActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< WaitSubmittedActor, 4, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<EBackupState> waitSubmitted( DatabaseBackupAgent* const& backupAgent, Database const& cx, Key const& tagName ) {
															#line 2499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<EBackupState>(new WaitSubmittedActor(backupAgent, cx, tagName));
															#line 24346 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2525 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 24351 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via submitBackup()
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class SubmitBackupActor>
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class SubmitBackupActorState {
															#line 24357 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	SubmitBackupActorState(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName,Standalone<VectorRef<KeyRangeRef>> const& backupRanges,StopWhenDone const& stopWhenDone,Key const& addPrefix,Key const& removePrefix,LockDB const& lockDB,DatabaseBackupAgent::PreBackupAction const& backupAction) 
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(tr),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backupRanges(backupRanges),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   stopWhenDone(stopWhenDone),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   addPrefix(addPrefix),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   removePrefix(removePrefix),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   lockDB(lockDB),
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backupAction(backupAction),
															#line 2535 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUid(deterministicRandom()->randomUniqueID()),
															#line 2536 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUidValue(BinaryWriter::toValue(logUid, Unversioned()))
															#line 24384 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("submitBackup", reinterpret_cast<unsigned long>(this));

	}
	~SubmitBackupActorState() 
	{
		fdb_probe_actor_destroy("submitBackup", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(tr, tagName);
															#line 2537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24401 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 1;
															#line 2537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 0, UID >*>(static_cast<SubmitBackupActor*>(this)));
															#line 24406 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~SubmitBackupActorState();
		static_cast<SubmitBackupActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2539 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2540 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2544 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::COMMIT_ON_FIRST_PROXY);
															#line 2547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<EBackupState> __when_expr_1 = backupAgent->getStateValue(tr, logUidCurrent);
															#line 2547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24437 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<SubmitBackupActor*>(this)->actor_wait_state = 2;
															#line 2547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 1, EBackupState >*>(static_cast<SubmitBackupActor*>(this)));
															#line 24442 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(UID const& __logUidCurrent,int loopDepth) 
	{
															#line 2537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUidCurrent = __logUidCurrent;
															#line 24451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID && __logUidCurrent,int loopDepth) 
	{
		logUidCurrent = std::move(__logUidCurrent);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 2549 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (DatabaseBackupAgent::isRunnable(status))
															#line 24518 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2550 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1Catch1(backup_duplicate(), loopDepth);
															#line 24522 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2553 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (logUidCurrent.isValid())
															#line 24526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2554 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			logUid = logUidCurrent;
															#line 2555 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			logUidValue = BinaryWriter::toValue(logUid, Unversioned());
															#line 24532 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2558 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_2 = tr->get(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId));
															#line 2558 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24538 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<SubmitBackupActor*>(this)->actor_wait_state = 3;
															#line 2558 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 2, Optional<Key> >*>(static_cast<SubmitBackupActor*>(this)));
															#line 24543 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(EBackupState const& __status,int loopDepth) 
	{
															#line 2547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		status = __status;
															#line 24552 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(EBackupState && __status,int loopDepth) 
	{
		status = std::move(__status);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 1, EBackupState >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 1, EBackupState >*,EBackupState const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 1, EBackupState >*,EBackupState && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 1, EBackupState >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(Optional<Key> const& v,int loopDepth) 
	{
															#line 2559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Version uidVersion = 0;
															#line 2560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present())
															#line 24621 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2561 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			uidVersion = BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) + 1;
															#line 24625 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2562 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupUid = BinaryWriter::toValue(uidVersion, Unversioned());
															#line 2564 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		KeyRangeMap<int> backupRangeSet;
															#line 2565 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto& backupRange : backupRanges ) {
															#line 2566 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			backupRangeSet.insert(backupRange, 1);
															#line 24635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2569 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRangeSet.coalesce(allKeys);
															#line 2570 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = Standalone<VectorRef<KeyRangeRef>>();
															#line 2572 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto& backupRange : backupRangeSet.ranges() ) {
															#line 2573 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (backupRange.value())
															#line 24645 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2574 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				backupRanges.push_back_deep(backupRanges.arena(), backupRange.range());
															#line 24649 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 2578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupAction == DatabaseBackupAgent::PreBackupAction::VERIFY)
															#line 24654 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2580 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			backupIntoResults = std::vector<Future<RangeResult>>();
															#line 2581 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto& backupRange : backupRanges ) {
															#line 2582 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				backupIntoResults.push_back( tr->getRange(backupRange.removePrefix(removePrefix).withPrefix(addPrefix), 1));
															#line 24662 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 2585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = waitForAll(backupIntoResults);
															#line 2585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24668 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont3when1(__when_expr_3.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 4;
															#line 2585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 3, Void >*>(static_cast<SubmitBackupActor*>(this)));
															#line 24673 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 2592 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (backupAction == DatabaseBackupAgent::PreBackupAction::CLEAR)
															#line 24680 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2594 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				for( auto& backupRange : backupRanges ) {
															#line 2595 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					tr->clear(backupRange.removePrefix(removePrefix).withPrefix(addPrefix));
															#line 24686 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
			}
			loopDepth = a_body1cont6(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3(Optional<Key> && v,int loopDepth) 
	{
															#line 2559 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Version uidVersion = 0;
															#line 2560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present())
															#line 24700 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2561 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			uidVersion = BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) + 1;
															#line 24704 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2562 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupUid = BinaryWriter::toValue(uidVersion, Unversioned());
															#line 2564 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		KeyRangeMap<int> backupRangeSet;
															#line 2565 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto& backupRange : backupRanges ) {
															#line 2566 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			backupRangeSet.insert(backupRange, 1);
															#line 24714 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2569 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRangeSet.coalesce(allKeys);
															#line 2570 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = Standalone<VectorRef<KeyRangeRef>>();
															#line 2572 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto& backupRange : backupRangeSet.ranges() ) {
															#line 2573 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (backupRange.value())
															#line 24724 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2574 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				backupRanges.push_back_deep(backupRanges.arena(), backupRange.range());
															#line 24728 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 2578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupAction == DatabaseBackupAgent::PreBackupAction::VERIFY)
															#line 24733 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2580 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			backupIntoResults = std::vector<Future<RangeResult>>();
															#line 2581 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto& backupRange : backupRanges ) {
															#line 2582 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				backupIntoResults.push_back( tr->getRange(backupRange.removePrefix(removePrefix).withPrefix(addPrefix), 1));
															#line 24741 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
															#line 2585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_3 = waitForAll(backupIntoResults);
															#line 2585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24747 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont3when1(__when_expr_3.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 4;
															#line 2585 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 3, Void >*>(static_cast<SubmitBackupActor*>(this)));
															#line 24752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 2592 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (backupAction == DatabaseBackupAgent::PreBackupAction::CLEAR)
															#line 24759 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2594 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				for( auto& backupRange : backupRanges ) {
															#line 2595 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
					tr->clear(backupRange.removePrefix(removePrefix).withPrefix(addPrefix));
															#line 24765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				}
			}
			loopDepth = a_body1cont6(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2when1(Optional<Key> const& v,int loopDepth) 
	{
		loopDepth = a_body1cont3(v, loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Optional<Key> && v,int loopDepth) 
	{
		loopDepth = a_body1cont3(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 2, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 2, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 2, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 2, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont6(int loopDepth) 
	{
															#line 2600 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(backupAgent->config.get(logUidValue).range());
															#line 2601 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(backupAgent->states.get(logUidValue).range());
															#line 2602 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(backupAgent->errors.range());
															#line 2604 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->tagNames.pack(tagName), logUidValue);
															#line 2607 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		DRConfig(logUid).clear(tr);
															#line 2608 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyDrVersion), BinaryWriter::toValue(DatabaseBackupAgent::LATEST_DR_VERSION, Unversioned()));
															#line 2610 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyAddPrefix), addPrefix);
															#line 2611 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyRemovePrefix), removePrefix);
															#line 2612 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyConfigBackupTag), tagName);
															#line 2613 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyConfigLogUid), logUidValue);
															#line 2614 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId), backupUid);
															#line 2615 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId), backupUid);
															#line 2617 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyConfigBackupRanges), BinaryWriter::toValue(backupRanges, IncludeVersion(ProtocolVersion::withDRBackupRanges())));
															#line 2619 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_SUBMITTED)));
															#line 2621 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (stopWhenDone)
															#line 24868 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2622 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->set(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyConfigStopWhenDoneKey), StringRef());
															#line 24872 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2626 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		int64_t startCount = 0;
															#line 2627 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		mapPrefix = logUidValue.withPrefix(applyMutationsKeyVersionMapRange.begin);
															#line 2628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Key mapEnd = normalKeys.end.withPrefix(mapPrefix);
															#line 2629 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(logUidValue.withPrefix(applyMutationsAddPrefixRange.begin), addPrefix);
															#line 2630 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(logUidValue.withPrefix(applyMutationsRemovePrefixRange.begin), removePrefix);
															#line 2631 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(logUidValue.withPrefix(applyMutationsKeyVersionCountRange.begin), StringRef((uint8_t*)&startCount, 8));
															#line 2632 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(KeyRangeRef(mapPrefix, mapEnd));
															#line 2634 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		readVersion = invalidVersion;
															#line 2635 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupAction == DatabaseBackupAgent::PreBackupAction::NONE)
															#line 24892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2636 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Transaction readTransaction(backupAgent->taskBucket->src);
															#line 2637 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			readTransaction.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Version> __when_expr_4 = readTransaction.getReadVersion();
															#line 2638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 24902 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont6when1(__when_expr_4.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 5;
															#line 2638 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 4, Version >*>(static_cast<SubmitBackupActor*>(this)));
															#line 24907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont16(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11(Void const& _,int loopDepth) 
	{
															#line 2586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto result : backupIntoResults ) {
															#line 2587 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (result.get().size() > 0)
															#line 24923 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2589 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1Catch1(restore_destination_not_empty(), loopDepth);
															#line 24927 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
		loopDepth = a_body1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont11(Void && _,int loopDepth) 
	{
															#line 2586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		for( auto result : backupIntoResults ) {
															#line 2587 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (result.get().size() > 0)
															#line 24940 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2589 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1Catch1(restore_destination_not_empty(), loopDepth);
															#line 24944 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
		loopDepth = a_body1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont16(int loopDepth) 
	{
															#line 2641 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(mapPrefix, BinaryWriter::toValue<Version>(readVersion, Unversioned()));
															#line 2643 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Key> __when_expr_5 = dbBackup::StartFullBackupTaskFunc::addTask( tr, backupAgent->taskBucket, logUidValue, backupUid, addPrefix, removePrefix, BinaryWriter::toValue(backupRanges, IncludeVersion(ProtocolVersion::withDRBackupRanges())), tagName, TaskCompletionKey::noSignal(), Reference<TaskFuture>(), backupAction);
															#line 2643 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25022 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont16when1(__when_expr_5.get(), loopDepth); };
		static_cast<SubmitBackupActor*>(this)->actor_wait_state = 6;
															#line 2643 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 5, Key >*>(static_cast<SubmitBackupActor*>(this)));
															#line 25027 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont18(Version const& _,int loopDepth) 
	{
															#line 2639 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		readVersion = _;
															#line 25036 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont16(loopDepth);

		return loopDepth;
	}
	int a_body1cont18(Version && _,int loopDepth) 
	{
															#line 2639 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		readVersion = _;
															#line 25045 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont16(loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Version const& _,int loopDepth) 
	{
		loopDepth = a_body1cont18(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont6when1(Version && _,int loopDepth) 
	{
		loopDepth = a_body1cont18(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 4, Version >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 4, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 4, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont6when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 4, Version >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont16cont1(Key const& taskKey,int loopDepth) 
	{
															#line 2656 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (lockDB)
															#line 25117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2657 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_6 = lockDatabase(tr, logUid);
															#line 2657 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25123 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont16cont1when1(__when_expr_6.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 7;
															#line 2657 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 6, Void >*>(static_cast<SubmitBackupActor*>(this)));
															#line 25128 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 2659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = checkDatabaseLock(tr, logUid);
															#line 2659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25137 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont16cont1when2(__when_expr_7.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 8;
															#line 2659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 7, Void >*>(static_cast<SubmitBackupActor*>(this)));
															#line 25142 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont16cont1(Key && taskKey,int loopDepth) 
	{
															#line 2656 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (lockDB)
															#line 25152 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2657 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_6 = lockDatabase(tr, logUid);
															#line 2657 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25158 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont16cont1when1(__when_expr_6.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 7;
															#line 2657 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 6, Void >*>(static_cast<SubmitBackupActor*>(this)));
															#line 25163 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
															#line 2659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = checkDatabaseLock(tr, logUid);
															#line 2659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<SubmitBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25172 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1cont16cont1when2(__when_expr_7.get(), loopDepth); };
			static_cast<SubmitBackupActor*>(this)->actor_wait_state = 8;
															#line 2659 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< SubmitBackupActor, 7, Void >*>(static_cast<SubmitBackupActor*>(this)));
															#line 25177 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1cont16when1(Key const& taskKey,int loopDepth) 
	{
		loopDepth = a_body1cont16cont1(taskKey, loopDepth);

		return loopDepth;
	}
	int a_body1cont16when1(Key && taskKey,int loopDepth) 
	{
		loopDepth = a_body1cont16cont1(std::move(taskKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 5, Key >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 5, Key >*,Key const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont16when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 5, Key >*,Key && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont16when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 5, Key >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont16cont2(int loopDepth) 
	{
															#line 2661 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_Submit") .detail("LogUid", logUid) .detail("Lock", lockDB) .detail("LogUID", logUidValue) .detail("Tag", tagName) .detail("Key", backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId)) .detail("MapPrefix", mapPrefix);
															#line 2669 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<SubmitBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~SubmitBackupActorState(); static_cast<SubmitBackupActor*>(this)->destroy(); return 0; }
															#line 25252 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<SubmitBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~SubmitBackupActorState();
		static_cast<SubmitBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont16cont3(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont16cont3(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont16cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont16cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont16cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont16cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont16cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont16cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont16cont1when2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont16cont1when2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont16cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<SubmitBackupActor*>(this)->actor_wait_state > 0) static_cast<SubmitBackupActor*>(this)->actor_wait_state = 0;
		static_cast<SubmitBackupActor*>(this)->ActorCallback< SubmitBackupActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont16cont1when2(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< SubmitBackupActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont16cont1when2(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< SubmitBackupActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), 7);

	}
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> backupRanges;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	StopWhenDone stopWhenDone;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key addPrefix;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key removePrefix;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	LockDB lockDB;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent::PreBackupAction backupAction;
															#line 2535 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 2536 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUidValue;
															#line 2537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUidCurrent;
															#line 2547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	EBackupState status;
															#line 2562 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<StringRef> backupUid;
															#line 2580 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::vector<Future<RangeResult>> backupIntoResults;
															#line 2627 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key mapPrefix;
															#line 2634 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version readVersion;
															#line 25444 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via submitBackup()
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class SubmitBackupActor final : public Actor<Void>, public ActorCallback< SubmitBackupActor, 0, UID >, public ActorCallback< SubmitBackupActor, 1, EBackupState >, public ActorCallback< SubmitBackupActor, 2, Optional<Key> >, public ActorCallback< SubmitBackupActor, 3, Void >, public ActorCallback< SubmitBackupActor, 4, Version >, public ActorCallback< SubmitBackupActor, 5, Key >, public ActorCallback< SubmitBackupActor, 6, Void >, public ActorCallback< SubmitBackupActor, 7, Void >, public FastAllocated<SubmitBackupActor>, public SubmitBackupActorState<SubmitBackupActor> {
															#line 25449 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<SubmitBackupActor>::operator new;
	using FastAllocated<SubmitBackupActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< SubmitBackupActor, 0, UID >;
friend struct ActorCallback< SubmitBackupActor, 1, EBackupState >;
friend struct ActorCallback< SubmitBackupActor, 2, Optional<Key> >;
friend struct ActorCallback< SubmitBackupActor, 3, Void >;
friend struct ActorCallback< SubmitBackupActor, 4, Version >;
friend struct ActorCallback< SubmitBackupActor, 5, Key >;
friend struct ActorCallback< SubmitBackupActor, 6, Void >;
friend struct ActorCallback< SubmitBackupActor, 7, Void >;
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	SubmitBackupActor(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName,Standalone<VectorRef<KeyRangeRef>> const& backupRanges,StopWhenDone const& stopWhenDone,Key const& addPrefix,Key const& removePrefix,LockDB const& lockDB,DatabaseBackupAgent::PreBackupAction const& backupAction) 
															#line 25467 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   SubmitBackupActorState<SubmitBackupActor>(backupAgent, tr, tagName, backupRanges, stopWhenDone, addPrefix, removePrefix, lockDB, backupAction)
	{
		fdb_probe_actor_enter("submitBackup", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("submitBackup");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("submitBackup", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< SubmitBackupActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< SubmitBackupActor, 1, EBackupState >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< SubmitBackupActor, 2, Optional<Key> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< SubmitBackupActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< SubmitBackupActor, 4, Version >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< SubmitBackupActor, 5, Key >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< SubmitBackupActor, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< SubmitBackupActor, 7, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> submitBackup( DatabaseBackupAgent* const& backupAgent, Reference<ReadYourWritesTransaction> const& tr, Key const& tagName, Standalone<VectorRef<KeyRangeRef>> const& backupRanges, StopWhenDone const& stopWhenDone, Key const& addPrefix, Key const& removePrefix, LockDB const& lockDB, DatabaseBackupAgent::PreBackupAction const& backupAction ) {
															#line 2526 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new SubmitBackupActor(backupAgent, tr, tagName, backupRanges, stopWhenDone, addPrefix, removePrefix, lockDB, backupAction));
															#line 25501 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2671 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 25506 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via unlockBackup()
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class UnlockBackupActor>
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class UnlockBackupActorState {
															#line 25512 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UnlockBackupActorState(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName) 
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(tr),
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName)
															#line 25523 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("unlockBackup", reinterpret_cast<unsigned long>(this));

	}
	~UnlockBackupActorState() 
	{
		fdb_probe_actor_destroy("unlockBackup", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(tr, tagName);
															#line 2675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<UnlockBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25540 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<UnlockBackupActor*>(this)->actor_wait_state = 1;
															#line 2675 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< UnlockBackupActor, 0, UID >*>(static_cast<UnlockBackupActor*>(this)));
															#line 25545 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~UnlockBackupActorState();
		static_cast<UnlockBackupActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(UID const& logUid,int loopDepth) 
	{
															#line 2676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = unlockDatabase(tr, logUid);
															#line 2676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<UnlockBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25570 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<UnlockBackupActor*>(this)->actor_wait_state = 2;
															#line 2676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< UnlockBackupActor, 1, Void >*>(static_cast<UnlockBackupActor*>(this)));
															#line 25575 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(UID && logUid,int loopDepth) 
	{
															#line 2676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = unlockDatabase(tr, logUid);
															#line 2676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<UnlockBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25586 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<UnlockBackupActor*>(this)->actor_wait_state = 2;
															#line 2676 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< UnlockBackupActor, 1, Void >*>(static_cast<UnlockBackupActor*>(this)));
															#line 25591 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(UID const& logUid,int loopDepth) 
	{
		loopDepth = a_body1cont1(logUid, loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID && logUid,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(logUid), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<UnlockBackupActor*>(this)->actor_wait_state > 0) static_cast<UnlockBackupActor*>(this)->actor_wait_state = 0;
		static_cast<UnlockBackupActor*>(this)->ActorCallback< UnlockBackupActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< UnlockBackupActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("unlockBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unlockBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< UnlockBackupActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("unlockBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unlockBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< UnlockBackupActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("unlockBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unlockBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(Void const& _,int loopDepth) 
	{
															#line 2677 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_Unlock").detail("Tag", tagName);
															#line 2678 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<UnlockBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~UnlockBackupActorState(); static_cast<UnlockBackupActor*>(this)->destroy(); return 0; }
															#line 25665 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<UnlockBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~UnlockBackupActorState();
		static_cast<UnlockBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2(Void && _,int loopDepth) 
	{
															#line 2677 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_Unlock").detail("Tag", tagName);
															#line 2678 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<UnlockBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~UnlockBackupActorState(); static_cast<UnlockBackupActor*>(this)->destroy(); return 0; }
															#line 25679 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<UnlockBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~UnlockBackupActorState();
		static_cast<UnlockBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<UnlockBackupActor*>(this)->actor_wait_state > 0) static_cast<UnlockBackupActor*>(this)->actor_wait_state = 0;
		static_cast<UnlockBackupActor*>(this)->ActorCallback< UnlockBackupActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< UnlockBackupActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("unlockBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unlockBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< UnlockBackupActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("unlockBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unlockBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< UnlockBackupActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("unlockBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("unlockBackup", reinterpret_cast<unsigned long>(this), 1);

	}
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 25756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via unlockBackup()
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class UnlockBackupActor final : public Actor<Void>, public ActorCallback< UnlockBackupActor, 0, UID >, public ActorCallback< UnlockBackupActor, 1, Void >, public FastAllocated<UnlockBackupActor>, public UnlockBackupActorState<UnlockBackupActor> {
															#line 25761 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<UnlockBackupActor>::operator new;
	using FastAllocated<UnlockBackupActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< UnlockBackupActor, 0, UID >;
friend struct ActorCallback< UnlockBackupActor, 1, Void >;
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UnlockBackupActor(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName) 
															#line 25773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   UnlockBackupActorState<UnlockBackupActor>(backupAgent, tr, tagName)
	{
		fdb_probe_actor_enter("unlockBackup", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("unlockBackup");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("unlockBackup", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< UnlockBackupActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< UnlockBackupActor, 1, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> unlockBackup( DatabaseBackupAgent* const& backupAgent, Reference<ReadYourWritesTransaction> const& tr, Key const& tagName ) {
															#line 2672 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new UnlockBackupActor(backupAgent, tr, tagName));
															#line 25801 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2680 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 25806 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via atomicSwitchover()
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AtomicSwitchoverActor>
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AtomicSwitchoverActorState {
															#line 25812 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AtomicSwitchoverActorState(DatabaseBackupAgent* const& backupAgent,Database const& dest,Key const& tagName,Standalone<VectorRef<KeyRangeRef>> const& backupRanges,Key const& addPrefix,Key const& removePrefix,ForceAction const& forceAction) 
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   dest(dest),
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName),
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backupRanges(backupRanges),
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   addPrefix(addPrefix),
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   removePrefix(removePrefix),
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   forceAction(forceAction),
															#line 2688 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   drAgent(dest)
															#line 25833 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("atomicSwitchover", reinterpret_cast<unsigned long>(this));

	}
	~AtomicSwitchoverActorState() 
	{
		fdb_probe_actor_destroy("atomicSwitchover", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(dest, tagName);
															#line 2689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25850 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 1;
															#line 2689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 0, UID >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 25855 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AtomicSwitchoverActorState();
		static_cast<AtomicSwitchoverActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2690 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<EBackupState> __when_expr_1 = backupAgent->getStateValue(dest, destlogUid);
															#line 2690 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 2;
															#line 2690 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 1, EBackupState >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 25885 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(UID const& __destlogUid,int loopDepth) 
	{
															#line 2689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destlogUid = __destlogUid;
															#line 25894 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID && __destlogUid,int loopDepth) 
	{
		destlogUid = std::move(__destlogUid);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 2692 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverStart").detail("Status", status);
															#line 2693 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (status != EBackupState::STATE_RUNNING_DIFFERENTIAL && status != EBackupState::STATE_COMPLETED)
															#line 25963 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2694 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1Catch1(backup_duplicate(), loopDepth);
															#line 25967 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2697 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!g_network->isSimulated() && !forceAction)
															#line 25971 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<StatusObject> __when_expr_2 = StatusClient::statusFetcher(backupAgent->taskBucket->src);
															#line 2698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 25977 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 3;
															#line 2698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 2, StatusObject >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 25982 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1when1(EBackupState const& __status,int loopDepth) 
	{
															#line 2690 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		status = __status;
															#line 25996 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(EBackupState && __status,int loopDepth) 
	{
		status = std::move(__status);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 1, EBackupState >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 1, EBackupState >*,EBackupState const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 1, EBackupState >*,EBackupState && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 1, EBackupState >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 2703 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = deterministicRandom()->randomUniqueID();
															#line 2704 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUidValue = BinaryWriter::toValue(logUid, Unversioned());
															#line 2705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<UID> __when_expr_4 = drAgent.getLogUid(backupAgent->taskBucket->src, tagName);
															#line 2705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 26069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1cont3when1(__when_expr_4.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 5;
															#line 2705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 4, UID >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26074 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont5(int loopDepth) 
	{
															#line 2699 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<StatusObject> __when_expr_3 = StatusClient::statusFetcher(dest);
															#line 2699 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 26085 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1cont5when1(__when_expr_3.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 4;
															#line 2699 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 3, StatusObject >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26090 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2when1(StatusObject const& __srcStatus,int loopDepth) 
	{
															#line 2698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcStatus = __srcStatus;
															#line 26099 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(StatusObject && __srcStatus,int loopDepth) 
	{
		srcStatus = std::move(__srcStatus);
		loopDepth = a_body1cont5(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 2, StatusObject >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 2, StatusObject >*,StatusObject const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 2, StatusObject >*,StatusObject && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 2, StatusObject >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1cont6(StatusObject const& destStatus,int loopDepth) 
	{
															#line 2700 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		checkAtomicSwitchOverConfig(srcStatus, destStatus, tagName);
															#line 26166 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont6(StatusObject && destStatus,int loopDepth) 
	{
															#line 2700 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		checkAtomicSwitchOverConfig(srcStatus, destStatus, tagName);
															#line 26175 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(StatusObject const& destStatus,int loopDepth) 
	{
		loopDepth = a_body1cont6(destStatus, loopDepth);

		return loopDepth;
	}
	int a_body1cont5when1(StatusObject && destStatus,int loopDepth) 
	{
		loopDepth = a_body1cont6(std::move(destStatus), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 3, StatusObject >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 3, StatusObject >*,StatusObject const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 3, StatusObject >*,StatusObject && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 3, StatusObject >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1cont8(int loopDepth) 
	{
															#line 2707 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (logUidCurrent.isValid())
															#line 26247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2708 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			logUid = logUidCurrent;
															#line 2709 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			logUidValue = BinaryWriter::toValue(logUid, Unversioned());
															#line 26253 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2713 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = Transaction(backupAgent->taskBucket->src);
															#line 2714 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		commitVersion = Version();
															#line 2715 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 26261 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont8loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(UID const& __logUidCurrent,int loopDepth) 
	{
															#line 2705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUidCurrent = __logUidCurrent;
															#line 26270 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont8(loopDepth);

		return loopDepth;
	}
	int a_body1cont3when1(UID && __logUidCurrent,int loopDepth) 
	{
		logUidCurrent = std::move(__logUidCurrent);
		loopDepth = a_body1cont8(loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 4, UID >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 4, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 4, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 4, UID >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont9(int loopDepth) 
	{
															#line 2727 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverLocked").detail("Version", commitVersion);
															#line 2730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr2 = ReadYourWritesTransaction(dest);
															#line 2731 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 26341 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont9loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont8loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont8loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont8loopBody1(int loopDepth) 
	{
		try {
															#line 2717 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_5 = lockDatabase(&tr, logUid);
															#line 2717 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont8loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26360 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont8loopBody1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont8loopBody1when1(__when_expr_5.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 6;
															#line 2717 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 5, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26365 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont8loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont8loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont8break1(int loopDepth) 
	{
		try {
			return a_body1cont9(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont8loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont8loopHead1(0);

		return loopDepth;
	}
	int a_body1cont8loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = tr.onError(e);
															#line 2723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 26402 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), std::max(0, loopDepth - 1)); else return a_body1cont8loopBody1Catch1when1(__when_expr_7.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 8;
															#line 2723 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 7, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26407 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont8loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 2718 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr.set(backupAgent->tagNames.pack(tagName), logUidValue);
															#line 2719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = tr.commit();
															#line 2719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont8loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26426 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont8loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont8loopBody1cont2when1(__when_expr_6.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 7;
															#line 2719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 6, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26431 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont8loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 2718 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr.set(backupAgent->tagNames.pack(tagName), logUidValue);
															#line 2719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = tr.commit();
															#line 2719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont8loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26444 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont8loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont8loopBody1cont2when1(__when_expr_6.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 7;
															#line 2719 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 6, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26449 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont8loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont8loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 5, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 5, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont8loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont8loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont8loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 5, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont8loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont8loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont8loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 5, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont8loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont8loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont8loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont8loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 2720 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		commitVersion = tr.getCommittedVersion();
															#line 26521 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1cont8break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont8loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 2720 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		commitVersion = tr.getCommittedVersion();
															#line 26530 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1cont8break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont8loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont8loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont8loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont8loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont8loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont8loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont8loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont8loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont8loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont8loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont8loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont8loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont8loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont8loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont8loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont8loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont8loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont8loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1cont11(int loopDepth) 
	{
															#line 2762 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverReady").log();
															#line 26677 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		try {
															#line 2765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_13 = backupAgent->discontinueBackup(dest, tagName);
															#line 2765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont11Catch1(actor_cancelled(), loopDepth);
															#line 26683 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_13.isReady()) { if (__when_expr_13.isError()) return a_body1cont11Catch1(__when_expr_13.getError(), loopDepth); else return a_body1cont11when1(__when_expr_13.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 14;
															#line 2765 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_13.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 13, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26688 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont11Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont11Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont9loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont9loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1(int loopDepth) 
	{
		try {
															#line 2733 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr2.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2734 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr2.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2735 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_8 = tr2.get(backupAgent->states.get(BinaryWriter::toValue(destlogUid, Unversioned())) .pack(DatabaseBackupAgent::keyFolderId));
															#line 2735 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont9loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26717 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1cont9loopBody1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont9loopBody1when1(__when_expr_8.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 9;
															#line 2735 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26722 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont9loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont9loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont9break1(int loopDepth) 
	{
		try {
			return a_body1cont11(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont9loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont9loopHead1(0);

		return loopDepth;
	}
	int a_body1cont9loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2758 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_12 = tr2.onError(e);
															#line 2758 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 26759 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_12.isReady()) { if (__when_expr_12.isError()) return a_body1Catch1(__when_expr_12.getError(), std::max(0, loopDepth - 1)); else return a_body1cont9loopBody1Catch1when1(__when_expr_12.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 13;
															#line 2758 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_12.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 12, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26764 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont9loopBody1cont2(int loopDepth) 
	{
															#line 2738 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverBackupUID") .detail("Uid", backupUid) .detail("Key", backupAgent->states.get(BinaryWriter::toValue(destlogUid, Unversioned())) .pack(DatabaseBackupAgent::keyFolderId));
															#line 2743 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!backupUid.present())
															#line 26781 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2744 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1cont9loopBody1Catch1(backup_duplicate(), loopDepth);
															#line 26785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2745 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_9 = tr2.get( BinaryWriter::toValue(destlogUid, Unversioned()).withPrefix(applyMutationsBeginRange.begin));
															#line 2745 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont9loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26791 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1cont9loopBody1Catch1(__when_expr_9.getError(), loopDepth); else return a_body1cont9loopBody1cont2when1(__when_expr_9.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 10;
															#line 2745 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26796 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont9loopBody1when1(Optional<Value> const& __backupUid,int loopDepth) 
	{
															#line 2735 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupUid = __backupUid;
															#line 26805 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont9loopBody1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1when1(Optional<Value> && __backupUid,int loopDepth) 
	{
		backupUid = std::move(__backupUid);
		loopDepth = a_body1cont9loopBody1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont9loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont9loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont9loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 8);

	}
	int a_body1cont9loopBody1cont3(Optional<Value> const& v,int loopDepth) 
	{
															#line 2747 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverVersion") .detail("Version", v.present() ? BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) : 0);
															#line 2749 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present() && BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) >= commitVersion)
															#line 26874 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1cont9break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 2752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		versionWatch = tr2.watch( BinaryWriter::toValue(destlogUid, Unversioned()).withPrefix(applyMutationsBeginRange.begin));
															#line 2754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_10 = tr2.commit();
															#line 2754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont9loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1cont9loopBody1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1cont9loopBody1cont3when1(__when_expr_10.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 11;
															#line 2754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 10, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26889 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont9loopBody1cont3(Optional<Value> && v,int loopDepth) 
	{
															#line 2747 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverVersion") .detail("Version", v.present() ? BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) : 0);
															#line 2749 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present() && BinaryReader::fromStringRef<Version>(v.get(), Unversioned()) >= commitVersion)
															#line 26900 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1cont9break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 2752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		versionWatch = tr2.watch( BinaryWriter::toValue(destlogUid, Unversioned()).withPrefix(applyMutationsBeginRange.begin));
															#line 2754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_10 = tr2.commit();
															#line 2754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont9loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26910 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1cont9loopBody1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1cont9loopBody1cont3when1(__when_expr_10.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 11;
															#line 2754 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 10, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26915 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont9loopBody1cont2when1(Optional<Value> const& v,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont3(v, loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1cont2when1(Optional<Value> && v,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont3(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose10() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont9loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont9loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont9loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 9);

	}
	int a_body1cont9loopBody1cont5(Void const& _,int loopDepth) 
	{
															#line 2755 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_11 = versionWatch;
															#line 2755 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont9loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 26989 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_11.isReady()) { if (__when_expr_11.isError()) return a_body1cont9loopBody1Catch1(__when_expr_11.getError(), loopDepth); else return a_body1cont9loopBody1cont5when1(__when_expr_11.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 12;
															#line 2755 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_11.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 11, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 26994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont9loopBody1cont5(Void && _,int loopDepth) 
	{
															#line 2755 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_11 = versionWatch;
															#line 2755 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont9loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 27005 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_11.isReady()) { if (__when_expr_11.isError()) return a_body1cont9loopBody1Catch1(__when_expr_11.getError(), loopDepth); else return a_body1cont9loopBody1cont5when1(__when_expr_11.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 12;
															#line 2755 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_11.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 11, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont9loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont5(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont5(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose11() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 10, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 10, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont9loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 10, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont9loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 10, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont9loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 10);

	}
	int a_body1cont9loopBody1cont7(Void const& _,int loopDepth) 
	{
															#line 2756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr2.reset();
															#line 27082 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont9loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1cont7(Void && _,int loopDepth) 
	{
															#line 2756 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr2.reset();
															#line 27091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont9loopBody1cont9(loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1cont5when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1cont5when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose12() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 11, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 11, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont9loopBody1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 11, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont9loopBody1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 11, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont9loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont9loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont9loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 11);

	}
	int a_body1cont9loopBody1cont9(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont9loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont9loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont9loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont9loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose13() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 12, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 12, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1cont9loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 12, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1cont9loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 12, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 12);

	}
	int a_body1cont11cont1(int loopDepth) 
	{
															#line 2771 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_14 = success(backupAgent->waitBackup(dest, tagName, StopWhenDone::True));
															#line 2771 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 27253 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_14.isReady()) { if (__when_expr_14.isError()) return a_body1Catch1(__when_expr_14.getError(), loopDepth); else return a_body1cont11cont1when1(__when_expr_14.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 15;
															#line 2771 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_14.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 14, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27258 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont11Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2767 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (e.code() != error_code_backup_duplicate && e.code() != error_code_backup_unneeded)
															#line 27268 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2768 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1Catch1(e, loopDepth);
															#line 27272 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
			loopDepth = a_body1cont11cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11cont2(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont2(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont11when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose14() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 13, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 13, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont11when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont11Catch1(error, 0);
		} catch (...) {
			a_body1cont11Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 13);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 13, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont11when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont11Catch1(error, 0);
		} catch (...) {
			a_body1cont11Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 13);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 13, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont11Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont11Catch1(error, 0);
		} catch (...) {
			a_body1cont11Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 13);

	}
	int a_body1cont11cont3(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont11cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11cont4(Void const& _,int loopDepth) 
	{
															#line 2773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverStopped").log();
															#line 2775 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr3 = ReadYourWritesTransaction(dest);
															#line 2776 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 27380 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont11cont4loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4(Void && _,int loopDepth) 
	{
															#line 2773 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverStopped").log();
															#line 2775 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr3 = ReadYourWritesTransaction(dest);
															#line 2776 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 27393 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont11cont4loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose15() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 14, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 14, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1cont11cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 14);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 14, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1cont11cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 14);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 14, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 14);

	}
	int a_body1cont11cont5(int loopDepth) 
	{
															#line 2794 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverVersionUpgraded").log();
															#line 27465 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		try {
															#line 2797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_18 = drAgent.submitBackup(backupAgent->taskBucket->src, tagName, backupRanges, StopWhenDone::False, addPrefix, removePrefix, LockDB::True, DatabaseBackupAgent::PreBackupAction::NONE);
															#line 2797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont11cont5Catch1(actor_cancelled(), loopDepth);
															#line 27471 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_18.isReady()) { if (__when_expr_18.isError()) return a_body1cont11cont5Catch1(__when_expr_18.getError(), loopDepth); else return a_body1cont11cont5when1(__when_expr_18.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 19;
															#line 2797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_18.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 18, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27476 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont11cont5Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont11cont5Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11cont4loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont11cont4loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1(int loopDepth) 
	{
		try {
															#line 2778 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr3.setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2779 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr3.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Version> __when_expr_15 = tr3.getReadVersion();
															#line 2780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont11cont4loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 27505 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_15.isReady()) { if (__when_expr_15.isError()) return a_body1cont11cont4loopBody1Catch1(__when_expr_15.getError(), loopDepth); else return a_body1cont11cont4loopBody1when1(__when_expr_15.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 16;
															#line 2780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_15.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 15, Version >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27510 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont11cont4loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont11cont4loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11cont4break1(int loopDepth) 
	{
		try {
			return a_body1cont11cont5(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont11cont4loopHead1(0);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2790 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_17 = tr3.onError(e);
															#line 2790 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 27547 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_17.isReady()) { if (__when_expr_17.isError()) return a_body1Catch1(__when_expr_17.getError(), std::max(0, loopDepth - 1)); else return a_body1cont11cont4loopBody1Catch1when1(__when_expr_17.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 18;
															#line 2790 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_17.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 17, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27552 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1cont2(Version const& destVersion,int loopDepth) 
	{
															#line 2781 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverVersionUpgrade").detail("Src", commitVersion).detail("Dest", destVersion);
															#line 2782 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (destVersion <= commitVersion)
															#line 27569 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2783 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TEST(true);
															#line 2784 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr3.set(minRequiredCommitVersionKey, BinaryWriter::toValue(commitVersion + 1, Unversioned()));
															#line 2785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_16 = tr3.commit();
															#line 2785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont11cont4loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 27579 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_16.isReady()) { if (__when_expr_16.isError()) return a_body1cont11cont4loopBody1Catch1(__when_expr_16.getError(), loopDepth); else return a_body1cont11cont4loopBody1cont2when1(__when_expr_16.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 17;
															#line 2785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_16.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 16, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27584 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			return a_body1cont11cont4break1(loopDepth==0?0:loopDepth-1); // break
		}

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1cont2(Version && destVersion,int loopDepth) 
	{
															#line 2781 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverVersionUpgrade").detail("Src", commitVersion).detail("Dest", destVersion);
															#line 2782 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (destVersion <= commitVersion)
															#line 27600 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2783 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TEST(true);
															#line 2784 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr3.set(minRequiredCommitVersionKey, BinaryWriter::toValue(commitVersion + 1, Unversioned()));
															#line 2785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_16 = tr3.commit();
															#line 2785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1cont11cont4loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 27610 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_16.isReady()) { if (__when_expr_16.isError()) return a_body1cont11cont4loopBody1Catch1(__when_expr_16.getError(), loopDepth); else return a_body1cont11cont4loopBody1cont2when1(__when_expr_16.get(), loopDepth); };
			static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 17;
															#line 2785 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_16.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 16, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27615 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			return a_body1cont11cont4break1(loopDepth==0?0:loopDepth-1); // break
		}

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1when1(Version const& destVersion,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont2(destVersion, loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1when1(Version && destVersion,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont2(std::move(destVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose16() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 15, Version >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 15, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 15);
		a_exitChoose16();
		try {
			a_body1cont11cont4loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont11cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 15);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 15, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 15);
		a_exitChoose16();
		try {
			a_body1cont11cont4loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont11cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 15);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 15, Version >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 15);
		a_exitChoose16();
		try {
			a_body1cont11cont4loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont11cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 15);

	}
	int a_body1cont11cont4loopBody1cont3(int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont6(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1cont4(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1cont4(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont4(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont4(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose17() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 16, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 16, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 16);
		a_exitChoose17();
		try {
			a_body1cont11cont4loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont11cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 16);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 16, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 16);
		a_exitChoose17();
		try {
			a_body1cont11cont4loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont11cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 16);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 16, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 16);
		a_exitChoose17();
		try {
			a_body1cont11cont4loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont11cont4loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont4loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 16);

	}
	int a_body1cont11cont4loopBody1cont6(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont11cont4loopBody1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont4loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont4loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose18() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 17, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 17, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 17);
		a_exitChoose18();
		try {
			a_body1cont11cont4loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 17);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 17, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 17);
		a_exitChoose18();
		try {
			a_body1cont11cont4loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 17);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 17, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 17);
		a_exitChoose18();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 17);

	}
	int a_body1cont11cont6(int loopDepth) 
	{
															#line 2810 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverSubmitted").log();
															#line 2812 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_19 = success(drAgent.waitSubmitted(backupAgent->taskBucket->src, tagName));
															#line 2812 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 27865 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_19.isReady()) { if (__when_expr_19.isError()) return a_body1Catch1(__when_expr_19.getError(), loopDepth); else return a_body1cont11cont6when1(__when_expr_19.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 20;
															#line 2812 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_19.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 19, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27870 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont11cont5Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2806 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (e.code() != error_code_backup_duplicate)
															#line 27880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2807 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1Catch1(e, loopDepth);
															#line 27884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
			loopDepth = a_body1cont11cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11cont7(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont8(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont7(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont8(loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont5when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont5when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose19() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 18, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 18, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 18);
		a_exitChoose19();
		try {
			a_body1cont11cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont11cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 18);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 18, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 18);
		a_exitChoose19();
		try {
			a_body1cont11cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont11cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 18);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 18, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 18);
		a_exitChoose19();
		try {
			a_body1cont11cont5Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont11cont5Catch1(error, 0);
		} catch (...) {
			a_body1cont11cont5Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 18);

	}
	int a_body1cont11cont8(int loopDepth) 
	{
		try {
			loopDepth = a_body1cont11cont6(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont11cont9(Void const& _,int loopDepth) 
	{
															#line 2814 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverStarted").log();
															#line 2816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_20 = backupAgent->unlockBackup(dest, tagName);
															#line 2816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 27992 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_20.isReady()) { if (__when_expr_20.isError()) return a_body1Catch1(__when_expr_20.getError(), loopDepth); else return a_body1cont11cont9when1(__when_expr_20.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 21;
															#line 2816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_20.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 20, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 27997 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont11cont9(Void && _,int loopDepth) 
	{
															#line 2814 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverStarted").log();
															#line 2816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_20 = backupAgent->unlockBackup(dest, tagName);
															#line 2816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 28010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_20.isReady()) { if (__when_expr_20.isError()) return a_body1Catch1(__when_expr_20.getError(), loopDepth); else return a_body1cont11cont9when1(__when_expr_20.get(), loopDepth); };
		static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 21;
															#line 2816 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_20.addCallbackAndClear(static_cast<ActorCallback< AtomicSwitchoverActor, 20, Void >*>(static_cast<AtomicSwitchoverActor*>(this)));
															#line 28015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont11cont6when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont6when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose20() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 19, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 19, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 19);
		a_exitChoose20();
		try {
			a_body1cont11cont6when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 19);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 19, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 19);
		a_exitChoose20();
		try {
			a_body1cont11cont6when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 19);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 19, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 19);
		a_exitChoose20();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 19);

	}
	int a_body1cont11cont10(Void const& _,int loopDepth) 
	{
															#line 2818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverUnlocked").log();
															#line 2820 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AtomicSwitchoverActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AtomicSwitchoverActorState(); static_cast<AtomicSwitchoverActor*>(this)->destroy(); return 0; }
															#line 28089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AtomicSwitchoverActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~AtomicSwitchoverActorState();
		static_cast<AtomicSwitchoverActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont11cont10(Void && _,int loopDepth) 
	{
															#line 2818 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_SwitchoverUnlocked").log();
															#line 2820 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AtomicSwitchoverActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AtomicSwitchoverActorState(); static_cast<AtomicSwitchoverActor*>(this)->destroy(); return 0; }
															#line 28103 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AtomicSwitchoverActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~AtomicSwitchoverActorState();
		static_cast<AtomicSwitchoverActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont11cont9when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont10(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont11cont9when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont11cont10(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose21() 
	{
		if (static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state > 0) static_cast<AtomicSwitchoverActor*>(this)->actor_wait_state = 0;
		static_cast<AtomicSwitchoverActor*>(this)->ActorCallback< AtomicSwitchoverActor, 20, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 20, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 20);
		a_exitChoose21();
		try {
			a_body1cont11cont9when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 20);

	}
	void a_callback_fire(ActorCallback< AtomicSwitchoverActor, 20, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 20);
		a_exitChoose21();
		try {
			a_body1cont11cont9when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 20);

	}
	void a_callback_error(ActorCallback< AtomicSwitchoverActor, 20, Void >*,Error err) 
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), 20);
		a_exitChoose21();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), 20);

	}
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database dest;
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> backupRanges;
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key addPrefix;
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key removePrefix;
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	ForceAction forceAction;
															#line 2688 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent drAgent;
															#line 2689 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID destlogUid;
															#line 2690 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	EBackupState status;
															#line 2698 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	StatusObject srcStatus;
															#line 2703 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 2704 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUidValue;
															#line 2705 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUidCurrent;
															#line 2713 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Transaction tr;
															#line 2714 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version commitVersion;
															#line 2730 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	ReadYourWritesTransaction tr2;
															#line 2735 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> backupUid;
															#line 2752 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> versionWatch;
															#line 2775 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	ReadYourWritesTransaction tr3;
															#line 28214 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via atomicSwitchover()
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AtomicSwitchoverActor final : public Actor<Void>, public ActorCallback< AtomicSwitchoverActor, 0, UID >, public ActorCallback< AtomicSwitchoverActor, 1, EBackupState >, public ActorCallback< AtomicSwitchoverActor, 2, StatusObject >, public ActorCallback< AtomicSwitchoverActor, 3, StatusObject >, public ActorCallback< AtomicSwitchoverActor, 4, UID >, public ActorCallback< AtomicSwitchoverActor, 5, Void >, public ActorCallback< AtomicSwitchoverActor, 6, Void >, public ActorCallback< AtomicSwitchoverActor, 7, Void >, public ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >, public ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >, public ActorCallback< AtomicSwitchoverActor, 10, Void >, public ActorCallback< AtomicSwitchoverActor, 11, Void >, public ActorCallback< AtomicSwitchoverActor, 12, Void >, public ActorCallback< AtomicSwitchoverActor, 13, Void >, public ActorCallback< AtomicSwitchoverActor, 14, Void >, public ActorCallback< AtomicSwitchoverActor, 15, Version >, public ActorCallback< AtomicSwitchoverActor, 16, Void >, public ActorCallback< AtomicSwitchoverActor, 17, Void >, public ActorCallback< AtomicSwitchoverActor, 18, Void >, public ActorCallback< AtomicSwitchoverActor, 19, Void >, public ActorCallback< AtomicSwitchoverActor, 20, Void >, public FastAllocated<AtomicSwitchoverActor>, public AtomicSwitchoverActorState<AtomicSwitchoverActor> {
															#line 28219 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AtomicSwitchoverActor>::operator new;
	using FastAllocated<AtomicSwitchoverActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AtomicSwitchoverActor, 0, UID >;
friend struct ActorCallback< AtomicSwitchoverActor, 1, EBackupState >;
friend struct ActorCallback< AtomicSwitchoverActor, 2, StatusObject >;
friend struct ActorCallback< AtomicSwitchoverActor, 3, StatusObject >;
friend struct ActorCallback< AtomicSwitchoverActor, 4, UID >;
friend struct ActorCallback< AtomicSwitchoverActor, 5, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 6, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 7, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >;
friend struct ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >;
friend struct ActorCallback< AtomicSwitchoverActor, 10, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 11, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 12, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 13, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 14, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 15, Version >;
friend struct ActorCallback< AtomicSwitchoverActor, 16, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 17, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 18, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 19, Void >;
friend struct ActorCallback< AtomicSwitchoverActor, 20, Void >;
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AtomicSwitchoverActor(DatabaseBackupAgent* const& backupAgent,Database const& dest,Key const& tagName,Standalone<VectorRef<KeyRangeRef>> const& backupRanges,Key const& addPrefix,Key const& removePrefix,ForceAction const& forceAction) 
															#line 28250 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   AtomicSwitchoverActorState<AtomicSwitchoverActor>(backupAgent, dest, tagName, backupRanges, addPrefix, removePrefix, forceAction)
	{
		fdb_probe_actor_enter("atomicSwitchover", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("atomicSwitchover");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("atomicSwitchover", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 1, EBackupState >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 2, StatusObject >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 3, StatusObject >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 4, UID >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 5, Void >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 7, Void >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 8, Optional<Value> >*)0, actor_cancelled()); break;
		case 10: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 9, Optional<Value> >*)0, actor_cancelled()); break;
		case 11: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 10, Void >*)0, actor_cancelled()); break;
		case 12: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 11, Void >*)0, actor_cancelled()); break;
		case 13: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 12, Void >*)0, actor_cancelled()); break;
		case 14: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 13, Void >*)0, actor_cancelled()); break;
		case 15: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 14, Void >*)0, actor_cancelled()); break;
		case 16: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 15, Version >*)0, actor_cancelled()); break;
		case 17: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 16, Void >*)0, actor_cancelled()); break;
		case 18: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 17, Void >*)0, actor_cancelled()); break;
		case 19: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 18, Void >*)0, actor_cancelled()); break;
		case 20: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 19, Void >*)0, actor_cancelled()); break;
		case 21: this->a_callback_error((ActorCallback< AtomicSwitchoverActor, 20, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> atomicSwitchover( DatabaseBackupAgent* const& backupAgent, Database const& dest, Key const& tagName, Standalone<VectorRef<KeyRangeRef>> const& backupRanges, Key const& addPrefix, Key const& removePrefix, ForceAction const& forceAction ) {
															#line 2681 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new AtomicSwitchoverActor(backupAgent, dest, tagName, backupRanges, addPrefix, removePrefix, forceAction));
															#line 28297 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2822 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 28302 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via discontinueBackup()
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class DiscontinueBackupActor>
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class DiscontinueBackupActorState {
															#line 28308 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DiscontinueBackupActorState(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName) 
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(tr),
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName)
															#line 28319 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("discontinueBackup", reinterpret_cast<unsigned long>(this));

	}
	~DiscontinueBackupActorState() 
	{
		fdb_probe_actor_destroy("discontinueBackup", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2826 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(tr, tagName);
															#line 2827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<DiscontinueBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 28338 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<DiscontinueBackupActor*>(this)->actor_wait_state = 1;
															#line 2827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< DiscontinueBackupActor, 0, UID >*>(static_cast<DiscontinueBackupActor*>(this)));
															#line 28343 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~DiscontinueBackupActorState();
		static_cast<DiscontinueBackupActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2828 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<EBackupState> __when_expr_1 = backupAgent->getStateValue(tr, logUid);
															#line 2828 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<DiscontinueBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 28368 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1cont1when1(__when_expr_1.get(), loopDepth); };
		static_cast<DiscontinueBackupActor*>(this)->actor_wait_state = 2;
															#line 2828 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< DiscontinueBackupActor, 1, EBackupState >*>(static_cast<DiscontinueBackupActor*>(this)));
															#line 28373 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1when1(UID const& __logUid,int loopDepth) 
	{
															#line 2827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = __logUid;
															#line 28382 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(UID && __logUid,int loopDepth) 
	{
		logUid = std::move(__logUid);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<DiscontinueBackupActor*>(this)->actor_wait_state > 0) static_cast<DiscontinueBackupActor*>(this)->actor_wait_state = 0;
		static_cast<DiscontinueBackupActor*>(this)->ActorCallback< DiscontinueBackupActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< DiscontinueBackupActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< DiscontinueBackupActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< DiscontinueBackupActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 2830 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_Discontinue").detail("Status", status);
															#line 2831 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!DatabaseBackupAgent::isRunnable(status))
															#line 28451 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2832 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1Catch1(backup_unneeded(), loopDepth);
															#line 28455 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2835 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_2 = tr->get(backupAgent->config.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(DatabaseBackupAgent::keyConfigStopWhenDoneKey));
															#line 2835 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<DiscontinueBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 28461 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1cont2when1(__when_expr_2.get(), loopDepth); };
		static_cast<DiscontinueBackupActor*>(this)->actor_wait_state = 3;
															#line 2835 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >*>(static_cast<DiscontinueBackupActor*>(this)));
															#line 28466 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1when1(EBackupState const& __status,int loopDepth) 
	{
															#line 2828 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		status = __status;
															#line 28475 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	int a_body1cont1when1(EBackupState && __status,int loopDepth) 
	{
		status = std::move(__status);
		loopDepth = a_body1cont2(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<DiscontinueBackupActor*>(this)->actor_wait_state > 0) static_cast<DiscontinueBackupActor*>(this)->actor_wait_state = 0;
		static_cast<DiscontinueBackupActor*>(this)->ActorCallback< DiscontinueBackupActor, 1, EBackupState >::remove();

	}
	void a_callback_fire(ActorCallback< DiscontinueBackupActor, 1, EBackupState >*,EBackupState const& value) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< DiscontinueBackupActor, 1, EBackupState >*,EBackupState && value) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< DiscontinueBackupActor, 1, EBackupState >*,Error err) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 2839 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (stopWhenDoneValue.present())
															#line 28542 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2840 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1Catch1(backup_duplicate(), loopDepth);
															#line 28546 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2843 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2844 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2845 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(backupAgent->config.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(BackupAgentBase::keyConfigStopWhenDoneKey), StringRef());
															#line 2849 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<DiscontinueBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~DiscontinueBackupActorState(); static_cast<DiscontinueBackupActor*>(this)->destroy(); return 0; }
															#line 28556 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<DiscontinueBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~DiscontinueBackupActorState();
		static_cast<DiscontinueBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont2when1(Optional<Value> const& __stopWhenDoneValue,int loopDepth) 
	{
															#line 2835 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		stopWhenDoneValue = __stopWhenDoneValue;
															#line 28568 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2when1(Optional<Value> && __stopWhenDoneValue,int loopDepth) 
	{
		stopWhenDoneValue = std::move(__stopWhenDoneValue);
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<DiscontinueBackupActor*>(this)->actor_wait_state > 0) static_cast<DiscontinueBackupActor*>(this)->actor_wait_state = 0;
		static_cast<DiscontinueBackupActor*>(this)->ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), 2);

	}
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2827 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 2828 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	EBackupState status;
															#line 2835 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> stopWhenDoneValue;
															#line 28643 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via discontinueBackup()
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class DiscontinueBackupActor final : public Actor<Void>, public ActorCallback< DiscontinueBackupActor, 0, UID >, public ActorCallback< DiscontinueBackupActor, 1, EBackupState >, public ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >, public FastAllocated<DiscontinueBackupActor>, public DiscontinueBackupActorState<DiscontinueBackupActor> {
															#line 28648 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<DiscontinueBackupActor>::operator new;
	using FastAllocated<DiscontinueBackupActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< DiscontinueBackupActor, 0, UID >;
friend struct ActorCallback< DiscontinueBackupActor, 1, EBackupState >;
friend struct ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >;
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DiscontinueBackupActor(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName) 
															#line 28661 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   DiscontinueBackupActorState<DiscontinueBackupActor>(backupAgent, tr, tagName)
	{
		fdb_probe_actor_enter("discontinueBackup", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("discontinueBackup");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("discontinueBackup", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< DiscontinueBackupActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< DiscontinueBackupActor, 1, EBackupState >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< DiscontinueBackupActor, 2, Optional<Value> >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> discontinueBackup( DatabaseBackupAgent* const& backupAgent, Reference<ReadYourWritesTransaction> const& tr, Key const& tagName ) {
															#line 2823 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new DiscontinueBackupActor(backupAgent, tr, tagName));
															#line 28690 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 2851 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 28695 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via abortBackup()
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class AbortBackupActor>
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AbortBackupActorState {
															#line 28701 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AbortBackupActorState(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName,PartialBackup const& partial,AbortOldBackup const& abortOldBackup,DstOnly const& dstOnly,WaitForDestUID const& waitForDestUID) 
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   cx(cx),
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName),
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   partial(partial),
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   abortOldBackup(abortOldBackup),
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   dstOnly(dstOnly),
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   waitForDestUID(waitForDestUID),
															#line 2859 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(new ReadYourWritesTransaction(cx)),
															#line 2860 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   destUidValue(),
															#line 2861 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   destUid(),
															#line 2862 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   backupUid()
															#line 28728 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("abortBackup", reinterpret_cast<unsigned long>(this));

	}
	~AbortBackupActorState() 
	{
		fdb_probe_actor_destroy("abortBackup", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 2864 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			;
															#line 28743 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~AbortBackupActorState();
		static_cast<AbortBackupActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 2916 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = makeReference<ReadYourWritesTransaction>(cx);
															#line 2917 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 28768 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 2866 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2867 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2868 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::COMMIT_ON_FIRST_PROXY);
															#line 2870 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<UID> __when_expr_0 = backupAgent->getLogUid(tr, tagName);
															#line 2870 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 28793 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 1;
															#line 2870 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 0, UID >*>(static_cast<AbortBackupActor*>(this)));
															#line 28798 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2911 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_AbortError").errorUnsuppressed(e);
															#line 2912 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_4 = tr->onError(e);
															#line 2912 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 28837 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1Catch1(__when_expr_4.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_4.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 5;
															#line 2912 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 4, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 28842 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(UID const& _logUid,int loopDepth) 
	{
															#line 2871 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = _logUid;
															#line 2872 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUidValue = BinaryWriter::toValue(logUid, Unversioned());
															#line 2874 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusFuture = backupAgent->getStateValue(tr, logUid);
															#line 2875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destUidFuture = backupAgent->getDestUid(tr, logUid);
															#line 2876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = success(statusFuture) && success(destUidFuture);
															#line 2876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 28867 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 2;
															#line 2876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 1, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 28872 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(UID && _logUid,int loopDepth) 
	{
															#line 2871 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = _logUid;
															#line 2872 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUidValue = BinaryWriter::toValue(logUid, Unversioned());
															#line 2874 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusFuture = backupAgent->getStateValue(tr, logUid);
															#line 2875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		destUidFuture = backupAgent->getDestUid(tr, logUid);
															#line 2876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_1 = success(statusFuture) && success(destUidFuture);
															#line 2876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 28891 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 2;
															#line 2876 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 1, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 28896 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(UID const& _logUid,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_logUid, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(UID && _logUid,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_logUid), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 0, UID >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 0, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 0, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 0, UID >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 2878 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		EBackupState status = statusFuture.get();
															#line 2879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!backupAgent->isRunnable(status))
															#line 28970 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1loopBody1Catch1(backup_unneeded(), loopDepth);
															#line 28974 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2882 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		UID destUid = destUidFuture.get();
															#line 2883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (destUid.isValid())
															#line 28980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			destUidValue = BinaryWriter::toValue(destUid, Unversioned());
															#line 28984 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
															#line 2885 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (destUidValue.size() == 0 && waitForDestUID)
															#line 28990 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2889 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1loopBody1Catch1(not_committed(), loopDepth);
															#line 28994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 2892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_2 = tr->get(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId));
															#line 2892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29001 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 3;
															#line 2892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 2, Optional<Value> >*>(static_cast<AbortBackupActor*>(this)));
															#line 29006 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 2878 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		EBackupState status = statusFuture.get();
															#line 2879 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!backupAgent->isRunnable(status))
															#line 29017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			return a_body1loopBody1Catch1(backup_unneeded(), loopDepth);
															#line 29021 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 2882 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		UID destUid = destUidFuture.get();
															#line 2883 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (destUid.isValid())
															#line 29027 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2884 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			destUidValue = BinaryWriter::toValue(destUid, Unversioned());
															#line 29031 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
															#line 2885 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (destUidValue.size() == 0 && waitForDestUID)
															#line 29037 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2889 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				return a_body1loopBody1Catch1(not_committed(), loopDepth);
															#line 29041 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 2892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_2 = tr->get(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId));
															#line 2892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 3;
															#line 2892 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 2, Optional<Value> >*>(static_cast<AbortBackupActor*>(this)));
															#line 29053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 1, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 1, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 1, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 1, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont4(Optional<Value> const& _backupUid,int loopDepth) 
	{
															#line 2894 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupUid = _backupUid.get();
															#line 2897 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(backupAgent->config.get(logUidValue).range());
															#line 2900 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(logUidValue.withPrefix(applyMutationsEndRange.begin));
															#line 2902 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(prefixRange(logUidValue.withPrefix(applyLogKeys.begin)));
															#line 2904 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(StringRef(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyStateStatus)), StringRef(DatabaseBackupAgent::getStateText(EBackupState::STATE_PARTIALLY_ABORTED)));
															#line 2907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = tr->commit();
															#line 2907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29137 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 4;
															#line 2907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 3, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29142 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont4(Optional<Value> && _backupUid,int loopDepth) 
	{
															#line 2894 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupUid = _backupUid.get();
															#line 2897 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(backupAgent->config.get(logUidValue).range());
															#line 2900 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(logUidValue.withPrefix(applyMutationsEndRange.begin));
															#line 2902 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->clear(prefixRange(logUidValue.withPrefix(applyLogKeys.begin)));
															#line 2904 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(StringRef(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyStateStatus)), StringRef(DatabaseBackupAgent::getStateText(EBackupState::STATE_PARTIALLY_ABORTED)));
															#line 2907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_3 = tr->commit();
															#line 2907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29163 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont4when1(__when_expr_3.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 4;
															#line 2907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 3, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Optional<Value> const& _backupUid,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(_backupUid, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(Optional<Value> && _backupUid,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont4(std::move(_backupUid), loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 2, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 2, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 2, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 2, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont9(Void const& _,int loopDepth) 
	{
															#line 2908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_Abort").detail("CommitVersion", tr->getCommittedVersion());
															#line 29240 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont9(Void && _,int loopDepth) 
	{
															#line 2908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		TraceEvent("DBA_Abort").detail("CommitVersion", tr->getCommittedVersion());
															#line 29249 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont9(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 3, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 3, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 3, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 3, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 4, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 4, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 4, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 4, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1cont2(int loopDepth) 
	{
															#line 2957 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!dstOnly)
															#line 29396 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2958 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			partialTimeout = partial ? delay(30.0) : Never();
															#line 2959 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr = Reference<ReadYourWritesTransaction>(new ReadYourWritesTransaction(backupAgent->taskBucket->src));
															#line 2961 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			beginVersion = Version();
															#line 2962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			endVersion = Version();
															#line 2964 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			;
															#line 29408 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1cont2loopHead1(loopDepth);
		}
		else
		{
			loopDepth = a_body1cont3(loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1(int loopDepth) 
	{
															#line 2918 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2919 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2927 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::COMMIT_ON_FIRST_PROXY);
															#line 29433 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		try {
															#line 2930 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_5 = tr->get(logUidValue.withPrefix(applyMutationsBeginRange.begin));
															#line 2930 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29439 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1cont1loopBody1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1cont1loopBody1when1(__when_expr_5.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 6;
															#line 2930 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 5, Optional<Value> >*>(static_cast<AbortBackupActor*>(this)));
															#line 29444 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1break1(int loopDepth) 
	{
		try {
			return a_body1cont2(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont1loopHead1(0);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 2953 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_7 = tr->onError(e);
															#line 2953 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 29481 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1Catch1(__when_expr_7.getError(), std::max(0, loopDepth - 1)); else return a_body1cont1loopBody1Catch1when1(__when_expr_7.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 8;
															#line 2953 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 7, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29486 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Optional<Value> const& lastApplied,int loopDepth) 
	{
															#line 2931 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (lastApplied.present())
															#line 29501 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2932 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version current = tr->getReadVersion().get();
															#line 2933 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version applied = BinaryReader::fromStringRef<Version>(lastApplied.get(), Unversioned());
															#line 2934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_AbortVersionUpgrade").detail("Src", applied).detail("Dest", current);
															#line 2935 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (current <= applied)
															#line 29511 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2936 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				TEST(true);
															#line 2939 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr->set(minRequiredCommitVersionKey, BinaryWriter::toValue(applied + 1, Unversioned()));
															#line 29517 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
			else
			{
															#line 2947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr->addWriteConflictRange(singleKeyRange(minRequiredCommitVersionKey));
															#line 29523 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 2950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = tr->commit();
															#line 2950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29530 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont1loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_6.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 7;
															#line 2950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 6, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29535 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2(Optional<Value> && lastApplied,int loopDepth) 
	{
															#line 2931 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (lastApplied.present())
															#line 29544 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2932 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version current = tr->getReadVersion().get();
															#line 2933 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			Version applied = BinaryReader::fromStringRef<Version>(lastApplied.get(), Unversioned());
															#line 2934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			TraceEvent("DBA_AbortVersionUpgrade").detail("Src", applied).detail("Dest", current);
															#line 2935 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (current <= applied)
															#line 29554 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 2936 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				TEST(true);
															#line 2939 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr->set(minRequiredCommitVersionKey, BinaryWriter::toValue(applied + 1, Unversioned()));
															#line 29560 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
			else
			{
															#line 2947 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				tr->addWriteConflictRange(singleKeyRange(minRequiredCommitVersionKey));
															#line 29566 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
															#line 2950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_6 = tr->commit();
															#line 2950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29573 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1cont1loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1cont1loopBody1cont2when1(__when_expr_6.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 7;
															#line 2950 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 6, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29578 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Value> const& lastApplied,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(lastApplied, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1when1(Optional<Value> && lastApplied,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont2(std::move(lastApplied), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 5, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 5, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 5, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 5, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1cont1loopBody1cont3(Void const& _,int loopDepth) 
	{
		return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont3(Void && _,int loopDepth) 
	{
		return a_body1cont1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 6, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 6, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 6, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 6, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1cont1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1cont1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 7, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 7, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 7, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1cont1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 7, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1cont3(int loopDepth) 
	{
															#line 3029 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr = makeReference<ReadYourWritesTransaction>(cx);
															#line 3030 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		;
															#line 29802 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont3loopHead1(loopDepth);

		return loopDepth;
	}
	int a_body1cont4(int loopDepth) 
	{
		loopDepth = a_body1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont2loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1(int loopDepth) 
	{
		try {
															#line 2966 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 2967 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 2968 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			backupVersionF = srcTr->get(backupAgent->sourceStates.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId));
															#line 2970 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_8 = success(backupVersionF) || partialTimeout;
															#line 2970 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29833 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1cont2loopBody1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1cont2loopBody1when1(__when_expr_8.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 9;
															#line 2970 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 8, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29838 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont2loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont2loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2break1(int loopDepth) 
	{
		try {
			return a_body1cont4(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont2loopHead1(0);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3024 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_12 = srcTr->onError(e);
															#line 3024 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 29875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_12.isReady()) { if (__when_expr_12.isError()) return a_body1Catch1(__when_expr_12.getError(), std::max(0, loopDepth - 1)); else return a_body1cont2loopBody1Catch1when1(__when_expr_12.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 13;
															#line 3024 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_12.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 12, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 2971 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 29895 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2972 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 29899 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2975 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupVersionF.get().present() && BinaryReader::fromStringRef<Version>(backupVersionF.get().get(), Unversioned()) > BinaryReader::fromStringRef<Version>(backupUid, Unversioned()))
															#line 29907 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 2981 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (abortOldBackup)
															#line 29913 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2982 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(backupAgent->sourceStates.pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_ABORTED)));
															#line 2984 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(backupAgent->sourceStates.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId), backupUid);
															#line 2986 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->clear(prefixRange(logUidValue.withPrefix(backupLogKeys.begin)));
															#line 2987 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->clear(prefixRange(logUidValue.withPrefix(logRangesRange.begin)));
															#line 29923 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 2991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Key latestVersionKey = logUidValue.withPrefix(destUidValue.withPrefix(backupLatestVersionsPrefix));
															#line 2993 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bVersionF = srcTr->get(latestVersionKey);
															#line 2994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_9 = success(bVersionF) || partialTimeout;
															#line 2994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29934 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1cont2loopBody1Catch1(__when_expr_9.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_9.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 10;
															#line 2994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 9, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29939 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 2971 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 29948 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2972 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 29952 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2975 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupVersionF.get().present() && BinaryReader::fromStringRef<Version>(backupVersionF.get().get(), Unversioned()) > BinaryReader::fromStringRef<Version>(backupUid, Unversioned()))
															#line 29960 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 2981 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (abortOldBackup)
															#line 29966 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2982 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(backupAgent->sourceStates.pack(DatabaseBackupAgent::keyStateStatus), StringRef(BackupAgentBase::getStateText(EBackupState::STATE_ABORTED)));
															#line 2984 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->set(backupAgent->sourceStates.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId), backupUid);
															#line 2986 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->clear(prefixRange(logUidValue.withPrefix(backupLogKeys.begin)));
															#line 2987 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			srcTr->clear(prefixRange(logUidValue.withPrefix(logRangesRange.begin)));
															#line 29976 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 2991 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		Key latestVersionKey = logUidValue.withPrefix(destUidValue.withPrefix(backupLatestVersionsPrefix));
															#line 2993 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		bVersionF = srcTr->get(latestVersionKey);
															#line 2994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_9 = success(bVersionF) || partialTimeout;
															#line 2994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 29987 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1cont2loopBody1Catch1(__when_expr_9.getError(), loopDepth); else return a_body1cont2loopBody1cont2when1(__when_expr_9.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 10;
															#line 2994 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 9, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 29992 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 8, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 8, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 8, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 8, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 8);

	}
	int a_body1cont2loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 2995 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 30064 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2996 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30068 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2999 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (bVersionF.get().present())
															#line 30076 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			beginVersion = BinaryReader::fromStringRef<Version>(bVersionF.get().get(), Unversioned());
															#line 30080 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 3005 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr->set(backupAgent->sourceStates.pack(DatabaseBackupAgent::keyStateStatus), StringRef(DatabaseBackupAgent::getStateText(EBackupState::STATE_PARTIALLY_ABORTED)));
															#line 3007 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr->set(backupAgent->sourceStates.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId), backupUid);
															#line 3010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_10 = eraseLogData(srcTr, logUidValue, destUidValue) || partialTimeout;
															#line 3010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 30094 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1cont2loopBody1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1cont2loopBody1cont3when1(__when_expr_10.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 11;
															#line 3010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 10, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 30099 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 2995 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 30108 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 2996 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30112 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 2999 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (bVersionF.get().present())
															#line 30120 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3000 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			beginVersion = BinaryReader::fromStringRef<Version>(bVersionF.get().get(), Unversioned());
															#line 30124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		else
		{
			return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break
		}
															#line 3005 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr->set(backupAgent->sourceStates.pack(DatabaseBackupAgent::keyStateStatus), StringRef(DatabaseBackupAgent::getStateText(EBackupState::STATE_PARTIALLY_ABORTED)));
															#line 3007 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcTr->set(backupAgent->sourceStates.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId), backupUid);
															#line 3010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_10 = eraseLogData(srcTr, logUidValue, destUidValue) || partialTimeout;
															#line 3010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 30138 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1cont2loopBody1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1cont2loopBody1cont3when1(__when_expr_10.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 11;
															#line 3010 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 10, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 30143 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose10() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 9, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 9, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont2loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 9, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont2loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 9, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 9);

	}
	int a_body1cont2loopBody1cont7(Void const& _,int loopDepth) 
	{
															#line 3011 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 30215 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30219 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_11 = srcTr->commit() || partialTimeout;
															#line 3015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 30229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_11.isReady()) { if (__when_expr_11.isError()) return a_body1cont2loopBody1Catch1(__when_expr_11.getError(), loopDepth); else return a_body1cont2loopBody1cont7when1(__when_expr_11.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 12;
															#line 3015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_11.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 11, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 30234 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont7(Void && _,int loopDepth) 
	{
															#line 3011 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 30243 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3012 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_11 = srcTr->commit() || partialTimeout;
															#line 3015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont2loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 30257 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_11.isReady()) { if (__when_expr_11.isError()) return a_body1cont2loopBody1Catch1(__when_expr_11.getError(), loopDepth); else return a_body1cont2loopBody1cont7when1(__when_expr_11.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 12;
															#line 3015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_11.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 11, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 30262 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont7(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont3when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont7(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose11() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 10, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 10, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont2loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 10, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont2loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 10, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 10);

	}
	int a_body1cont2loopBody1cont11(Void const& _,int loopDepth) 
	{
															#line 3016 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 30334 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30338 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = srcTr->getCommittedVersion() + 1;
															#line 30346 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont2loopBody1cont11(Void && _,int loopDepth) 
	{
															#line 3016 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (partialTimeout.isReady())
															#line 30355 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3017 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30359 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3020 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		endVersion = srcTr->getCommittedVersion() + 1;
															#line 30367 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		return a_body1cont2break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1cont2loopBody1cont7when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont11(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1cont7when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont11(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose12() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 11, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 11, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont2loopBody1cont7when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 11, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont2loopBody1cont7when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 11, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1cont2loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont2loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont2loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 11);

	}
	int a_body1cont2loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont2loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont2loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose13() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 12, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 12, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1cont2loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 12, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1cont2loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 12, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 12);

	}
	int a_body1cont3loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1cont3loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1(int loopDepth) 
	{
		try {
															#line 3032 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 3033 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_13 = tr->get(StringRef(backupAgent->config.get(logUidValue).pack(DatabaseBackupAgent::keyFolderId)));
															#line 3035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 30528 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_13.isReady()) { if (__when_expr_13.isError()) return a_body1cont3loopBody1Catch1(__when_expr_13.getError(), loopDepth); else return a_body1cont3loopBody1when1(__when_expr_13.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 14;
															#line 3035 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_13.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 13, Optional<Value> >*>(static_cast<AbortBackupActor*>(this)));
															#line 30533 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1cont3loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1cont3loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1cont3loopHead1(0);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_15 = tr->onError(e);
															#line 3048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 30557 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_15.isReady()) { if (__when_expr_15.isError()) return a_body1Catch1(__when_expr_15.getError(), std::max(0, loopDepth - 1)); else return a_body1cont3loopBody1Catch1when1(__when_expr_15.get(), loopDepth); };
			static_cast<AbortBackupActor*>(this)->actor_wait_state = 16;
															#line 3048 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_15.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 15, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 30562 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2(Optional<Value> const& v,int loopDepth) 
	{
															#line 3037 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present())
															#line 30577 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3038 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30581 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3041 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(StringRef(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyStateStatus)), StringRef(DatabaseBackupAgent::getStateText(EBackupState::STATE_ABORTED)));
															#line 3044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_14 = tr->commit();
															#line 3044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 30593 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_14.isReady()) { if (__when_expr_14.isError()) return a_body1cont3loopBody1Catch1(__when_expr_14.getError(), loopDepth); else return a_body1cont3loopBody1cont2when1(__when_expr_14.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 15;
															#line 3044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_14.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 14, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 30598 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2(Optional<Value> && v,int loopDepth) 
	{
															#line 3037 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present())
															#line 30607 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3038 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30611 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
			this->~AbortBackupActorState();
			static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
			return 0;
		}
															#line 3041 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->set(StringRef(backupAgent->states.get(logUidValue).pack(DatabaseBackupAgent::keyStateStatus)), StringRef(DatabaseBackupAgent::getStateText(EBackupState::STATE_ABORTED)));
															#line 3044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Void> __when_expr_14 = tr->commit();
															#line 3044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state < 0) return a_body1cont3loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 30623 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_14.isReady()) { if (__when_expr_14.isError()) return a_body1cont3loopBody1Catch1(__when_expr_14.getError(), loopDepth); else return a_body1cont3loopBody1cont2when1(__when_expr_14.get(), loopDepth); };
		static_cast<AbortBackupActor*>(this)->actor_wait_state = 15;
															#line 3044 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_14.addCallbackAndClear(static_cast<ActorCallback< AbortBackupActor, 14, Void >*>(static_cast<AbortBackupActor*>(this)));
															#line 30628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1when1(Optional<Value> const& v,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont2(v, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1when1(Optional<Value> && v,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont2(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose14() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 13, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 13, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont3loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 13);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 13, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont3loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 13);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 13, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 13);
		a_exitChoose14();
		try {
			a_body1cont3loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 13);

	}
	int a_body1cont3loopBody1cont3(Void const& _,int loopDepth) 
	{
															#line 3046 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30700 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~AbortBackupActorState();
		static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont3(Void && _,int loopDepth) 
	{
															#line 3046 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<AbortBackupActor*>(this)->SAV<Void>::futures) { (void)(Void()); this->~AbortBackupActorState(); static_cast<AbortBackupActor*>(this)->destroy(); return 0; }
															#line 30712 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<AbortBackupActor*>(this)->SAV< Void >::value()) Void(Void());
		this->~AbortBackupActorState();
		static_cast<AbortBackupActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont3(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1cont2when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont3(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose15() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 14, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 14, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1cont3loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 14);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 14, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1cont3loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 14);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 14, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 14);
		a_exitChoose15();
		try {
			a_body1cont3loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1cont3loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1cont3loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 14);

	}
	int a_body1cont3loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1cont3loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1cont3loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose16() 
	{
		if (static_cast<AbortBackupActor*>(this)->actor_wait_state > 0) static_cast<AbortBackupActor*>(this)->actor_wait_state = 0;
		static_cast<AbortBackupActor*>(this)->ActorCallback< AbortBackupActor, 15, Void >::remove();

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 15, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 15);
		a_exitChoose16();
		try {
			a_body1cont3loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 15);

	}
	void a_callback_fire(ActorCallback< AbortBackupActor, 15, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 15);
		a_exitChoose16();
		try {
			a_body1cont3loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 15);

	}
	void a_callback_error(ActorCallback< AbortBackupActor, 15, Void >*,Error err) 
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), 15);
		a_exitChoose16();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), 15);

	}
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	PartialBackup partial;
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AbortOldBackup abortOldBackup;
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DstOnly dstOnly;
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	WaitForDestUID waitForDestUID;
															#line 2859 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 2860 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key logUidValue, destUidValue;
															#line 2861 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid, destUid;
															#line 2862 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Value backupUid;
															#line 2874 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<EBackupState> statusFuture;
															#line 2875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<UID> destUidFuture;
															#line 2958 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Void> partialTimeout;
															#line 2959 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> srcTr;
															#line 2961 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version beginVersion;
															#line 2962 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version endVersion;
															#line 2968 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> backupVersionF;
															#line 2993 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Key>> bVersionF;
															#line 30896 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via abortBackup()
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class AbortBackupActor final : public Actor<Void>, public ActorCallback< AbortBackupActor, 0, UID >, public ActorCallback< AbortBackupActor, 1, Void >, public ActorCallback< AbortBackupActor, 2, Optional<Value> >, public ActorCallback< AbortBackupActor, 3, Void >, public ActorCallback< AbortBackupActor, 4, Void >, public ActorCallback< AbortBackupActor, 5, Optional<Value> >, public ActorCallback< AbortBackupActor, 6, Void >, public ActorCallback< AbortBackupActor, 7, Void >, public ActorCallback< AbortBackupActor, 8, Void >, public ActorCallback< AbortBackupActor, 9, Void >, public ActorCallback< AbortBackupActor, 10, Void >, public ActorCallback< AbortBackupActor, 11, Void >, public ActorCallback< AbortBackupActor, 12, Void >, public ActorCallback< AbortBackupActor, 13, Optional<Value> >, public ActorCallback< AbortBackupActor, 14, Void >, public ActorCallback< AbortBackupActor, 15, Void >, public FastAllocated<AbortBackupActor>, public AbortBackupActorState<AbortBackupActor> {
															#line 30901 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<AbortBackupActor>::operator new;
	using FastAllocated<AbortBackupActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<Void>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< AbortBackupActor, 0, UID >;
friend struct ActorCallback< AbortBackupActor, 1, Void >;
friend struct ActorCallback< AbortBackupActor, 2, Optional<Value> >;
friend struct ActorCallback< AbortBackupActor, 3, Void >;
friend struct ActorCallback< AbortBackupActor, 4, Void >;
friend struct ActorCallback< AbortBackupActor, 5, Optional<Value> >;
friend struct ActorCallback< AbortBackupActor, 6, Void >;
friend struct ActorCallback< AbortBackupActor, 7, Void >;
friend struct ActorCallback< AbortBackupActor, 8, Void >;
friend struct ActorCallback< AbortBackupActor, 9, Void >;
friend struct ActorCallback< AbortBackupActor, 10, Void >;
friend struct ActorCallback< AbortBackupActor, 11, Void >;
friend struct ActorCallback< AbortBackupActor, 12, Void >;
friend struct ActorCallback< AbortBackupActor, 13, Optional<Value> >;
friend struct ActorCallback< AbortBackupActor, 14, Void >;
friend struct ActorCallback< AbortBackupActor, 15, Void >;
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	AbortBackupActor(DatabaseBackupAgent* const& backupAgent,Database const& cx,Key const& tagName,PartialBackup const& partial,AbortOldBackup const& abortOldBackup,DstOnly const& dstOnly,WaitForDestUID const& waitForDestUID) 
															#line 30927 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<Void>(),
		   AbortBackupActorState<AbortBackupActor>(backupAgent, cx, tagName, partial, abortOldBackup, dstOnly, waitForDestUID)
	{
		fdb_probe_actor_enter("abortBackup", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("abortBackup");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("abortBackup", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< AbortBackupActor, 0, UID >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< AbortBackupActor, 1, Void >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< AbortBackupActor, 2, Optional<Value> >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< AbortBackupActor, 3, Void >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< AbortBackupActor, 4, Void >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< AbortBackupActor, 5, Optional<Value> >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< AbortBackupActor, 6, Void >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< AbortBackupActor, 7, Void >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< AbortBackupActor, 8, Void >*)0, actor_cancelled()); break;
		case 10: this->a_callback_error((ActorCallback< AbortBackupActor, 9, Void >*)0, actor_cancelled()); break;
		case 11: this->a_callback_error((ActorCallback< AbortBackupActor, 10, Void >*)0, actor_cancelled()); break;
		case 12: this->a_callback_error((ActorCallback< AbortBackupActor, 11, Void >*)0, actor_cancelled()); break;
		case 13: this->a_callback_error((ActorCallback< AbortBackupActor, 12, Void >*)0, actor_cancelled()); break;
		case 14: this->a_callback_error((ActorCallback< AbortBackupActor, 13, Optional<Value> >*)0, actor_cancelled()); break;
		case 15: this->a_callback_error((ActorCallback< AbortBackupActor, 14, Void >*)0, actor_cancelled()); break;
		case 16: this->a_callback_error((ActorCallback< AbortBackupActor, 15, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<Void> abortBackup( DatabaseBackupAgent* const& backupAgent, Database const& cx, Key const& tagName, PartialBackup const& partial, AbortOldBackup const& abortOldBackup, DstOnly const& dstOnly, WaitForDestUID const& waitForDestUID ) {
															#line 2852 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<Void>(new AbortBackupActor(backupAgent, cx, tagName, partial, abortOldBackup, dstOnly, waitForDestUID));
															#line 30969 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 3052 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 30974 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via getStatus()
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class GetStatusActor>
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetStatusActorState {
															#line 30980 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetStatusActorState(DatabaseBackupAgent* const& backupAgent,Database const& cx,int const& errorLimit,Key const& tagName) 
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   cx(cx),
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   errorLimit(errorLimit),
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName),
															#line 3057 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(new ReadYourWritesTransaction(cx))
															#line 30995 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("getStatus", reinterpret_cast<unsigned long>(this));

	}
	~GetStatusActorState() 
	{
		fdb_probe_actor_destroy("getStatus", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3058 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			statusText = std::string();
															#line 3060 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			retries = 0;
															#line 3062 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			;
															#line 31016 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1loopHead1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetStatusActorState();
		static_cast<GetStatusActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 3213 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetStatusActor*>(this)->SAV<std::string>::futures) { (void)(statusText); this->~GetStatusActorState(); static_cast<GetStatusActor*>(this)->destroy(); return 0; }
															#line 31039 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetStatusActor*>(this)->SAV< std::string >::value()) std::string(std::move(statusText)); // state_var_RVO
		this->~GetStatusActorState();
		static_cast<GetStatusActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1loopHead1(int loopDepth) 
	{
		int oldLoopDepth = ++loopDepth;
		while (loopDepth == oldLoopDepth) loopDepth = a_body1loopBody1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1(int loopDepth) 
	{
		try {
															#line 3064 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_0 = success(tr->getReadVersion());
															#line 3064 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31061 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1loopBody1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1loopBody1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 1;
															#line 3064 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 0, Void >*>(static_cast<GetStatusActor*>(this)));
															#line 31066 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1loopBody1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1loopBody1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1break1(int loopDepth) 
	{
		try {
			return a_body1cont1(loopDepth);
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont1(int loopDepth) 
	{
		if (loopDepth == 0) return a_body1loopHead1(0);

		return loopDepth;
	}
	int a_body1loopBody1Catch1(const Error& e,int loopDepth=0) 
	{
		try {
															#line 3204 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			retries++;
															#line 3205 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (retries > 5)
															#line 31103 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			{
															#line 3206 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				statusText += format("\nWARNING: Could not fetch full DR status: %s\n", e.name());
															#line 3207 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				if (!static_cast<GetStatusActor*>(this)->SAV<std::string>::futures) { (void)(statusText); this->~GetStatusActorState(); static_cast<GetStatusActor*>(this)->destroy(); return 0; }
															#line 31109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
				new (&static_cast<GetStatusActor*>(this)->SAV< std::string >::value()) std::string(std::move(statusText)); // state_var_RVO
				this->~GetStatusActorState();
				static_cast<GetStatusActor*>(this)->finishSendAndDelPromiseRef();
				return 0;
			}
															#line 3209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Void> __when_expr_12 = tr->onError(e);
															#line 3209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), std::max(0, loopDepth - 1));
															#line 31119 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_12.isReady()) { if (__when_expr_12.isError()) return a_body1Catch1(__when_expr_12.getError(), std::max(0, loopDepth - 1)); else return a_body1loopBody1Catch1when1(__when_expr_12.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 13;
															#line 3209 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_12.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 12, Void >*>(static_cast<GetStatusActor*>(this)));
															#line 31124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, std::max(0, loopDepth - 1));
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), std::max(0, loopDepth - 1));
		}

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void const& _,int loopDepth) 
	{
															#line 3067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		scrTr = Transaction(backupAgent->taskBucket->src);
															#line 3068 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		scrTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcReadVersion = scrTr.getReadVersion();
															#line 3071 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusText = "";
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<UID> __when_expr_1 = backupAgent->getLogUid(tr, tagName);
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31149 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 2;
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 1, UID >*>(static_cast<GetStatusActor*>(this)));
															#line 31154 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2(Void && _,int loopDepth) 
	{
															#line 3067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		scrTr = Transaction(backupAgent->taskBucket->src);
															#line 3068 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		scrTr.setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		srcReadVersion = scrTr.getReadVersion();
															#line 3071 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusText = "";
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<UID> __when_expr_1 = backupAgent->getLogUid(tr, tagName);
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_1.isReady()) { if (__when_expr_1.isError()) return a_body1loopBody1Catch1(__when_expr_1.getError(), loopDepth); else return a_body1loopBody1cont2when1(__when_expr_1.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 2;
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_1.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 1, UID >*>(static_cast<GetStatusActor*>(this)));
															#line 31178 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont2(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 0, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 0, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 0, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 0, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 0);

	}
	int a_body1loopBody1cont3(int loopDepth) 
	{
															#line 3075 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 3076 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3078 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fPaused = tr->get(backupAgent->taskBucket->getPauseKey());
															#line 3079 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fErrorValues = errorLimit > 0 ? tr->getRange(backupAgent->errors.get(BinaryWriter::toValue(logUid, Unversioned())).range(), errorLimit, Snapshot::False, Reverse::True) : Future<RangeResult>();
															#line 3086 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fBackupUid = tr->get(backupAgent->states.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(DatabaseBackupAgent::keyFolderId));
															#line 3089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fBackupVerison = tr->get(BinaryWriter::toValue(logUid, Unversioned()).withPrefix(applyMutationsBeginRange.begin));
															#line 3091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fTagName = tr->get(backupAgent->states.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(BackupAgentBase::keyConfigBackupTag));
															#line 3094 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fStopVersionKey = tr->get(backupAgent->states.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(BackupAgentBase::keyStateStop));
															#line 3097 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		fBackupKeysPacked = tr->get(backupAgent->config.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(BackupAgentBase::keyConfigBackupRanges));
															#line 3100 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		flogVersionKey = tr->get(backupAgent->states.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(BackupAgentBase::keyStateLogBeginVersion));
															#line 3104 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<EBackupState> __when_expr_2 = backupAgent->getStateValue(tr, logUid);
															#line 3104 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31272 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_2.isReady()) { if (__when_expr_2.isError()) return a_body1loopBody1Catch1(__when_expr_2.getError(), loopDepth); else return a_body1loopBody1cont3when1(__when_expr_2.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 3;
															#line 3104 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_2.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 2, EBackupState >*>(static_cast<GetStatusActor*>(this)));
															#line 31277 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(UID const& __logUid,int loopDepth) 
	{
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = __logUid;
															#line 31286 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont2when1(UID && __logUid,int loopDepth) 
	{
		logUid = std::move(__logUid);
		loopDepth = a_body1loopBody1cont3(loopDepth);

		return loopDepth;
	}
	void a_exitChoose2() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 1, UID >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 1, UID >*,UID const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 1, UID >*,UID && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 1);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 1, UID >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 1);
		a_exitChoose2();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 1);

	}
	int a_body1loopBody1cont4(int loopDepth) 
	{
															#line 3106 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupState == EBackupState::STATE_NEVERRAN)
															#line 31353 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3107 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			statusText += "No previous backups found.\n";
															#line 31357 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = a_body1loopBody1cont5(loopDepth);
		}
		else
		{
															#line 3109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tagNameDisplay = std::string();
															#line 3110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Key>> __when_expr_3 = fTagName;
															#line 3110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31368 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_3.isReady()) { if (__when_expr_3.isError()) return a_body1loopBody1Catch1(__when_expr_3.getError(), loopDepth); else return a_body1loopBody1cont4when1(__when_expr_3.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 4;
															#line 3110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_3.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 3, Optional<Key> >*>(static_cast<GetStatusActor*>(this)));
															#line 31373 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(EBackupState const& __backupState,int loopDepth) 
	{
															#line 3104 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupState = __backupState;
															#line 31383 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont3when1(EBackupState && __backupState,int loopDepth) 
	{
		backupState = std::move(__backupState);
		loopDepth = a_body1loopBody1cont4(loopDepth);

		return loopDepth;
	}
	void a_exitChoose3() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 2, EBackupState >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 2, EBackupState >*,EBackupState const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 2, EBackupState >*,EBackupState && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 2);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 2, EBackupState >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 2);
		a_exitChoose3();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 2);

	}
	int a_body1loopBody1cont5(int loopDepth) 
	{
															#line 3167 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (errorLimit > 0)
															#line 31450 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<RangeResult> __when_expr_7 = fErrorValues;
															#line 3168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31456 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_7.isReady()) { if (__when_expr_7.isError()) return a_body1loopBody1Catch1(__when_expr_7.getError(), loopDepth); else return a_body1loopBody1cont5when1(__when_expr_7.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 8;
															#line 3168 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_7.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 7, RangeResult >*>(static_cast<GetStatusActor*>(this)));
															#line 31461 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont11(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont7(Optional<Key> const& tagName,int loopDepth) 
	{
															#line 3113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (tagName.present())
															#line 31475 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3114 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tagNameDisplay = tagName.get().toString();
															#line 31479 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_4 = fStopVersionKey;
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31485 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont7when1(__when_expr_4.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 5;
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 4, Optional<Value> >*>(static_cast<GetStatusActor*>(this)));
															#line 31490 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont7(Optional<Key> && tagName,int loopDepth) 
	{
															#line 3113 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (tagName.present())
															#line 31499 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3114 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tagNameDisplay = tagName.get().toString();
															#line 31503 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_4 = fStopVersionKey;
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31509 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_4.isReady()) { if (__when_expr_4.isError()) return a_body1loopBody1Catch1(__when_expr_4.getError(), loopDepth); else return a_body1loopBody1cont7when1(__when_expr_4.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 5;
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_4.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 4, Optional<Value> >*>(static_cast<GetStatusActor*>(this)));
															#line 31514 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Optional<Key> const& tagName,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(tagName, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont4when1(Optional<Key> && tagName,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont7(std::move(tagName), loopDepth);

		return loopDepth;
	}
	void a_exitChoose4() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 3, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 3, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 3, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1cont4when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 3);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 3, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 3);
		a_exitChoose4();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 3);

	}
	int a_body1loopBody1cont8(int loopDepth) 
	{
															#line 3118 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_5 = flogVersionKey;
															#line 3118 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31588 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_5.isReady()) { if (__when_expr_5.isError()) return a_body1loopBody1Catch1(__when_expr_5.getError(), loopDepth); else return a_body1loopBody1cont8when1(__when_expr_5.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 6;
															#line 3118 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_5.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 5, Optional<Value> >*>(static_cast<GetStatusActor*>(this)));
															#line 31593 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont7when1(Optional<Value> const& __stopVersionKey,int loopDepth) 
	{
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		stopVersionKey = __stopVersionKey;
															#line 31602 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont8(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont7when1(Optional<Value> && __stopVersionKey,int loopDepth) 
	{
		stopVersionKey = std::move(__stopVersionKey);
		loopDepth = a_body1loopBody1cont8(loopDepth);

		return loopDepth;
	}
	void a_exitChoose5() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 4, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 4, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont7when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 4, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1cont7when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 4);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 4, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 4);
		a_exitChoose5();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 4);

	}
	int a_body1loopBody1cont10(Optional<Value> const& logVersionKey,int loopDepth) 
	{
															#line 3119 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logVersionText = ". Last log version is " + (logVersionKey.present() ? format("%lld", BinaryReader::fromStringRef<Version>(logVersionKey.get(), Unversioned())) : "unset");
															#line 3124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_6 = fBackupKeysPacked;
															#line 3124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31673 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1loopBody1cont10when1(__when_expr_6.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 7;
															#line 3124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 6, Optional<Key> >*>(static_cast<GetStatusActor*>(this)));
															#line 31678 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont10(Optional<Value> && logVersionKey,int loopDepth) 
	{
															#line 3119 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logVersionText = ". Last log version is " + (logVersionKey.present() ? format("%lld", BinaryReader::fromStringRef<Version>(logVersionKey.get(), Unversioned())) : "unset");
															#line 3124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Key>> __when_expr_6 = fBackupKeysPacked;
															#line 3124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31691 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_6.isReady()) { if (__when_expr_6.isError()) return a_body1loopBody1Catch1(__when_expr_6.getError(), loopDepth); else return a_body1loopBody1cont10when1(__when_expr_6.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 7;
															#line 3124 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_6.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 6, Optional<Key> >*>(static_cast<GetStatusActor*>(this)));
															#line 31696 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont8when1(Optional<Value> const& logVersionKey,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10(logVersionKey, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont8when1(Optional<Value> && logVersionKey,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10(std::move(logVersionKey), loopDepth);

		return loopDepth;
	}
	void a_exitChoose6() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 5, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 5, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1cont8when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 5, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1cont8when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 5);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 5, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 5);
		a_exitChoose6();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 5);

	}
	int a_body1loopBody1cont10cont1(Optional<Key> const& backupKeysPacked,int loopDepth) 
	{
															#line 3126 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = Standalone<VectorRef<KeyRangeRef>>();
															#line 3127 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupKeysPacked.present())
															#line 31770 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3128 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			BinaryReader br(backupKeysPacked.get(), IncludeVersion());
															#line 3129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			br >> backupRanges;
															#line 31776 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 3132 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		switch (backupState) { case EBackupState::STATE_SUBMITTED: statusText += "The DR on tag `" + tagNameDisplay + "' is NOT a complete copy of the primary database (just started).\n"; break; case EBackupState::STATE_RUNNING: statusText += "The DR on tag `" + tagNameDisplay + "' is NOT a complete copy of the primary database.\n"; break; case EBackupState::STATE_RUNNING_DIFFERENTIAL: statusText += "The DR on tag `" + tagNameDisplay + "' is a complete copy of the primary database" + logVersionText + ".\n"; break; case EBackupState::STATE_COMPLETED: { Version stopVersion = stopVersionKey.present() ? BinaryReader::fromStringRef<Version>(stopVersionKey.get(), Unversioned()) : -1; statusText += "The previous DR on tag `" + tagNameDisplay + "' completed at version " + format("%lld", stopVersion) + ".\n"; } break; case EBackupState::STATE_PARTIALLY_ABORTED: { statusText += "The previous DR on tag `" + tagNameDisplay + "' " + BackupAgentBase::getStateText(backupState) + logVersionText + ".\n"; statusText += "Abort the DR with --cleanup before starting a new DR.\n"; break; } default: statusText += "The previous DR on tag `" + tagNameDisplay + "' " + BackupAgentBase::getStateText(backupState) + logVersionText + ".\n"; break; };
															#line 31780 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont10cont1(Optional<Key> && backupKeysPacked,int loopDepth) 
	{
															#line 3126 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		backupRanges = Standalone<VectorRef<KeyRangeRef>>();
															#line 3127 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupKeysPacked.present())
															#line 31791 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3128 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			BinaryReader br(backupKeysPacked.get(), IncludeVersion());
															#line 3129 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			br >> backupRanges;
															#line 31797 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
															#line 3132 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		switch (backupState) { case EBackupState::STATE_SUBMITTED: statusText += "The DR on tag `" + tagNameDisplay + "' is NOT a complete copy of the primary database (just started).\n"; break; case EBackupState::STATE_RUNNING: statusText += "The DR on tag `" + tagNameDisplay + "' is NOT a complete copy of the primary database.\n"; break; case EBackupState::STATE_RUNNING_DIFFERENTIAL: statusText += "The DR on tag `" + tagNameDisplay + "' is a complete copy of the primary database" + logVersionText + ".\n"; break; case EBackupState::STATE_COMPLETED: { Version stopVersion = stopVersionKey.present() ? BinaryReader::fromStringRef<Version>(stopVersionKey.get(), Unversioned()) : -1; statusText += "The previous DR on tag `" + tagNameDisplay + "' completed at version " + format("%lld", stopVersion) + ".\n"; } break; case EBackupState::STATE_PARTIALLY_ABORTED: { statusText += "The previous DR on tag `" + tagNameDisplay + "' " + BackupAgentBase::getStateText(backupState) + logVersionText + ".\n"; statusText += "Abort the DR with --cleanup before starting a new DR.\n"; break; } default: statusText += "The previous DR on tag `" + tagNameDisplay + "' " + BackupAgentBase::getStateText(backupState) + logVersionText + ".\n"; break; };
															#line 31801 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont5(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont10when1(Optional<Key> const& backupKeysPacked,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10cont1(backupKeysPacked, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont10when1(Optional<Key> && backupKeysPacked,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont10cont1(std::move(backupKeysPacked), loopDepth);

		return loopDepth;
	}
	void a_exitChoose7() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 6, Optional<Key> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 6, Optional<Key> >*,Optional<Key> const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1loopBody1cont10when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 6, Optional<Key> >*,Optional<Key> && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1loopBody1cont10when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 6);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 6, Optional<Key> >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 6);
		a_exitChoose7();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 6);

	}
	int a_body1loopBody1cont11(int loopDepth) 
	{
															#line 3185 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_8 = fBackupUid;
															#line 3185 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31875 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_8.isReady()) { if (__when_expr_8.isError()) return a_body1loopBody1Catch1(__when_expr_8.getError(), loopDepth); else return a_body1loopBody1cont11when1(__when_expr_8.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 9;
															#line 3185 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_8.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 8, Optional<Value> >*>(static_cast<GetStatusActor*>(this)));
															#line 31880 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont12(RangeResult const& values,int loopDepth) 
	{
															#line 3171 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (values.size() > 0)
															#line 31889 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			statusText += (values.size() < errorLimit) ? "WARNING: Some DR agents have reported issues:\n" : "WARNING: Some DR agents have reported issues (printing " + std::to_string(errorLimit) + "):\n";
															#line 3178 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto& s : values ) {
															#line 3179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				statusText += "   " + printable(s.value) + "\n";
															#line 31897 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
		loopDepth = a_body1loopBody1cont11(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont12(RangeResult && values,int loopDepth) 
	{
															#line 3171 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (values.size() > 0)
															#line 31908 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3173 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			statusText += (values.size() < errorLimit) ? "WARNING: Some DR agents have reported issues:\n" : "WARNING: Some DR agents have reported issues (printing " + std::to_string(errorLimit) + "):\n";
															#line 3178 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			for( auto& s : values ) {
															#line 3179 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
				statusText += "   " + printable(s.value) + "\n";
															#line 31916 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			}
		}
		loopDepth = a_body1loopBody1cont11(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont5when1(RangeResult const& values,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont12(values, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont5when1(RangeResult && values,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont12(std::move(values), loopDepth);

		return loopDepth;
	}
	void a_exitChoose8() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 7, RangeResult >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 7, RangeResult >*,RangeResult const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1loopBody1cont5when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 7, RangeResult >*,RangeResult && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1loopBody1cont5when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 7);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 7, RangeResult >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 7);
		a_exitChoose8();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 7);

	}
	int a_body1loopBody1cont11cont1(Optional<Value> const& backupUid,int loopDepth) 
	{
															#line 3186 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupUid.present())
															#line 31990 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_9 = fBackupVerison;
															#line 3187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 31996 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1loopBody1Catch1(__when_expr_9.getError(), loopDepth); else return a_body1loopBody1cont11cont1when1(__when_expr_9.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 10;
															#line 3187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 9, Optional<Value> >*>(static_cast<GetStatusActor*>(this)));
															#line 32001 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont11cont2(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont11cont1(Optional<Value> && backupUid,int loopDepth) 
	{
															#line 3186 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (backupUid.present())
															#line 32015 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_9 = fBackupVerison;
															#line 3187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 32021 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_9.isReady()) { if (__when_expr_9.isError()) return a_body1loopBody1Catch1(__when_expr_9.getError(), loopDepth); else return a_body1loopBody1cont11cont1when1(__when_expr_9.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 10;
															#line 3187 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_9.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 9, Optional<Value> >*>(static_cast<GetStatusActor*>(this)));
															#line 32026 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont11cont2(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont11when1(Optional<Value> const& backupUid,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont1(backupUid, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11when1(Optional<Value> && backupUid,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont1(std::move(backupUid), loopDepth);

		return loopDepth;
	}
	void a_exitChoose9() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 8, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 8, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1loopBody1cont11when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 8, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1loopBody1cont11when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 8);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 8, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 8);
		a_exitChoose9();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 8);

	}
	int a_body1loopBody1cont11cont2(int loopDepth) 
	{
															#line 3197 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		StrictFuture<Optional<Value>> __when_expr_11 = fPaused;
															#line 3197 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 32105 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		if (__when_expr_11.isReady()) { if (__when_expr_11.isError()) return a_body1loopBody1Catch1(__when_expr_11.getError(), loopDepth); else return a_body1loopBody1cont11cont2when1(__when_expr_11.get(), loopDepth); };
		static_cast<GetStatusActor*>(this)->actor_wait_state = 12;
															#line 3197 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		__when_expr_11.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 11, Optional<Value> >*>(static_cast<GetStatusActor*>(this)));
															#line 32110 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1loopBody1cont11cont3(Optional<Value> const& v,int loopDepth) 
	{
															#line 3188 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present())
															#line 32119 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3189 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			destApplyBegin = BinaryReader::fromStringRef<Version>(v.get(), Unversioned());
															#line 3190 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Version> __when_expr_10 = srcReadVersion;
															#line 3190 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 32127 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1loopBody1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1loopBody1cont11cont3when1(__when_expr_10.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 11;
															#line 3190 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 10, Version >*>(static_cast<GetStatusActor*>(this)));
															#line 32132 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont11cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont11cont3(Optional<Value> && v,int loopDepth) 
	{
															#line 3188 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (v.present())
															#line 32146 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3189 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			destApplyBegin = BinaryReader::fromStringRef<Version>(v.get(), Unversioned());
															#line 3190 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Version> __when_expr_10 = srcReadVersion;
															#line 3190 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStatusActor*>(this)->actor_wait_state < 0) return a_body1loopBody1Catch1(actor_cancelled(), loopDepth);
															#line 32154 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_10.isReady()) { if (__when_expr_10.isError()) return a_body1loopBody1Catch1(__when_expr_10.getError(), loopDepth); else return a_body1loopBody1cont11cont3when1(__when_expr_10.get(), loopDepth); };
			static_cast<GetStatusActor*>(this)->actor_wait_state = 11;
															#line 3190 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_10.addCallbackAndClear(static_cast<ActorCallback< GetStatusActor, 10, Version >*>(static_cast<GetStatusActor*>(this)));
															#line 32159 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		else
		{
			loopDepth = a_body1loopBody1cont11cont4(loopDepth);
		}

		return loopDepth;
	}
	int a_body1loopBody1cont11cont1when1(Optional<Value> const& v,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont3(v, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11cont1when1(Optional<Value> && v,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont3(std::move(v), loopDepth);

		return loopDepth;
	}
	void a_exitChoose10() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 9, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 9, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1loopBody1cont11cont1when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 9, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1loopBody1cont11cont1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 9);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 9, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 9);
		a_exitChoose10();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 9);

	}
	int a_body1loopBody1cont11cont4(int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont2(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11cont5(Version const& sourceVersion,int loopDepth) 
	{
															#line 3191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		double secondsBehind = ((double)(sourceVersion - destApplyBegin)) / CLIENT_KNOBS->CORE_VERSIONSPERSECOND;
															#line 3193 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusText += format("\nThe DR is %.6f seconds behind.\n", secondsBehind);
															#line 32244 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont11cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11cont5(Version && sourceVersion,int loopDepth) 
	{
															#line 3191 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		double secondsBehind = ((double)(sourceVersion - destApplyBegin)) / CLIENT_KNOBS->CORE_VERSIONSPERSECOND;
															#line 3193 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		statusText += format("\nThe DR is %.6f seconds behind.\n", secondsBehind);
															#line 32255 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1loopBody1cont11cont4(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11cont3when1(Version const& sourceVersion,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont5(sourceVersion, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11cont3when1(Version && sourceVersion,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont5(std::move(sourceVersion), loopDepth);

		return loopDepth;
	}
	void a_exitChoose11() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 10, Version >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 10, Version >*,Version const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1loopBody1cont11cont3when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 10, Version >*,Version && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1loopBody1cont11cont3when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 10);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 10, Version >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 10);
		a_exitChoose11();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 10);

	}
	int a_body1loopBody1cont11cont7(Optional<Value> const& paused,int loopDepth) 
	{
															#line 3198 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (paused.present())
															#line 32327 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3199 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			statusText += format("\nAll DR agents have been paused.\n");
															#line 32331 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont11cont7(Optional<Value> && paused,int loopDepth) 
	{
															#line 3198 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (paused.present())
															#line 32341 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		{
															#line 3199 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			statusText += format("\nAll DR agents have been paused.\n");
															#line 32345 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		}
		return a_body1break1(loopDepth==0?0:loopDepth-1); // break

		return loopDepth;
	}
	int a_body1loopBody1cont11cont2when1(Optional<Value> const& paused,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont7(paused, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1cont11cont2when1(Optional<Value> && paused,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont11cont7(std::move(paused), loopDepth);

		return loopDepth;
	}
	void a_exitChoose12() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 11, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 11, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1loopBody1cont11cont2when1(value, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 11, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1loopBody1cont11cont2when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 11);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 11, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 11);
		a_exitChoose12();
		try {
			a_body1loopBody1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1loopBody1Catch1(error, 0);
		} catch (...) {
			a_body1loopBody1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 11);

	}
	int a_body1loopBody1Catch1cont1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1cont1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void const& _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(_, loopDepth);

		return loopDepth;
	}
	int a_body1loopBody1Catch1when1(Void && _,int loopDepth) 
	{
		loopDepth = a_body1loopBody1Catch1cont1(std::move(_), loopDepth);

		return loopDepth;
	}
	void a_exitChoose13() 
	{
		if (static_cast<GetStatusActor*>(this)->actor_wait_state > 0) static_cast<GetStatusActor*>(this)->actor_wait_state = 0;
		static_cast<GetStatusActor*>(this)->ActorCallback< GetStatusActor, 12, Void >::remove();

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 12, Void >*,Void const& value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1loopBody1Catch1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_fire(ActorCallback< GetStatusActor, 12, Void >*,Void && value) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1loopBody1Catch1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 12);

	}
	void a_callback_error(ActorCallback< GetStatusActor, 12, Void >*,Error err) 
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), 12);
		a_exitChoose13();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), 12);

	}
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Database cx;
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int errorLimit;
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 3057 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 3059 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::string statusText;
															#line 3060 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	int retries;
															#line 3067 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Transaction scrTr;
															#line 3069 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Version> srcReadVersion;
															#line 3073 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 3078 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> fPaused;
															#line 3079 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<RangeResult> fErrorValues;
															#line 3086 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> fBackupUid;
															#line 3089 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> fBackupVerison;
															#line 3091 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Key>> fTagName;
															#line 3094 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> fStopVersionKey;
															#line 3097 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Key>> fBackupKeysPacked;
															#line 3100 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Future<Optional<Value>> flogVersionKey;
															#line 3104 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	EBackupState backupState;
															#line 3109 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::string tagNameDisplay;
															#line 3117 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> stopVersionKey;
															#line 3119 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	std::string logVersionText;
															#line 3126 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Standalone<VectorRef<KeyRangeRef>> backupRanges;
															#line 3189 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Version destApplyBegin;
															#line 32537 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via getStatus()
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetStatusActor final : public Actor<std::string>, public ActorCallback< GetStatusActor, 0, Void >, public ActorCallback< GetStatusActor, 1, UID >, public ActorCallback< GetStatusActor, 2, EBackupState >, public ActorCallback< GetStatusActor, 3, Optional<Key> >, public ActorCallback< GetStatusActor, 4, Optional<Value> >, public ActorCallback< GetStatusActor, 5, Optional<Value> >, public ActorCallback< GetStatusActor, 6, Optional<Key> >, public ActorCallback< GetStatusActor, 7, RangeResult >, public ActorCallback< GetStatusActor, 8, Optional<Value> >, public ActorCallback< GetStatusActor, 9, Optional<Value> >, public ActorCallback< GetStatusActor, 10, Version >, public ActorCallback< GetStatusActor, 11, Optional<Value> >, public ActorCallback< GetStatusActor, 12, Void >, public FastAllocated<GetStatusActor>, public GetStatusActorState<GetStatusActor> {
															#line 32542 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<GetStatusActor>::operator new;
	using FastAllocated<GetStatusActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<std::string>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetStatusActor, 0, Void >;
friend struct ActorCallback< GetStatusActor, 1, UID >;
friend struct ActorCallback< GetStatusActor, 2, EBackupState >;
friend struct ActorCallback< GetStatusActor, 3, Optional<Key> >;
friend struct ActorCallback< GetStatusActor, 4, Optional<Value> >;
friend struct ActorCallback< GetStatusActor, 5, Optional<Value> >;
friend struct ActorCallback< GetStatusActor, 6, Optional<Key> >;
friend struct ActorCallback< GetStatusActor, 7, RangeResult >;
friend struct ActorCallback< GetStatusActor, 8, Optional<Value> >;
friend struct ActorCallback< GetStatusActor, 9, Optional<Value> >;
friend struct ActorCallback< GetStatusActor, 10, Version >;
friend struct ActorCallback< GetStatusActor, 11, Optional<Value> >;
friend struct ActorCallback< GetStatusActor, 12, Void >;
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetStatusActor(DatabaseBackupAgent* const& backupAgent,Database const& cx,int const& errorLimit,Key const& tagName) 
															#line 32565 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<std::string>(),
		   GetStatusActorState<GetStatusActor>(backupAgent, cx, errorLimit, tagName)
	{
		fdb_probe_actor_enter("getStatus", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getStatus");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getStatus", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetStatusActor, 0, Void >*)0, actor_cancelled()); break;
		case 2: this->a_callback_error((ActorCallback< GetStatusActor, 1, UID >*)0, actor_cancelled()); break;
		case 3: this->a_callback_error((ActorCallback< GetStatusActor, 2, EBackupState >*)0, actor_cancelled()); break;
		case 4: this->a_callback_error((ActorCallback< GetStatusActor, 3, Optional<Key> >*)0, actor_cancelled()); break;
		case 5: this->a_callback_error((ActorCallback< GetStatusActor, 4, Optional<Value> >*)0, actor_cancelled()); break;
		case 6: this->a_callback_error((ActorCallback< GetStatusActor, 5, Optional<Value> >*)0, actor_cancelled()); break;
		case 7: this->a_callback_error((ActorCallback< GetStatusActor, 6, Optional<Key> >*)0, actor_cancelled()); break;
		case 8: this->a_callback_error((ActorCallback< GetStatusActor, 7, RangeResult >*)0, actor_cancelled()); break;
		case 9: this->a_callback_error((ActorCallback< GetStatusActor, 8, Optional<Value> >*)0, actor_cancelled()); break;
		case 10: this->a_callback_error((ActorCallback< GetStatusActor, 9, Optional<Value> >*)0, actor_cancelled()); break;
		case 11: this->a_callback_error((ActorCallback< GetStatusActor, 10, Version >*)0, actor_cancelled()); break;
		case 12: this->a_callback_error((ActorCallback< GetStatusActor, 11, Optional<Value> >*)0, actor_cancelled()); break;
		case 13: this->a_callback_error((ActorCallback< GetStatusActor, 12, Void >*)0, actor_cancelled()); break;
		}

	}
};
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<std::string> getStatus( DatabaseBackupAgent* const& backupAgent, Database const& cx, int const& errorLimit, Key const& tagName ) {
															#line 3053 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<std::string>(new GetStatusActor(backupAgent, cx, errorLimit, tagName));
															#line 32604 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 3215 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 32609 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via getStateValue()
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class GetStateValueActor>
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetStateValueActorState {
															#line 32615 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetStateValueActorState(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,UID const& logUid,Snapshot const& snapshot) 
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(tr),
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUid(logUid),
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   snapshot(snapshot)
															#line 32628 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("getStateValue", reinterpret_cast<unsigned long>(this));

	}
	~GetStateValueActorState() 
	{
		fdb_probe_actor_destroy("getStateValue", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3220 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 3221 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3222 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			statusKey = backupAgent->states.get(BinaryWriter::toValue(logUid, Unversioned())) .pack(DatabaseBackupAgent::keyStateStatus);
															#line 3224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = tr->get(statusKey, snapshot);
															#line 3224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetStateValueActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 32651 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetStateValueActor*>(this)->actor_wait_state = 1;
															#line 3224 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetStateValueActor, 0, Optional<Value> >*>(static_cast<GetStateValueActor*>(this)));
															#line 32656 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetStateValueActorState();
		static_cast<GetStateValueActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Optional<Value> const& status,int loopDepth) 
	{
															#line 3226 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetStateValueActor*>(this)->SAV<EBackupState>::futures) { (void)((!status.present()) ? EBackupState::STATE_NEVERRAN : BackupAgentBase::getState(status.get().toString())); this->~GetStateValueActorState(); static_cast<GetStateValueActor*>(this)->destroy(); return 0; }
															#line 32679 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetStateValueActor*>(this)->SAV< EBackupState >::value()) EBackupState((!status.present()) ? EBackupState::STATE_NEVERRAN : BackupAgentBase::getState(status.get().toString()));
		this->~GetStateValueActorState();
		static_cast<GetStateValueActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Optional<Value> && status,int loopDepth) 
	{
															#line 3226 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetStateValueActor*>(this)->SAV<EBackupState>::futures) { (void)((!status.present()) ? EBackupState::STATE_NEVERRAN : BackupAgentBase::getState(status.get().toString())); this->~GetStateValueActorState(); static_cast<GetStateValueActor*>(this)->destroy(); return 0; }
															#line 32691 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetStateValueActor*>(this)->SAV< EBackupState >::value()) EBackupState((!status.present()) ? EBackupState::STATE_NEVERRAN : BackupAgentBase::getState(status.get().toString()));
		this->~GetStateValueActorState();
		static_cast<GetStateValueActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Optional<Value> const& status,int loopDepth) 
	{
		loopDepth = a_body1cont1(status, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Optional<Value> && status,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(status), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetStateValueActor*>(this)->actor_wait_state > 0) static_cast<GetStateValueActor*>(this)->actor_wait_state = 0;
		static_cast<GetStateValueActor*>(this)->ActorCallback< GetStateValueActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetStateValueActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getStateValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStateValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetStateValueActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getStateValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStateValue", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetStateValueActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getStateValue", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getStateValue", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Snapshot snapshot;
															#line 3222 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key statusKey;
															#line 32772 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via getStateValue()
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetStateValueActor final : public Actor<EBackupState>, public ActorCallback< GetStateValueActor, 0, Optional<Value> >, public FastAllocated<GetStateValueActor>, public GetStateValueActorState<GetStateValueActor> {
															#line 32777 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<GetStateValueActor>::operator new;
	using FastAllocated<GetStateValueActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<EBackupState>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetStateValueActor, 0, Optional<Value> >;
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetStateValueActor(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,UID const& logUid,Snapshot const& snapshot) 
															#line 32788 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<EBackupState>(),
		   GetStateValueActorState<GetStateValueActor>(backupAgent, tr, logUid, snapshot)
	{
		fdb_probe_actor_enter("getStateValue", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getStateValue");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getStateValue", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetStateValueActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		}

	}
};
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<EBackupState> getStateValue( DatabaseBackupAgent* const& backupAgent, Reference<ReadYourWritesTransaction> const& tr, UID const& logUid, Snapshot const& snapshot ) {
															#line 3216 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<EBackupState>(new GetStateValueActor(backupAgent, tr, logUid, snapshot));
															#line 32815 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 3228 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 32820 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via getDestUid()
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class GetDestUidActor>
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetDestUidActorState {
															#line 32826 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetDestUidActorState(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,UID const& logUid,Snapshot const& snapshot) 
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(tr),
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   logUid(logUid),
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   snapshot(snapshot)
															#line 32839 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("getDestUid", reinterpret_cast<unsigned long>(this));

	}
	~GetDestUidActorState() 
	{
		fdb_probe_actor_destroy("getDestUid", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3233 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 3234 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			destUidKey = backupAgent->config.get(BinaryWriter::toValue(logUid, Unversioned())).pack(BackupAgentBase::destUid);
															#line 3237 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = tr->get(destUidKey, snapshot);
															#line 3237 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetDestUidActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 32862 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetDestUidActor*>(this)->actor_wait_state = 1;
															#line 3237 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetDestUidActor, 0, Optional<Value> >*>(static_cast<GetDestUidActor*>(this)));
															#line 32867 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetDestUidActorState();
		static_cast<GetDestUidActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(Optional<Value> const& destUid,int loopDepth) 
	{
															#line 3239 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetDestUidActor*>(this)->SAV<UID>::futures) { (void)((destUid.present()) ? BinaryReader::fromStringRef<UID>(destUid.get(), Unversioned()) : UID()); this->~GetDestUidActorState(); static_cast<GetDestUidActor*>(this)->destroy(); return 0; }
															#line 32890 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetDestUidActor*>(this)->SAV< UID >::value()) UID((destUid.present()) ? BinaryReader::fromStringRef<UID>(destUid.get(), Unversioned()) : UID());
		this->~GetDestUidActorState();
		static_cast<GetDestUidActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1cont1(Optional<Value> && destUid,int loopDepth) 
	{
															#line 3239 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetDestUidActor*>(this)->SAV<UID>::futures) { (void)((destUid.present()) ? BinaryReader::fromStringRef<UID>(destUid.get(), Unversioned()) : UID()); this->~GetDestUidActorState(); static_cast<GetDestUidActor*>(this)->destroy(); return 0; }
															#line 32902 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetDestUidActor*>(this)->SAV< UID >::value()) UID((destUid.present()) ? BinaryReader::fromStringRef<UID>(destUid.get(), Unversioned()) : UID());
		this->~GetDestUidActorState();
		static_cast<GetDestUidActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Optional<Value> const& destUid,int loopDepth) 
	{
		loopDepth = a_body1cont1(destUid, loopDepth);

		return loopDepth;
	}
	int a_body1when1(Optional<Value> && destUid,int loopDepth) 
	{
		loopDepth = a_body1cont1(std::move(destUid), loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetDestUidActor*>(this)->actor_wait_state > 0) static_cast<GetDestUidActor*>(this)->actor_wait_state = 0;
		static_cast<GetDestUidActor*>(this)->ActorCallback< GetDestUidActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetDestUidActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getDestUid", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getDestUid", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetDestUidActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getDestUid", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getDestUid", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetDestUidActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getDestUid", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getDestUid", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	UID logUid;
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Snapshot snapshot;
															#line 3235 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key destUidKey;
															#line 32983 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via getDestUid()
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetDestUidActor final : public Actor<UID>, public ActorCallback< GetDestUidActor, 0, Optional<Value> >, public FastAllocated<GetDestUidActor>, public GetDestUidActorState<GetDestUidActor> {
															#line 32988 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<GetDestUidActor>::operator new;
	using FastAllocated<GetDestUidActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<UID>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetDestUidActor, 0, Optional<Value> >;
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetDestUidActor(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,UID const& logUid,Snapshot const& snapshot) 
															#line 32999 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<UID>(),
		   GetDestUidActorState<GetDestUidActor>(backupAgent, tr, logUid, snapshot)
	{
		fdb_probe_actor_enter("getDestUid", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getDestUid");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getDestUid", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetDestUidActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		}

	}
};
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<UID> getDestUid( DatabaseBackupAgent* const& backupAgent, Reference<ReadYourWritesTransaction> const& tr, UID const& logUid, Snapshot const& snapshot ) {
															#line 3229 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<UID>(new GetDestUidActor(backupAgent, tr, logUid, snapshot));
															#line 33026 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 3241 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"

																#line 33031 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
// This generated class is to be used only via getLogUid()
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
template <class GetLogUidActor>
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetLogUidActorState {
															#line 33037 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetLogUidActorState(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName,Snapshot const& snapshot) 
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		 : backupAgent(backupAgent),
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tr(tr),
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   tagName(tagName),
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		   snapshot(snapshot)
															#line 33050 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
	{
		fdb_probe_actor_create("getLogUid", reinterpret_cast<unsigned long>(this));

	}
	~GetLogUidActorState() 
	{
		fdb_probe_actor_destroy("getLogUid", reinterpret_cast<unsigned long>(this));

	}
	int a_body1(int loopDepth=0) 
	{
		try {
															#line 3246 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::ACCESS_SYSTEM_KEYS);
															#line 3247 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			tr->setOption(FDBTransactionOptions::LOCK_AWARE);
															#line 3248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			StrictFuture<Optional<Value>> __when_expr_0 = tr->get(backupAgent->tagNames.pack(tagName), snapshot);
															#line 3248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			if (static_cast<GetLogUidActor*>(this)->actor_wait_state < 0) return a_body1Catch1(actor_cancelled(), loopDepth);
															#line 33071 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			if (__when_expr_0.isReady()) { if (__when_expr_0.isError()) return a_body1Catch1(__when_expr_0.getError(), loopDepth); else return a_body1when1(__when_expr_0.get(), loopDepth); };
			static_cast<GetLogUidActor*>(this)->actor_wait_state = 1;
															#line 3248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
			__when_expr_0.addCallbackAndClear(static_cast<ActorCallback< GetLogUidActor, 0, Optional<Value> >*>(static_cast<GetLogUidActor*>(this)));
															#line 33076 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
			loopDepth = 0;
		}
		catch (Error& error) {
			loopDepth = a_body1Catch1(error, loopDepth);
		} catch (...) {
			loopDepth = a_body1Catch1(unknown_error(), loopDepth);
		}

		return loopDepth;
	}
	int a_body1Catch1(Error error,int loopDepth=0) 
	{
		this->~GetLogUidActorState();
		static_cast<GetLogUidActor*>(this)->sendErrorAndDelPromiseRef(error);
		loopDepth = 0;

		return loopDepth;
	}
	int a_body1cont1(int loopDepth) 
	{
															#line 3250 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		if (!static_cast<GetLogUidActor*>(this)->SAV<UID>::futures) { (void)((logUid.present()) ? BinaryReader::fromStringRef<UID>(logUid.get(), Unversioned()) : UID()); this->~GetLogUidActorState(); static_cast<GetLogUidActor*>(this)->destroy(); return 0; }
															#line 33099 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		new (&static_cast<GetLogUidActor*>(this)->SAV< UID >::value()) UID((logUid.present()) ? BinaryReader::fromStringRef<UID>(logUid.get(), Unversioned()) : UID());
		this->~GetLogUidActorState();
		static_cast<GetLogUidActor*>(this)->finishSendAndDelPromiseRef();
		return 0;

		return loopDepth;
	}
	int a_body1when1(Optional<Value> const& __logUid,int loopDepth) 
	{
															#line 3248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
		logUid = __logUid;
															#line 33111 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	int a_body1when1(Optional<Value> && __logUid,int loopDepth) 
	{
		logUid = std::move(__logUid);
		loopDepth = a_body1cont1(loopDepth);

		return loopDepth;
	}
	void a_exitChoose1() 
	{
		if (static_cast<GetLogUidActor*>(this)->actor_wait_state > 0) static_cast<GetLogUidActor*>(this)->actor_wait_state = 0;
		static_cast<GetLogUidActor*>(this)->ActorCallback< GetLogUidActor, 0, Optional<Value> >::remove();

	}
	void a_callback_fire(ActorCallback< GetLogUidActor, 0, Optional<Value> >*,Optional<Value> const& value) 
	{
		fdb_probe_actor_enter("getLogUid", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(value, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getLogUid", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_fire(ActorCallback< GetLogUidActor, 0, Optional<Value> >*,Optional<Value> && value) 
	{
		fdb_probe_actor_enter("getLogUid", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1when1(std::move(value), 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getLogUid", reinterpret_cast<unsigned long>(this), 0);

	}
	void a_callback_error(ActorCallback< GetLogUidActor, 0, Optional<Value> >*,Error err) 
	{
		fdb_probe_actor_enter("getLogUid", reinterpret_cast<unsigned long>(this), 0);
		a_exitChoose1();
		try {
			a_body1Catch1(err, 0);
		}
		catch (Error& error) {
			a_body1Catch1(error, 0);
		} catch (...) {
			a_body1Catch1(unknown_error(), 0);
		}
		fdb_probe_actor_exit("getLogUid", reinterpret_cast<unsigned long>(this), 0);

	}
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	DatabaseBackupAgent* backupAgent;
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Reference<ReadYourWritesTransaction> tr;
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Key tagName;
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Snapshot snapshot;
															#line 3248 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	Optional<Value> logUid;
															#line 33184 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
};
// This generated class is to be used only via getLogUid()
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
class GetLogUidActor final : public Actor<UID>, public ActorCallback< GetLogUidActor, 0, Optional<Value> >, public FastAllocated<GetLogUidActor>, public GetLogUidActorState<GetLogUidActor> {
															#line 33189 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
public:
	using FastAllocated<GetLogUidActor>::operator new;
	using FastAllocated<GetLogUidActor>::operator delete;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdelete-non-virtual-dtor"
	void destroy() override { ((Actor<UID>*)this)->~Actor(); operator delete(this); }
#pragma clang diagnostic pop
friend struct ActorCallback< GetLogUidActor, 0, Optional<Value> >;
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	GetLogUidActor(DatabaseBackupAgent* const& backupAgent,Reference<ReadYourWritesTransaction> const& tr,Key const& tagName,Snapshot const& snapshot) 
															#line 33200 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
		 : Actor<UID>(),
		   GetLogUidActorState<GetLogUidActor>(backupAgent, tr, tagName, snapshot)
	{
		fdb_probe_actor_enter("getLogUid", reinterpret_cast<unsigned long>(this), -1);
		#ifdef ENABLE_SAMPLING
		this->lineage.setActorName("getLogUid");
		LineageScope _(&this->lineage);
		#endif
		this->a_body1();
		fdb_probe_actor_exit("getLogUid", reinterpret_cast<unsigned long>(this), -1);

	}
	void cancel() override
	{
		auto wait_state = this->actor_wait_state;
		this->actor_wait_state = -1;
		switch (wait_state) {
		case 1: this->a_callback_error((ActorCallback< GetLogUidActor, 0, Optional<Value> >*)0, actor_cancelled()); break;
		}

	}
};
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
[[nodiscard]] static Future<UID> getLogUid( DatabaseBackupAgent* const& backupAgent, Reference<ReadYourWritesTransaction> const& tr, Key const& tagName, Snapshot const& snapshot ) {
															#line 3242 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
	return Future<UID>(new GetLogUidActor(backupAgent, tr, tagName, snapshot));
															#line 33227 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.g.cpp"
}

#line 3252 "/usr/src/libfdb_c/fdbclient/DatabaseBackupAgent.actor.cpp"
};

Future<Void> DatabaseBackupAgent::unlockBackup(Reference<ReadYourWritesTransaction> tr, Key tagName) {
	return DatabaseBackupAgentImpl::unlockBackup(this, tr, tagName);
}

Future<Void> DatabaseBackupAgent::atomicSwitchover(Database dest,
                                                   Key tagName,
                                                   Standalone<VectorRef<KeyRangeRef>> backupRanges,
                                                   Key addPrefix,
                                                   Key removePrefix,
                                                   ForceAction forceAction) {
	return DatabaseBackupAgentImpl::atomicSwitchover(
	    this, dest, tagName, backupRanges, addPrefix, removePrefix, forceAction);
}

Future<Void> DatabaseBackupAgent::submitBackup(Reference<ReadYourWritesTransaction> tr,
                                               Key tagName,
                                               Standalone<VectorRef<KeyRangeRef>> backupRanges,
                                               StopWhenDone stopWhenDone,
                                               Key addPrefix,
                                               Key removePrefix,
                                               LockDB lockDatabase,
                                               PreBackupAction backupAction) {
	return DatabaseBackupAgentImpl::submitBackup(
	    this, tr, tagName, backupRanges, stopWhenDone, addPrefix, removePrefix, lockDatabase, backupAction);
}

Future<Void> DatabaseBackupAgent::discontinueBackup(Reference<ReadYourWritesTransaction> tr, Key tagName) {
	return DatabaseBackupAgentImpl::discontinueBackup(this, tr, tagName);
}

Future<Void> DatabaseBackupAgent::abortBackup(Database cx,
                                              Key tagName,
                                              PartialBackup partial,
                                              AbortOldBackup abortOldBackup,
                                              DstOnly dstOnly,
                                              WaitForDestUID waitForDestUID) {
	return DatabaseBackupAgentImpl::abortBackup(this, cx, tagName, partial, abortOldBackup, dstOnly, waitForDestUID);
}

Future<std::string> DatabaseBackupAgent::getStatus(Database cx, int errorLimit, Key tagName) {
	return DatabaseBackupAgentImpl::getStatus(this, cx, errorLimit, tagName);
}

Future<EBackupState> DatabaseBackupAgent::getStateValue(Reference<ReadYourWritesTransaction> tr,
                                                        UID logUid,
                                                        Snapshot snapshot) {
	return DatabaseBackupAgentImpl::getStateValue(this, tr, logUid, snapshot);
}

Future<UID> DatabaseBackupAgent::getDestUid(Reference<ReadYourWritesTransaction> tr, UID logUid, Snapshot snapshot) {
	return DatabaseBackupAgentImpl::getDestUid(this, tr, logUid, snapshot);
}

Future<UID> DatabaseBackupAgent::getLogUid(Reference<ReadYourWritesTransaction> tr, Key tagName, Snapshot snapshot) {
	return DatabaseBackupAgentImpl::getLogUid(this, tr, tagName, snapshot);
}

Future<Void> DatabaseBackupAgent::waitUpgradeToLatestDrVersion(Database cx, Key tagName) {
	return DatabaseBackupAgentImpl::waitUpgradeToLatestDrVersion(this, cx, tagName);
}

Future<EBackupState> DatabaseBackupAgent::waitBackup(Database cx, Key tagName, StopWhenDone stopWhenDone) {
	return DatabaseBackupAgentImpl::waitBackup(this, cx, tagName, stopWhenDone);
}

Future<EBackupState> DatabaseBackupAgent::waitSubmitted(Database cx, Key tagName) {
	return DatabaseBackupAgentImpl::waitSubmitted(this, cx, tagName);
}

Future<int64_t> DatabaseBackupAgent::getRangeBytesWritten(Reference<ReadYourWritesTransaction> tr,
                                                          UID logUid,
                                                          Snapshot snapshot) {
	return DRConfig(logUid).rangeBytesWritten().getD(tr, snapshot);
}

Future<int64_t> DatabaseBackupAgent::getLogBytesWritten(Reference<ReadYourWritesTransaction> tr,
                                                        UID logUid,
                                                        Snapshot snapshot) {
	return DRConfig(logUid).logBytesWritten().getD(tr, snapshot);
}
